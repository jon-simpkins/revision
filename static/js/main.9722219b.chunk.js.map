{"version":3,"sources":["protos_v2.js","features/revision-header/RevisionHeader.tsx","features/storyList/StoryCard.tsx","features/storyList/storyListPersistence.ts","features/storyList/storyListSlice.ts","app/hooks.ts","features/scrapList/scrapListPersistence.ts","features/scrapList/scrapListSlice.ts","pages/homepage/Homepage.tsx","features/utils/durationUtils.ts","features/storyDetails/StoryDetails.tsx","pages/story-details/StoryDetailsPage.tsx","pages/import-export/DataManagementPage.tsx","features/scrapDetails/usefulConstants.ts","features/scrapDetails/ScrapEmbedComponent.tsx","features/scrapDetails/BaseReadOnlyComponent.tsx","features/scrapDetails/FountainHeaderComponent.tsx","features/scrapDetails/FountainTransitionComponent.tsx","features/scrapDetails/FountainCenteredComponent.tsx","features/scrapDetails/FountainCharacterComponent.tsx","features/scrapDetails/FountainDialogueComponent.tsx","features/scrapDetails/FountainParentheticalComponent.tsx","features/scrapDetails/FountainActionComponent.tsx","features/scrapDetails/parseProse.ts","features/scrapDetails/CommentComponent.tsx","features/scrapDetails/foutainDecorators.ts","features/utils/fetchParsedContentBlocksForScrap.ts","features/scrapDetails/ReadOnlyViewer.tsx","features/timeline/timelineParsing.ts","features/timeline/Timeline.tsx","features/scrapDetails/ScrapDetails.tsx","pages/scrap-details/ScrapDetailsPage.tsx","pages/decisions/DecisionPage.tsx","App.tsx","app/store.ts","serviceWorker.ts","index.tsx"],"names":["define","$protobuf","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","Timestamp","properties","keys","Object","i","length","this","prototype","seconds","nanos","create","encode","message","writer","hasOwnProperty","call","uint32","int32","encodeDelimited","ldelim","decode","reader","end","undefined","len","pos","tag","skipType","decodeDelimited","verify","isInteger","fromObject","object","toObject","options","defaults","toJSON","constructor","toJSONOptions","Duration","Story","relatedStoryIds","id","name","description","duration","emptyArray","string","fork","push","isString","error","Array","isArray","String","TypeError","arrays","j","Scrap","stories","childScraps","intendedDurationSec","synopsis","prose","WritingWorkspace","scraps","RevisionHeader","Menu","to","Item","header","Icon","Component","StoryCard","props","story","getCardUrl","Card","style","margin","Content","split","map","line","idx","allStoryIdsKey","storyKey","readAllStoriesFromStorage","readStoryIds","storyString","localStorage","getItem","Error","JSON","parse","readStory","storyIdString","writeStoryIds","storyIds","setItem","stringify","writeStory","addStoryToStorage","allStoryIds","initialState","storyMap","forEach","fetchInitialStateFromStorage","actionPrefix","storyListSlice","createSlice","reducers","createStory","state","action","payload","updateStory","removeStory","storyListPersistenceMiddleware","storeAPI","next","result","type","startsWith","handleStoryListPersistence","idToRemove","filter","removeItem","selectStoryMap","compiledStoryMap","entries","storyList","key","value","actions","useAppDispatch","useDispatch","useAppSelector","useSelector","allScrapIdsKey","scrapKey","readAllScrapsFromStorage","readScrapIds","scrapString","readScrap","writeScrapIds","scrapIds","writeScrap","scrap","addScrapToStorage","allScrapIds","scrapMap","ScrapListSlice","createScrap","updateScrap","removeScrap","scrapListPersistenceMiddleware","handleScrapListPersistence","selectScrapMap","compiledScrapMap","scrapList","getStorySection","values","Segment","display","flexWrap","Homepage","dispatch","history","useHistory","Group","Header","size","Subheader","flex","textAlign","Button","icon","color","onClick","newStory","uuid","associatedStoryId","newScrap","durationSecondsToString","durationSeconds","durationStr","hours","Math","floor","toString","padStart","minutes","round","durationStringToSeconds","durationString","RegExp","test","splitDurationStr","Boolean","durationSec","parseInt","StoryDetails","durationErrorString","currentScrapFilter","currentScrapId","newName","onStoryChange","newDescription","newDuration","setDurationErrorString","hasError","setState","indexOf","linkUnlinkButton","currentScrap","find","editingScrap","storyId","onScrapUpdate","Container","text","marginTop","primary","onStoryDelete","Form","widths","Input","label","defaultValue","onChange","e","onNameChange","target","getDurationString","onDurationChange","Field","TextArea","onDescriptionChange","fontFamily","height","onScrapCreate","createNewScrap","pointing","vertical","Dropdown","fluid","selection","getFilteredScraps","active","marginLeft","renderScrapDetails","StoryDetailsPage","match","params","fetchedStory","topLevelScraps","downloadWorkspace","filename","Date","now","fileDownload","workspace","finish","loadDataFromStorage","files","a","arrayBuffer","fileData","loadDataToStorage","Uint8Array","window","location","reload","data","clear","DataManagementPage","accept","event","uploadWorkspace","ONE_LINE_DURATION_SEC","PAGE_WIDTH_EM","scrapIdField","ancestorField","durationSecContribution","isScrapEmbedding","scrapLink","isFountainHeader","isFountainCentered","isFountainTransition","isBlank","isComment","isFountainCharacter","character","isFountainDialogue","isFountainParenthetical","isFountainAction","FOUNTAIN_EDITOR_STYLE","border","padding","width","overflowY","fontSize","mergeDataObject","dataObject","newData","createChildScrap","parentScrapId","scrapId","parentStories","ScrapEmbedSummary","onGotoScrap","parseScrapIdFromProps","contentState","getBlockMap","get","blockKey","getData","BaseReadOnlyComponent","isHover","cursor","position","top","right","circular","paddingRight","backgroundColor","children","getParentStyle","onMouseEnter","onMouseLeave","renderSpecific","buildScrapLinkButton","fountainHeaderStrategy","contentBlock","callback","getText","sceneHeaderDurationSec","blockText","FountainHeaderComponent","fontWeight","FountainHeaderReadOnlyComponent","fountainTransitionStrategy","sceneTransitionDurationSec","FountainTransitionComponent","FountainTransitionReadOnlyComponent","fountainCenteredStrategy","sceneCenteredDurationSec","FountainCenteredComponent","FountainCenteredReadOnlyComponent","fountainCharacterStrategy","characterDurationSec","ceil","FountainCharacterComponent","FountainCharacterReadOnlyComponent","fountainDialogueStrategy","dialogueDurationSec","FountainDialogueComponent","FountainDialogueReadOnlyComponent","fountainParentheticalStrategy","parentheticalDurationSec","FountainParentheticalComponent","FountainParentheticalReadOnlyComponent","fountainActionStrategy","actionDurationSec","FountainActionComponent","FountainActionReadOnlyComponent","preProcessProseBlock","blockData","trim","checkIsCommentStart","endsWith","checkIsCommentEnd","set","Immutable","fromJS","processProseBlock","blockBefore","blockAfter","processProgress","toJS","blankBefore","blankAfter","characterBefore","currentDurationSec","checkIsSceneHeader","toUpperCase","checkIsSceneTransition","checkIsCentered","checkIsCharacter","checkIsDialogue","checkIsParenthetical","actionData","parentheticalData","dialogueData","parsedCharacter","characterData","sceneCenteredData","sceneTransitionData","sceneHeaderData","checkIsScrapEmbed","replace","scrapEmbedData","add","childScrap","updatedBlock","updatedCharacterList","getCharacterList","c","parseAllProse","warnParsingThreshold","errorParsingThreshold","newParseErrorState","processStartEpoch","OrderedSet","currentBlockMap","blockKeys","nextKey","timeSoFar","currentlyInComment","currentBlock","updatedData","update","newContent","durationMs","console","log","totalDurationSec","showTimeoutWarning","editorDecorator","CompositeDecorator","strategy","component","inComment","currentLocation","useLocation","pathname","textColor","background","fontStyle","viewerDecorator","fetchParsedContentBlocksForScrap","scrapAncestors","newAncestors","parseResult","ContentState","createFromText","allNewContentBlocks","getBlocksAsArray","block","embeddedScrapId","includes","subBlocks","ReadOnlyViewer","initializeState","editorState","buildInitialEditorState","prevProps","prevState","snapshot","EditorState","createEmpty","parsedBlocks","createWithContent","createFromBlockArray","readOnly","getScrapSynopsis","formatPercentString","percent","TimelineBlock","headerText","startSec","Popup","content","mouseEnterDelay","mouseLeaveDelay","trigger","boxShadow","left","zIndex","TimelineRow","blocks","zoomLevel","borderBottom","render","Timeline","isValid","rows","durationContribution","ancestors","lastBlockId","parseTimeline","numLevels","stepLevel","startingPoint","steps","nextContribution","secondMarkers","getSecondMarkers","markerTopPadding","overflowX","row","markerStyle","paddingTop","borderRight","paddingLeft","borderLeft","TimelineViewer","timeline","minimized","max","zoomOptions","zoomOut","disabled","zoomIn","marginBottom","flipMinimization","styleMap","ScrapDetails","domEditor","remapEditorContent","debounce","newStrToEmit","getCurrentContent","getPlainText","lastEmittedStr","persistProse","thisScrap","array","isArrayEqualToImmutableSet","toArray","currentContent","actualDurationSec","parseErrorState","parentScrapIds","buildParentScrapIds","durationInputKey","parentScraps","storyContribution","parentStoryLinks","parentStory","BreadcrumbSection","link","Breadcrumb","reduce","prev","curr","BreadcrumbDivider","scrapContribution","parentScrapLinks","parentScrap","newSynopsis","onSynopsisChange","updateExpectedDurationSec","parseWarning","addChildScrap","ref","focus","newState","selected","getFragmentFromSelection","x","join","editor","removeWhenDone","preventDefault","selectedText","getSelectedText","clipboard","then","newContentState","Modifier","replaceText","getSelection","newProseStr","currentSelection","currentlySelectedText","newScrapId","thingToInsert","isCollapsed","insertText","tabStyle","flexDirection","panes","menuItem","Tab","Pane","getBreadcrumbs","getPrimaryForm","getProseEditorToolbar","customStyleMap","stripPastedStyles","onCut","onCopy","setDomEditorRef","onProseChange","ScrapDetailsPage","DecisionPage","showListInput","showCurrentScores","nextCandidateLabel","nextCandidateDesc","candidates","winMatrix","candidateIndexA","candidateIndexB","newCandidates","currentScore","wins","losses","fill","indexAWeights","ignore","getTotalComparisons","indexA","randomSelectWeighted","indexBWeights","indexB","weights","sumWeight","previousValue","currentValue","randomCutoff","random","sum","index","totalComparisons","candidateA","candidateB","updateWin","winIndex","loseIndex","iteration","W_i","denominator","averageValue","setupNewComparison","sortedCandidates","candidate","sort","b","newValue","mainContent","updateNextCandidateLabel","updateNextCandidateDesc","addCandidate","renderCandidates","renderComparison","toggleShowCurrentScores","renderWinMatrix","App","path","store","configureStore","reducer","storyListReducer","scrapListReducer","middleware","getDefaultMiddleware","concat","hostname","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch"],"mappings":"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","file":"static/js/main.9722219b.chunk.js","sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n(function(global, factory) { /* global define, require, module */\n\n    /* AMD */ if (typeof define === 'function' && define.amd)\n        define([\"protobufjs/minimal\"], factory);\n\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)\n        module.exports = factory(require(\"protobufjs/minimal\"));\n\n})(this, function($protobuf) {\n    \"use strict\";\n\n    // Common aliases\n    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n    \n    // Exported root namespace\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    \n    $root.Timestamp = (function() {\n    \n        /**\n         * Properties of a Timestamp.\n         * @exports ITimestamp\n         * @interface ITimestamp\n         * @property {number|null} [seconds] Timestamp seconds\n         * @property {number|null} [nanos] Timestamp nanos\n         */\n    \n        /**\n         * Constructs a new Timestamp.\n         * @exports Timestamp\n         * @classdesc Represents a Timestamp.\n         * @implements ITimestamp\n         * @constructor\n         * @param {ITimestamp=} [properties] Properties to set\n         */\n        function Timestamp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Timestamp seconds.\n         * @member {number} seconds\n         * @memberof Timestamp\n         * @instance\n         */\n        Timestamp.prototype.seconds = 0;\n    \n        /**\n         * Timestamp nanos.\n         * @member {number} nanos\n         * @memberof Timestamp\n         * @instance\n         */\n        Timestamp.prototype.nanos = 0;\n    \n        /**\n         * Creates a new Timestamp instance using the specified properties.\n         * @function create\n         * @memberof Timestamp\n         * @static\n         * @param {ITimestamp=} [properties] Properties to set\n         * @returns {Timestamp} Timestamp instance\n         */\n        Timestamp.create = function create(properties) {\n            return new Timestamp(properties);\n        };\n    \n        /**\n         * Encodes the specified Timestamp message. Does not implicitly {@link Timestamp.verify|verify} messages.\n         * @function encode\n         * @memberof Timestamp\n         * @static\n         * @param {ITimestamp} message Timestamp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Timestamp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.seconds != null && Object.hasOwnProperty.call(message, \"seconds\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seconds);\n            if (message.nanos != null && Object.hasOwnProperty.call(message, \"nanos\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link Timestamp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Timestamp\n         * @static\n         * @param {ITimestamp} message Timestamp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Timestamp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Timestamp message from the specified reader or buffer.\n         * @function decode\n         * @memberof Timestamp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Timestamp} Timestamp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Timestamp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Timestamp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.seconds = reader.int32();\n                    break;\n                case 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Timestamp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Timestamp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Timestamp} Timestamp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Timestamp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Timestamp message.\n         * @function verify\n         * @memberof Timestamp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Timestamp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                if (!$util.isInteger(message.seconds))\n                    return \"seconds: integer expected\";\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                if (!$util.isInteger(message.nanos))\n                    return \"nanos: integer expected\";\n            return null;\n        };\n    \n        /**\n         * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Timestamp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Timestamp} Timestamp\n         */\n        Timestamp.fromObject = function fromObject(object) {\n            if (object instanceof $root.Timestamp)\n                return object;\n            var message = new $root.Timestamp();\n            if (object.seconds != null)\n                message.seconds = object.seconds | 0;\n            if (object.nanos != null)\n                message.nanos = object.nanos | 0;\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Timestamp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Timestamp\n         * @static\n         * @param {Timestamp} message Timestamp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Timestamp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.seconds = 0;\n                object.nanos = 0;\n            }\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                object.seconds = message.seconds;\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                object.nanos = message.nanos;\n            return object;\n        };\n    \n        /**\n         * Converts this Timestamp to JSON.\n         * @function toJSON\n         * @memberof Timestamp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Timestamp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return Timestamp;\n    })();\n    \n    $root.Duration = (function() {\n    \n        /**\n         * Properties of a Duration.\n         * @exports IDuration\n         * @interface IDuration\n         * @property {number|null} [seconds] Duration seconds\n         * @property {number|null} [nanos] Duration nanos\n         */\n    \n        /**\n         * Constructs a new Duration.\n         * @exports Duration\n         * @classdesc Represents a Duration.\n         * @implements IDuration\n         * @constructor\n         * @param {IDuration=} [properties] Properties to set\n         */\n        function Duration(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Duration seconds.\n         * @member {number} seconds\n         * @memberof Duration\n         * @instance\n         */\n        Duration.prototype.seconds = 0;\n    \n        /**\n         * Duration nanos.\n         * @member {number} nanos\n         * @memberof Duration\n         * @instance\n         */\n        Duration.prototype.nanos = 0;\n    \n        /**\n         * Creates a new Duration instance using the specified properties.\n         * @function create\n         * @memberof Duration\n         * @static\n         * @param {IDuration=} [properties] Properties to set\n         * @returns {Duration} Duration instance\n         */\n        Duration.create = function create(properties) {\n            return new Duration(properties);\n        };\n    \n        /**\n         * Encodes the specified Duration message. Does not implicitly {@link Duration.verify|verify} messages.\n         * @function encode\n         * @memberof Duration\n         * @static\n         * @param {IDuration} message Duration message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Duration.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.seconds != null && Object.hasOwnProperty.call(message, \"seconds\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seconds);\n            if (message.nanos != null && Object.hasOwnProperty.call(message, \"nanos\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Duration message, length delimited. Does not implicitly {@link Duration.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Duration\n         * @static\n         * @param {IDuration} message Duration message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Duration.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Duration message from the specified reader or buffer.\n         * @function decode\n         * @memberof Duration\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Duration} Duration\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Duration.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Duration();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.seconds = reader.int32();\n                    break;\n                case 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Duration message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Duration\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Duration} Duration\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Duration.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Duration message.\n         * @function verify\n         * @memberof Duration\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Duration.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                if (!$util.isInteger(message.seconds))\n                    return \"seconds: integer expected\";\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                if (!$util.isInteger(message.nanos))\n                    return \"nanos: integer expected\";\n            return null;\n        };\n    \n        /**\n         * Creates a Duration message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Duration\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Duration} Duration\n         */\n        Duration.fromObject = function fromObject(object) {\n            if (object instanceof $root.Duration)\n                return object;\n            var message = new $root.Duration();\n            if (object.seconds != null)\n                message.seconds = object.seconds | 0;\n            if (object.nanos != null)\n                message.nanos = object.nanos | 0;\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Duration message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Duration\n         * @static\n         * @param {Duration} message Duration\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Duration.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.seconds = 0;\n                object.nanos = 0;\n            }\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                object.seconds = message.seconds;\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                object.nanos = message.nanos;\n            return object;\n        };\n    \n        /**\n         * Converts this Duration to JSON.\n         * @function toJSON\n         * @memberof Duration\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Duration.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return Duration;\n    })();\n    \n    $root.Story = (function() {\n    \n        /**\n         * Properties of a Story.\n         * @exports IStory\n         * @interface IStory\n         * @property {string|null} [id] Story id\n         * @property {string|null} [name] Story name\n         * @property {string|null} [description] Story description\n         * @property {IDuration|null} [duration] Story duration\n         * @property {Array.<string>|null} [relatedStoryIds] Story relatedStoryIds\n         */\n    \n        /**\n         * Constructs a new Story.\n         * @exports Story\n         * @classdesc Represents a Story.\n         * @implements IStory\n         * @constructor\n         * @param {IStory=} [properties] Properties to set\n         */\n        function Story(properties) {\n            this.relatedStoryIds = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Story id.\n         * @member {string} id\n         * @memberof Story\n         * @instance\n         */\n        Story.prototype.id = \"\";\n    \n        /**\n         * Story name.\n         * @member {string} name\n         * @memberof Story\n         * @instance\n         */\n        Story.prototype.name = \"\";\n    \n        /**\n         * Story description.\n         * @member {string} description\n         * @memberof Story\n         * @instance\n         */\n        Story.prototype.description = \"\";\n    \n        /**\n         * Story duration.\n         * @member {IDuration|null|undefined} duration\n         * @memberof Story\n         * @instance\n         */\n        Story.prototype.duration = null;\n    \n        /**\n         * Story relatedStoryIds.\n         * @member {Array.<string>} relatedStoryIds\n         * @memberof Story\n         * @instance\n         */\n        Story.prototype.relatedStoryIds = $util.emptyArray;\n    \n        /**\n         * Creates a new Story instance using the specified properties.\n         * @function create\n         * @memberof Story\n         * @static\n         * @param {IStory=} [properties] Properties to set\n         * @returns {Story} Story instance\n         */\n        Story.create = function create(properties) {\n            return new Story(properties);\n        };\n    \n        /**\n         * Encodes the specified Story message. Does not implicitly {@link Story.verify|verify} messages.\n         * @function encode\n         * @memberof Story\n         * @static\n         * @param {IStory} message Story message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Story.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n            if (message.duration != null && Object.hasOwnProperty.call(message, \"duration\"))\n                $root.Duration.encode(message.duration, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.relatedStoryIds != null && message.relatedStoryIds.length)\n                for (var i = 0; i < message.relatedStoryIds.length; ++i)\n                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.relatedStoryIds[i]);\n            if (message.description != null && Object.hasOwnProperty.call(message, \"description\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Story message, length delimited. Does not implicitly {@link Story.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Story\n         * @static\n         * @param {IStory} message Story message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Story.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Story message from the specified reader or buffer.\n         * @function decode\n         * @memberof Story\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Story} Story\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Story.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Story();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                case 5:\n                    message.description = reader.string();\n                    break;\n                case 3:\n                    message.duration = $root.Duration.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.relatedStoryIds && message.relatedStoryIds.length))\n                        message.relatedStoryIds = [];\n                    message.relatedStoryIds.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Story message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Story\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Story} Story\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Story.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Story message.\n         * @function verify\n         * @memberof Story\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Story.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                if (!$util.isString(message.id))\n                    return \"id: string expected\";\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.description != null && message.hasOwnProperty(\"description\"))\n                if (!$util.isString(message.description))\n                    return \"description: string expected\";\n            if (message.duration != null && message.hasOwnProperty(\"duration\")) {\n                var error = $root.Duration.verify(message.duration);\n                if (error)\n                    return \"duration.\" + error;\n            }\n            if (message.relatedStoryIds != null && message.hasOwnProperty(\"relatedStoryIds\")) {\n                if (!Array.isArray(message.relatedStoryIds))\n                    return \"relatedStoryIds: array expected\";\n                for (var i = 0; i < message.relatedStoryIds.length; ++i)\n                    if (!$util.isString(message.relatedStoryIds[i]))\n                        return \"relatedStoryIds: string[] expected\";\n            }\n            return null;\n        };\n    \n        /**\n         * Creates a Story message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Story\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Story} Story\n         */\n        Story.fromObject = function fromObject(object) {\n            if (object instanceof $root.Story)\n                return object;\n            var message = new $root.Story();\n            if (object.id != null)\n                message.id = String(object.id);\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.description != null)\n                message.description = String(object.description);\n            if (object.duration != null) {\n                if (typeof object.duration !== \"object\")\n                    throw TypeError(\".Story.duration: object expected\");\n                message.duration = $root.Duration.fromObject(object.duration);\n            }\n            if (object.relatedStoryIds) {\n                if (!Array.isArray(object.relatedStoryIds))\n                    throw TypeError(\".Story.relatedStoryIds: array expected\");\n                message.relatedStoryIds = [];\n                for (var i = 0; i < object.relatedStoryIds.length; ++i)\n                    message.relatedStoryIds[i] = String(object.relatedStoryIds[i]);\n            }\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Story message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Story\n         * @static\n         * @param {Story} message Story\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Story.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.relatedStoryIds = [];\n            if (options.defaults) {\n                object.id = \"\";\n                object.name = \"\";\n                object.duration = null;\n                object.description = \"\";\n            }\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                object.id = message.id;\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.duration != null && message.hasOwnProperty(\"duration\"))\n                object.duration = $root.Duration.toObject(message.duration, options);\n            if (message.relatedStoryIds && message.relatedStoryIds.length) {\n                object.relatedStoryIds = [];\n                for (var j = 0; j < message.relatedStoryIds.length; ++j)\n                    object.relatedStoryIds[j] = message.relatedStoryIds[j];\n            }\n            if (message.description != null && message.hasOwnProperty(\"description\"))\n                object.description = message.description;\n            return object;\n        };\n    \n        /**\n         * Converts this Story to JSON.\n         * @function toJSON\n         * @memberof Story\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Story.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return Story;\n    })();\n    \n    $root.Scrap = (function() {\n    \n        /**\n         * Properties of a Scrap.\n         * @exports IScrap\n         * @interface IScrap\n         * @property {string|null} [id] Scrap id\n         * @property {number|null} [intendedDurationSec] Scrap intendedDurationSec\n         * @property {string|null} [synopsis] Scrap synopsis\n         * @property {string|null} [prose] Scrap prose\n         * @property {Array.<string>|null} [stories] Scrap stories\n         * @property {Array.<string>|null} [childScraps] Scrap childScraps\n         */\n    \n        /**\n         * Constructs a new Scrap.\n         * @exports Scrap\n         * @classdesc Represents a Scrap.\n         * @implements IScrap\n         * @constructor\n         * @param {IScrap=} [properties] Properties to set\n         */\n        function Scrap(properties) {\n            this.stories = [];\n            this.childScraps = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Scrap id.\n         * @member {string} id\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.id = \"\";\n    \n        /**\n         * Scrap intendedDurationSec.\n         * @member {number} intendedDurationSec\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.intendedDurationSec = 0;\n    \n        /**\n         * Scrap synopsis.\n         * @member {string} synopsis\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.synopsis = \"\";\n    \n        /**\n         * Scrap prose.\n         * @member {string} prose\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.prose = \"\";\n    \n        /**\n         * Scrap stories.\n         * @member {Array.<string>} stories\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.stories = $util.emptyArray;\n    \n        /**\n         * Scrap childScraps.\n         * @member {Array.<string>} childScraps\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.childScraps = $util.emptyArray;\n    \n        /**\n         * Creates a new Scrap instance using the specified properties.\n         * @function create\n         * @memberof Scrap\n         * @static\n         * @param {IScrap=} [properties] Properties to set\n         * @returns {Scrap} Scrap instance\n         */\n        Scrap.create = function create(properties) {\n            return new Scrap(properties);\n        };\n    \n        /**\n         * Encodes the specified Scrap message. Does not implicitly {@link Scrap.verify|verify} messages.\n         * @function encode\n         * @memberof Scrap\n         * @static\n         * @param {IScrap} message Scrap message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Scrap.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n            if (message.intendedDurationSec != null && Object.hasOwnProperty.call(message, \"intendedDurationSec\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.intendedDurationSec);\n            if (message.synopsis != null && Object.hasOwnProperty.call(message, \"synopsis\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.synopsis);\n            if (message.prose != null && Object.hasOwnProperty.call(message, \"prose\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.prose);\n            if (message.stories != null && message.stories.length)\n                for (var i = 0; i < message.stories.length; ++i)\n                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.stories[i]);\n            if (message.childScraps != null && message.childScraps.length)\n                for (var i = 0; i < message.childScraps.length; ++i)\n                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.childScraps[i]);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Scrap message, length delimited. Does not implicitly {@link Scrap.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Scrap\n         * @static\n         * @param {IScrap} message Scrap message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Scrap.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Scrap message from the specified reader or buffer.\n         * @function decode\n         * @memberof Scrap\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Scrap} Scrap\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Scrap.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Scrap();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.intendedDurationSec = reader.uint32();\n                    break;\n                case 3:\n                    message.synopsis = reader.string();\n                    break;\n                case 4:\n                    message.prose = reader.string();\n                    break;\n                case 8:\n                    if (!(message.stories && message.stories.length))\n                        message.stories = [];\n                    message.stories.push(reader.string());\n                    break;\n                case 9:\n                    if (!(message.childScraps && message.childScraps.length))\n                        message.childScraps = [];\n                    message.childScraps.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Scrap message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Scrap\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Scrap} Scrap\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Scrap.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Scrap message.\n         * @function verify\n         * @memberof Scrap\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Scrap.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                if (!$util.isString(message.id))\n                    return \"id: string expected\";\n            if (message.intendedDurationSec != null && message.hasOwnProperty(\"intendedDurationSec\"))\n                if (!$util.isInteger(message.intendedDurationSec))\n                    return \"intendedDurationSec: integer expected\";\n            if (message.synopsis != null && message.hasOwnProperty(\"synopsis\"))\n                if (!$util.isString(message.synopsis))\n                    return \"synopsis: string expected\";\n            if (message.prose != null && message.hasOwnProperty(\"prose\"))\n                if (!$util.isString(message.prose))\n                    return \"prose: string expected\";\n            if (message.stories != null && message.hasOwnProperty(\"stories\")) {\n                if (!Array.isArray(message.stories))\n                    return \"stories: array expected\";\n                for (var i = 0; i < message.stories.length; ++i)\n                    if (!$util.isString(message.stories[i]))\n                        return \"stories: string[] expected\";\n            }\n            if (message.childScraps != null && message.hasOwnProperty(\"childScraps\")) {\n                if (!Array.isArray(message.childScraps))\n                    return \"childScraps: array expected\";\n                for (var i = 0; i < message.childScraps.length; ++i)\n                    if (!$util.isString(message.childScraps[i]))\n                        return \"childScraps: string[] expected\";\n            }\n            return null;\n        };\n    \n        /**\n         * Creates a Scrap message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Scrap\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Scrap} Scrap\n         */\n        Scrap.fromObject = function fromObject(object) {\n            if (object instanceof $root.Scrap)\n                return object;\n            var message = new $root.Scrap();\n            if (object.id != null)\n                message.id = String(object.id);\n            if (object.intendedDurationSec != null)\n                message.intendedDurationSec = object.intendedDurationSec >>> 0;\n            if (object.synopsis != null)\n                message.synopsis = String(object.synopsis);\n            if (object.prose != null)\n                message.prose = String(object.prose);\n            if (object.stories) {\n                if (!Array.isArray(object.stories))\n                    throw TypeError(\".Scrap.stories: array expected\");\n                message.stories = [];\n                for (var i = 0; i < object.stories.length; ++i)\n                    message.stories[i] = String(object.stories[i]);\n            }\n            if (object.childScraps) {\n                if (!Array.isArray(object.childScraps))\n                    throw TypeError(\".Scrap.childScraps: array expected\");\n                message.childScraps = [];\n                for (var i = 0; i < object.childScraps.length; ++i)\n                    message.childScraps[i] = String(object.childScraps[i]);\n            }\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Scrap message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Scrap\n         * @static\n         * @param {Scrap} message Scrap\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Scrap.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.stories = [];\n                object.childScraps = [];\n            }\n            if (options.defaults) {\n                object.id = \"\";\n                object.intendedDurationSec = 0;\n                object.synopsis = \"\";\n                object.prose = \"\";\n            }\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                object.id = message.id;\n            if (message.intendedDurationSec != null && message.hasOwnProperty(\"intendedDurationSec\"))\n                object.intendedDurationSec = message.intendedDurationSec;\n            if (message.synopsis != null && message.hasOwnProperty(\"synopsis\"))\n                object.synopsis = message.synopsis;\n            if (message.prose != null && message.hasOwnProperty(\"prose\"))\n                object.prose = message.prose;\n            if (message.stories && message.stories.length) {\n                object.stories = [];\n                for (var j = 0; j < message.stories.length; ++j)\n                    object.stories[j] = message.stories[j];\n            }\n            if (message.childScraps && message.childScraps.length) {\n                object.childScraps = [];\n                for (var j = 0; j < message.childScraps.length; ++j)\n                    object.childScraps[j] = message.childScraps[j];\n            }\n            return object;\n        };\n    \n        /**\n         * Converts this Scrap to JSON.\n         * @function toJSON\n         * @memberof Scrap\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Scrap.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return Scrap;\n    })();\n    \n    $root.WritingWorkspace = (function() {\n    \n        /**\n         * Properties of a WritingWorkspace.\n         * @exports IWritingWorkspace\n         * @interface IWritingWorkspace\n         * @property {Array.<IStory>|null} [stories] WritingWorkspace stories\n         * @property {Array.<IScrap>|null} [scraps] WritingWorkspace scraps\n         */\n    \n        /**\n         * Constructs a new WritingWorkspace.\n         * @exports WritingWorkspace\n         * @classdesc Represents a WritingWorkspace.\n         * @implements IWritingWorkspace\n         * @constructor\n         * @param {IWritingWorkspace=} [properties] Properties to set\n         */\n        function WritingWorkspace(properties) {\n            this.stories = [];\n            this.scraps = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * WritingWorkspace stories.\n         * @member {Array.<IStory>} stories\n         * @memberof WritingWorkspace\n         * @instance\n         */\n        WritingWorkspace.prototype.stories = $util.emptyArray;\n    \n        /**\n         * WritingWorkspace scraps.\n         * @member {Array.<IScrap>} scraps\n         * @memberof WritingWorkspace\n         * @instance\n         */\n        WritingWorkspace.prototype.scraps = $util.emptyArray;\n    \n        /**\n         * Creates a new WritingWorkspace instance using the specified properties.\n         * @function create\n         * @memberof WritingWorkspace\n         * @static\n         * @param {IWritingWorkspace=} [properties] Properties to set\n         * @returns {WritingWorkspace} WritingWorkspace instance\n         */\n        WritingWorkspace.create = function create(properties) {\n            return new WritingWorkspace(properties);\n        };\n    \n        /**\n         * Encodes the specified WritingWorkspace message. Does not implicitly {@link WritingWorkspace.verify|verify} messages.\n         * @function encode\n         * @memberof WritingWorkspace\n         * @static\n         * @param {IWritingWorkspace} message WritingWorkspace message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        WritingWorkspace.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.stories != null && message.stories.length)\n                for (var i = 0; i < message.stories.length; ++i)\n                    $root.Story.encode(message.stories[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.scraps != null && message.scraps.length)\n                for (var i = 0; i < message.scraps.length; ++i)\n                    $root.Scrap.encode(message.scraps[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified WritingWorkspace message, length delimited. Does not implicitly {@link WritingWorkspace.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof WritingWorkspace\n         * @static\n         * @param {IWritingWorkspace} message WritingWorkspace message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        WritingWorkspace.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a WritingWorkspace message from the specified reader or buffer.\n         * @function decode\n         * @memberof WritingWorkspace\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {WritingWorkspace} WritingWorkspace\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        WritingWorkspace.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WritingWorkspace();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.stories && message.stories.length))\n                        message.stories = [];\n                    message.stories.push($root.Story.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    if (!(message.scraps && message.scraps.length))\n                        message.scraps = [];\n                    message.scraps.push($root.Scrap.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a WritingWorkspace message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof WritingWorkspace\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {WritingWorkspace} WritingWorkspace\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        WritingWorkspace.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a WritingWorkspace message.\n         * @function verify\n         * @memberof WritingWorkspace\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        WritingWorkspace.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.stories != null && message.hasOwnProperty(\"stories\")) {\n                if (!Array.isArray(message.stories))\n                    return \"stories: array expected\";\n                for (var i = 0; i < message.stories.length; ++i) {\n                    var error = $root.Story.verify(message.stories[i]);\n                    if (error)\n                        return \"stories.\" + error;\n                }\n            }\n            if (message.scraps != null && message.hasOwnProperty(\"scraps\")) {\n                if (!Array.isArray(message.scraps))\n                    return \"scraps: array expected\";\n                for (var i = 0; i < message.scraps.length; ++i) {\n                    var error = $root.Scrap.verify(message.scraps[i]);\n                    if (error)\n                        return \"scraps.\" + error;\n                }\n            }\n            return null;\n        };\n    \n        /**\n         * Creates a WritingWorkspace message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof WritingWorkspace\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {WritingWorkspace} WritingWorkspace\n         */\n        WritingWorkspace.fromObject = function fromObject(object) {\n            if (object instanceof $root.WritingWorkspace)\n                return object;\n            var message = new $root.WritingWorkspace();\n            if (object.stories) {\n                if (!Array.isArray(object.stories))\n                    throw TypeError(\".WritingWorkspace.stories: array expected\");\n                message.stories = [];\n                for (var i = 0; i < object.stories.length; ++i) {\n                    if (typeof object.stories[i] !== \"object\")\n                        throw TypeError(\".WritingWorkspace.stories: object expected\");\n                    message.stories[i] = $root.Story.fromObject(object.stories[i]);\n                }\n            }\n            if (object.scraps) {\n                if (!Array.isArray(object.scraps))\n                    throw TypeError(\".WritingWorkspace.scraps: array expected\");\n                message.scraps = [];\n                for (var i = 0; i < object.scraps.length; ++i) {\n                    if (typeof object.scraps[i] !== \"object\")\n                        throw TypeError(\".WritingWorkspace.scraps: object expected\");\n                    message.scraps[i] = $root.Scrap.fromObject(object.scraps[i]);\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a WritingWorkspace message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof WritingWorkspace\n         * @static\n         * @param {WritingWorkspace} message WritingWorkspace\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        WritingWorkspace.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.stories = [];\n                object.scraps = [];\n            }\n            if (message.stories && message.stories.length) {\n                object.stories = [];\n                for (var j = 0; j < message.stories.length; ++j)\n                    object.stories[j] = $root.Story.toObject(message.stories[j], options);\n            }\n            if (message.scraps && message.scraps.length) {\n                object.scraps = [];\n                for (var j = 0; j < message.scraps.length; ++j)\n                    object.scraps[j] = $root.Scrap.toObject(message.scraps[j], options);\n            }\n            return object;\n        };\n    \n        /**\n         * Converts this WritingWorkspace to JSON.\n         * @function toJSON\n         * @memberof WritingWorkspace\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        WritingWorkspace.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return WritingWorkspace;\n    })();\n\n    return $root;\n});\n","import React, {Component} from 'react';\nimport {\n  Link\n} from 'react-router-dom';\nimport {Icon, Menu} from 'semantic-ui-react';\n\nexport default class RevisionHeader extends Component {\n\n  render() {\n    return (\n        <Menu>\n          <Link to={'/'}>\n            <Menu.Item header>Revision</Menu.Item>\n          </Link>\n          <Link to={'/data'}>\n            <Menu.Item>\n              <Icon name=\"save\" />\n            </Menu.Item>\n          </Link>\n        </Menu>\n    );\n  }\n}\n","import React, {Component} from 'react';\nimport {\n  Link\n} from 'react-router-dom';\nimport { Card } from 'semantic-ui-react';\nimport {Story} from '../../protos_v2';\n\ninterface StoryCardProps {\n  story: Story;\n}\n\nexport default class StoryCard extends Component<StoryCardProps> {\n  getCardUrl(): string {\n    return '/story/' + this.props.story.id;\n  }\n\n  render() {\n    return (\n      <Link to={this.getCardUrl()}>\n        <Card style={{margin: '8px'}}>\n          <Card.Content header={this.props.story.name} />\n          <Card.Content>\n            {/* For each line of the description, print it in a paragraph */}\n            {this.props.story.description.split('\\n').map((line, idx) => {\n              return (<p key={idx}>{line}</p>);\n            })}\n          </Card.Content>\n        </Card>\n      </Link>\n    );\n  }\n}\n","import {IStory, Story} from '../../protos_v2';\nimport {StoryMapInState} from './storyListSlice';\n\nconst allStoryIdsKey = 'story-ids';\n\nfunction storyKey(id: string): string {\n  return `story-${id}`;\n}\n\nexport function readAllStoriesFromStorage(): Story[] {\n  return readStoryIds().map((id) => {\n    return readStory(id);\n  });\n}\n\nfunction readStoryIds(): string[] {\n  let storyIdString = localStorage.getItem(allStoryIdsKey) || '[]';\n  return JSON.parse(storyIdString) as string[];\n}\n\nfunction writeStoryIds(storyIds: string[]): void {\n  localStorage.setItem(allStoryIdsKey, JSON.stringify(storyIds));\n}\n\nfunction readStory(id: string): Story {\n  let storyString = localStorage.getItem(storyKey(id));\n  if (!storyString) {\n    throw Error(`Unable to read story ${id} from local storage`);\n  }\n\n  return Story.create(JSON.parse(storyString));\n}\n\nexport function writeStory(story: IStory) {\n  localStorage.setItem(storyKey(story.id as string), JSON.stringify(story));\n}\n\nexport function addStoryToStorage(story: IStory): void {\n  writeStory(story);\n\n  const allStoryIds = readStoryIds();\n  allStoryIds.push(story.id as string);\n  writeStoryIds(allStoryIds);\n}\n\nexport function clearStoryFromStorage(idToRemove: string): void {\n  let allStoryIds = readStoryIds();\n\n  writeStoryIds(allStoryIds.filter((id) => {\n    return id !== idToRemove;\n  }));\n\n  localStorage.removeItem(storyKey(idToRemove));\n}\n\nexport function fetchInitialStateFromStorage() {\n  const initialState = {\n    storyMap: {} as StoryMapInState\n  };\n  readAllStoriesFromStorage().forEach((story) => {\n    initialState.storyMap[story.id] = story.toJSON();\n  });\n\n  return initialState;\n}\n\n","import {createSlice, Middleware, PayloadAction} from '@reduxjs/toolkit';\nimport {RootState} from '../../app/store';\nimport {IStory, Story} from '../../protos_v2';\nimport {addStoryToStorage, clearStoryFromStorage, fetchInitialStateFromStorage, writeStory} from './storyListPersistence';\n\nexport interface StoryMap {\n  [key: string]: Story;\n}\n\nexport interface StoryMapInState {\n  [key: string]: IStory\n}\n\ninterface storyListInState {\n  storyList: {\n    storyMap: StoryMapInState\n  }\n}\n\nconst initialState = fetchInitialStateFromStorage();\n\nconst actionPrefix = 'storyList';\n\nconst storyListSlice = createSlice({\n  name: actionPrefix,\n  initialState,\n  reducers: {\n    createStory(state, action: PayloadAction<IStory>) {\n      state.storyMap[action.payload.id as string] = action.payload;\n    },\n    updateStory(state, action: PayloadAction<IStory>) {\n      state.storyMap[action.payload.id as string] = action.payload;\n    },\n    removeStory(state, action: PayloadAction<string>) {\n      delete state.storyMap[action.payload];\n    }\n  }\n});\n\nexport const storyListPersistenceMiddleware: Middleware<{}, storyListInState>\n    = storeAPI => next => action => {\n  let result = next(action);\n\n  if (action.type.startsWith(actionPrefix + '/')) {\n    handleStoryListPersistence(action);\n  }\n\n  return result;\n}\n\nexport const handleStoryListPersistence = (action: PayloadAction<string|IStory>) => {\n  switch (action.type) {\n    case `${actionPrefix}/createStory`:\n      addStoryToStorage(action.payload as IStory);\n      break;\n    case `${actionPrefix}/updateStory`:\n      writeStory(action.payload as IStory);\n      break;\n    case `${actionPrefix}/removeStory`:\n      clearStoryFromStorage(action.payload as string);\n      break;\n  }\n}\n\n// Selector for fetching full map of stories\nexport const selectStoryMap = (state: storyListInState|RootState): StoryMap => {\n  const compiledStoryMap: StoryMap = {};\n\n  for (const [key, value] of Object.entries(state.storyList.storyMap)) {\n    compiledStoryMap[key] = Story.fromObject(value);\n  }\n\n  return compiledStoryMap;\n}\n\n// Creates selector for particular story\nexport const selectSpecificStory = (id: string) => (state: storyListInState|RootState): Story|null => {\n  const fetchedStory = state.storyList.storyMap[id];\n\n  if (!fetchedStory) {\n    return null;\n  }\n\n  return Story.create(fetchedStory);\n}\n\nexport const { createStory, updateStory, removeStory } = storyListSlice.actions;\nexport default storyListSlice.reducer;\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import {IScrap, Scrap} from '../../protos_v2';\nimport {ScrapMapInState} from './scrapListSlice';\n\nconst allScrapIdsKey = 'scrap-ids';\n\nfunction scrapKey(id: string): string {\n  return `scrap-${id}`;\n}\n\nexport function readAllScrapsFromStorage(): Scrap[] {\n  return readScrapIds().map((id) => {\n    return readScrap(id);\n  });\n}\n\nfunction readScrapIds(): string[] {\n  let storyIdString = localStorage.getItem(allScrapIdsKey) || '[]';\n  return JSON.parse(storyIdString) as string[];\n}\n\nfunction writeScrapIds(scrapIds: string[]): void {\n  localStorage.setItem(allScrapIdsKey, JSON.stringify(scrapIds));\n}\n\nfunction readScrap(id: string): Scrap {\n  let scrapString = localStorage.getItem(scrapKey(id));\n  if (!scrapString) {\n    throw Error(`Unable to read scrap ${id} from local storage`);\n  }\n\n  return Scrap.create(JSON.parse(scrapString));\n}\n\nexport function writeScrap(scrap: IScrap) {\n  localStorage.setItem(scrapKey(scrap.id as string), JSON.stringify(scrap));\n}\n\nexport function addScrapToStorage(scrap: IScrap): void {\n  writeScrap(scrap);\n\n  const allScrapIds = readScrapIds();\n  allScrapIds.push(scrap.id as string);\n  writeScrapIds(allScrapIds);\n}\n\n\nexport function clearScrapFromStorage(idToRemove: string): void {\n  let allScrapIds = readScrapIds();\n\n  writeScrapIds(allScrapIds.filter((id) => {\n    return id !== idToRemove;\n  }));\n\n  localStorage.removeItem(scrapKey(idToRemove));\n}\n\nexport function fetchInitialStateFromStorage() {\n  const initialState = {\n    scrapMap: {} as ScrapMapInState\n  };\n  readAllScrapsFromStorage().forEach((scrap) => {\n    initialState.scrapMap[scrap.id] = scrap.toJSON();\n  });\n\n  return initialState;\n}\n","import {createSlice, Middleware, PayloadAction} from '@reduxjs/toolkit';\nimport {RootState} from '../../app/store';\nimport {IScrap, Scrap} from '../../protos_v2';\nimport {addScrapToStorage, clearScrapFromStorage, fetchInitialStateFromStorage, writeScrap} from './scrapListPersistence';\n\nexport interface ScrapMap {\n  [key: string]: Scrap;\n}\n\nexport interface ScrapMapInState {\n  [key: string]: IScrap\n}\n\ninterface ScrapListInState {\n  scrapList: {\n    scrapMap: ScrapMapInState\n  }\n}\n\nconst initialState = fetchInitialStateFromStorage();\n\nconst actionPrefix = 'scrapList';\n\nconst ScrapListSlice = createSlice({\n  name: actionPrefix,\n  initialState,\n  reducers: {\n    createScrap(state, action: PayloadAction<IScrap>) {\n      state.scrapMap[action.payload.id as string] = action.payload;\n    },\n    updateScrap(state, action: PayloadAction<IScrap>) {\n      state.scrapMap[action.payload.id as string] = action.payload;\n    },\n    removeScrap(state, action: PayloadAction<string>) {\n      delete state.scrapMap[action.payload];\n    }\n  }\n});\n\nexport const scrapListPersistenceMiddleware: Middleware<{}, ScrapListInState>\n    = storeAPI => next => action => {\n  let result = next(action);\n\n  if (action.type.startsWith(actionPrefix + '/')) {\n    handleScrapListPersistence(action);\n  }\n\n  return result;\n}\n\nexport const handleScrapListPersistence = (action: PayloadAction<string|IScrap>) => {\n  switch (action.type) {\n    case `${actionPrefix}/createScrap`:\n      addScrapToStorage(action.payload as IScrap);\n      break;\n    case `${actionPrefix}/updateScrap`:\n      writeScrap(action.payload as IScrap);\n      break;\n    case `${actionPrefix}/removeScrap`:\n      clearScrapFromStorage(action.payload as string);\n      break;\n  }\n}\n\n// Selector for fetching full map of stories\nexport const selectScrapMap = (state: ScrapListInState|RootState): ScrapMap => {\n  const compiledScrapMap: ScrapMap = {};\n\n  for (const [key, value] of Object.entries(state.scrapList.scrapMap)) {\n    compiledScrapMap[key] = Scrap.fromObject(value);\n  }\n\n  return compiledScrapMap;\n}\n\n// Creates selector for particular Scrap\nexport const selectSpecificScrap = (id: string) => (state: ScrapListInState|RootState): Scrap|null => {\n  const fetchedScrap = state.scrapList.scrapMap[id];\n\n  if (!fetchedScrap) {\n    return null;\n  }\n\n  return Scrap.create(fetchedScrap);\n}\n\nexport const { createScrap, updateScrap, removeScrap } = ScrapListSlice.actions;\nexport default ScrapListSlice.reducer;\n","import StoryCard from '../../features/storyList/StoryCard';\nimport {Button, Header, Icon, Segment} from 'semantic-ui-react';\nimport { useHistory } from 'react-router-dom';\nimport {createStory, selectStoryMap, StoryMap} from '../../features/storyList/storyListSlice';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {IScrap, IStory, Scrap, Story} from '../../protos_v2';\nimport { v4 as uuid } from 'uuid';\nimport {createScrap} from '../../features/scrapList/scrapListSlice';\n\nfunction createNewStory(): IStory {\n  return Story.create({\n    id: uuid(),\n    name: 'New Story',\n    description: 'A story about something'\n  }).toJSON();\n}\n\nfunction createNewScrap(associatedStoryId: string): IScrap {\n  return Scrap.create({\n    id: uuid(),\n    synopsis: 'Story Content',\n    prose: 'Here is where you can summarize the story, and start to structure / brainstorm\\n'\n      + 'Feel free to create new scraps for alternative starting points, or new supporting docs '\n      + 'for this story.',\n    stories: [associatedStoryId]\n  }).toJSON();\n}\n\nfunction getStorySection(storyMap: StoryMap): JSX.Element {\n  const storyList = Object.values(storyMap);\n\n  if (!storyList.length) {\n    return (\n        <Segment>Whoops, no stories yet</Segment>\n    );\n  }\n\n  return <Segment style={{display: 'flex', flexWrap: 'wrap'}}>\n    {storyList.map((story, idx) => {\n      return (\n          <StoryCard key={idx} story={story} />\n      );\n    })}\n  </Segment>\n}\n\nexport default function Homepage() {\n  const storyMap = useAppSelector(selectStoryMap);\n  const dispatch = useAppDispatch();\n  const history = useHistory();\n\n  return (\n      <div style={{margin: '24px'}}>\n        <Segment.Group >\n          <Segment style={{display: 'flex'}}>\n            <Header size='medium'>Story List\n              <Header.Subheader>\n                All your stories\n              </Header.Subheader>\n            </Header>\n            <div style={{flex: 1, textAlign: 'right'}}>\n              <Button icon color='green'\n                onClick={() => {\n                  const newStory = createNewStory();\n                  dispatch(createStory(newStory));\n                  const newScrap = createNewScrap(newStory.id as string);\n                  dispatch(createScrap(newScrap));\n\n                  history.push(`/story/${newStory.id}`);\n                }}\n              >\n                <Icon name='add' />\n              </Button>\n            </div>\n          </Segment>\n          {getStorySection(storyMap)}\n        </Segment.Group>\n      </div>\n  );\n}\n","\n\nexport function durationSecondsToString(durationSeconds: number): string {\n  let durationStr = '';\n\n  const hours = Math.floor(durationSeconds / 3600);\n  durationSeconds -= 3600 * hours;\n  durationStr += hours.toString().padStart(2, '0') + ':';\n\n  const minutes = Math.floor(durationSeconds / 60);\n  durationSeconds -= 60 * minutes;\n  durationStr += minutes.toString().padStart(2, '0') + ':';\n\n  durationStr += Math.round(durationSeconds).toString().padStart(2, '0');\n\n  return durationStr;\n}\n\nexport function durationStringToSeconds(durationString: string): number {\n  const expectedRegex = new RegExp('^[0-9:]+$');\n  if (!expectedRegex.test(durationString)) {\n    throw Error('Invalid duration string');\n  }\n\n  const splitDurationStr = durationString.split(':').filter(Boolean);\n\n  if (splitDurationStr.length > 3) {\n    throw Error('Invalid duration string');\n  }\n\n  let durationSec = 0;\n  for (let i = 0; i < splitDurationStr.length; i++) {\n    durationSec = (60 * durationSec) + parseInt(splitDurationStr[i], 10);\n  }\n\n  return durationSec;\n}\n","import React, {Component, ReactNode} from 'react';\nimport {Button, Container, Dropdown, Form, Header, Icon, Menu, Segment, TextArea} from 'semantic-ui-react';\nimport {Duration, Scrap, Story} from '../../protos_v2';\nimport {\n  Link\n} from 'react-router-dom';\nimport { v4 as uuid } from 'uuid';\nimport {durationSecondsToString, durationStringToSeconds} from '../utils/durationUtils';\n\ninterface StoryDetailsProps {\n  story: Story|null;\n  scraps: Scrap[];\n  onStoryChange: (story: Story) => void;\n  onStoryDelete: () => void;\n  onScrapCreate: (scrap: Scrap) => void;\n  onScrapUpdate: (scrap: Scrap) => void;\n}\n\ninterface StoryDetailsState {\n  durationErrorString: string|null;\n  currentScrapFilter: string;\n  currentScrapId: string;\n}\n\nexport default class StoryDetails extends Component<StoryDetailsProps, StoryDetailsState> {\n  state: StoryDetailsState = {\n    durationErrorString: null,\n    currentScrapFilter: 'mine',\n    currentScrapId: '',\n  };\n\n  onNameChange(newName: string) {\n    const story = this.props.story as Story;\n\n    story.name = newName;\n    this.props.onStoryChange(story);\n  }\n\n  onDescriptionChange(newDescription: string) {\n    const story = this.props.story as Story;\n\n    story.description = newDescription;\n    this.props.onStoryChange(story);\n  }\n\n  getDurationString(): string {\n    let durationSec = (this.props.story?.duration?.seconds || 0) as number;\n\n    return durationSecondsToString(durationSec);\n  }\n\n  onDurationChange(newDuration: string) {\n    let durationSec;\n    try {\n      durationSec = durationStringToSeconds(newDuration);\n    } catch {\n      return this.setDurationErrorString(true);\n    }\n\n    const story = this.props.story as Story;\n    story.duration = Duration.create({\n      seconds: durationSec\n    });\n\n    this.props.onStoryChange(story);\n    this.setDurationErrorString(false);\n  }\n\n  setDurationErrorString(hasError: boolean) {\n    this.setState((state) => ({\n      ...state,\n      durationErrorString: hasError ? 'Please enter a duration of format HH:MM:SS' : null\n    }));\n  }\n\n  getFilteredScraps(filter: string) {\n    return this.props.scraps.filter((scrap) => {\n      if (filter === 'mine' && scrap.stories.indexOf(this.props.story?.id || '') < 0) {\n        return false;\n      }\n\n      if (filter === 'others' && scrap.stories.indexOf(this.props.story?.id || '') >= 0) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  createNewScrap(): Scrap {\n    return Scrap.create({\n      id: uuid(),\n      synopsis: 'New Scrap',\n      prose: 'New scrap for \"' + this.props.story?.name + '\" story\\nFill this out with notes or prose content',\n      stories: [this.props.story?.id as string]\n    });\n  }\n\n  renderScrapDetails(): ReactNode {\n    let currentScrap = this.props.scraps.find((scrap) => {\n      return scrap.id === this.state.currentScrapId;\n    });\n\n    if (!currentScrap) {\n      return (\n          <Header>Please select a scrap</Header>\n      )\n    }\n\n    let linkUnlinkButton;\n    if (currentScrap.stories.indexOf(this.props.story?.id || '') >= 0) {\n      // Need unlink button\n      linkUnlinkButton =\n          (<Button icon color='red'\n                   onClick={() => {\n                     const editingScrap = currentScrap as Scrap;\n                     editingScrap.stories = editingScrap.stories.filter((storyId) => {\n                       return storyId !== this.props.story?.id;\n                     });\n\n                     this.props.onScrapUpdate(editingScrap);\n                   }}>\n        <Icon name='unlink' />\n      </Button>);\n    } else {\n      linkUnlinkButton = (\n          <Button icon color='green'\n                  onClick={() => {\n                    const editingScrap = currentScrap as Scrap;\n                    editingScrap.stories.push(this.props.story?.id || '');\n                    this.props.onScrapUpdate(editingScrap);\n                  }}>\n            <Icon name='linkify' />\n          </Button>\n      );\n    }\n\n    return (\n        <div>\n          <div style={{display: 'flex'}}>\n            <Header>\n              {currentScrap.synopsis}\n            </Header>\n            <div style={{flex: 1, textAlign: 'right'}}>\n              {linkUnlinkButton}\n            </div>\n          </div>\n          <Container text>\n            {currentScrap.prose.split('\\n').map((line, idx) => {\n              return (<p key={'line-' +idx}>{line}</p>);\n            })}\n          </Container>\n          <div style={{marginTop: '32px'}}>\n            <Link to={`/scrap/${currentScrap.id}`}>\n              <Button primary>Start writing</Button>\n            </Link>\n          </div>\n        </div>\n    );\n\n  }\n\n  render() {\n    if (!this.props.story) {\n      return (\n          <div>Whoops, could not find story</div>\n      );\n    }\n\n    return (\n        <div style={{margin: '24px'}}>\n          <Segment.Group>\n            <Segment style={{display: 'flex'}}>\n              <Header>\n                Story Details\n                <Header.Subheader>\n                  Set the title, top-level description here\n                </Header.Subheader>\n              </Header>\n\n              <div style={{flex: 1, textAlign: 'right'}}>\n                <Button icon color='red'\n                        onClick={() => this.props.onStoryDelete()}\n                >\n                  <Icon name='delete' />\n                </Button>\n              </div>\n            </Segment>\n            <Segment>\n              <Form>\n                <Form.Group widths='equal'>\n                  <Form.Input\n                      label='Story Name'\n                      defaultValue={this.props.story.name}\n                      onChange={(e) => this.onNameChange(e.target.value)}\n                  />\n                  <Form.Input\n                      label='Intended Duration (HH:MM:SS)'\n                      defaultValue={this.getDurationString()}\n                      error={this.state.durationErrorString}\n                      onChange={(e) => this.onDurationChange(e.target.value)}\n                  />\n                </Form.Group>\n                <Form.Field>\n                  <label>Story Description</label>\n                  <TextArea\n                      defaultValue={this.props.story.description}\n                      onChange={(e) => this.onDescriptionChange(e.target.value)}\n                      style={{fontFamily: 'CourierPrime', height: '125px'}}\n                  />\n                </Form.Field>\n              </Form>\n            </Segment>\n          </Segment.Group>\n          <Segment.Group>\n            <Segment style={{display: 'flex'}}>\n              <Header>\n                Scraps\n                <Header.Subheader>\n                  These are the bits and pieces that make up the story\n                </Header.Subheader>\n              </Header>\n\n              <div style={{flex: 1, textAlign: 'right'}}>\n                <Button icon color='green'\n                        onClick={() => {\n                          this.props.onScrapCreate(this.createNewScrap())\n                        }}\n                >\n                  <Icon name='add' />\n                </Button>\n              </div>\n            </Segment>\n            <Segment style={{display: 'flex'}}>\n              <Menu pointing vertical>\n\n                  <Menu.Item>\n                    <Dropdown\n                        fluid\n                        selection\n                        onChange={(e, { value }) => {\n                          this.setState({\n                            ...this.state,\n                            currentScrapFilter: value as string,\n                          })\n                        }}\n                        defaultValue={this.state.currentScrapFilter}\n                        options={[\n                          {\n                            value: 'all',\n                            text: 'All stories',\n                            description: '' + (this.getFilteredScraps('all').length)\n                          },\n                          {\n                            value: 'mine',\n                            text: 'This story',\n                            description: '' + (this.getFilteredScraps('mine').length)\n                          },\n                          {\n                            value: 'others',\n                            text: 'Other stories',\n                            description: '' + (this.getFilteredScraps('others').length)\n                          },\n                        ]}>\n                    </Dropdown>\n                  </Menu.Item>\n                {this.getFilteredScraps(this.state.currentScrapFilter).map((scrap, idx) => {\n                  return (<Menu.Item\n                      key={'scrap-menu-' + idx}\n                      name={scrap.id}\n                      active={scrap.id === this.state.currentScrapId}\n                      onClick={() => this.setState({...this.state, currentScrapId: scrap.id})}\n                  >{scrap.synopsis}</Menu.Item>);\n                }).filter(Boolean)}\n              </Menu>\n              <div style={{flex: 1, marginLeft: '32px'}}>\n                {this.renderScrapDetails()}\n              </div>\n            </Segment>\n          </Segment.Group>\n        </div>\n    );\n  }\n}\n","import { RouteComponentProps } from 'react-router';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {removeStory, selectSpecificStory, updateStory} from '../../features/storyList/storyListSlice';\nimport StoryDetails from '../../features/storyDetails/StoryDetails';\nimport {Scrap, Story} from '../../protos_v2';\nimport {useHistory} from 'react-router-dom';\nimport {createScrap, selectScrapMap, updateScrap} from '../../features/scrapList/scrapListSlice';\n\ninterface MatchParams {\n  id: string\n}\n\ninterface StoryDetailsProps extends RouteComponentProps<MatchParams> {}\n\nexport default function StoryDetailsPage (props: StoryDetailsProps) {\n  const story = useAppSelector(selectSpecificStory(props.match.params?.id));\n  const topLevelScraps: Scrap[] = Object.values(useAppSelector(selectScrapMap));\n  const dispatch = useAppDispatch();\n  const history = useHistory();\n\n  return (\n    <StoryDetails\n      story={story}\n      scraps={topLevelScraps}\n      onStoryChange={(story) => dispatch(updateStory(story.toJSON()))}\n      onStoryDelete={() => {\n        dispatch(removeStory((story as Story).id));\n        history.push('/');\n      }}\n      onScrapCreate={(scrap) => {\n        dispatch(createScrap(scrap.toJSON()));\n        history.push('/scrap/' + scrap.id);\n      }}\n      onScrapUpdate={(scrap) => {\n        dispatch(updateScrap(scrap.toJSON()));\n      }}\n    />\n  )\n}\n","import {useAppSelector} from '../../app/hooks';\nimport {Button, Header, Segment} from 'semantic-ui-react';\nimport {selectStoryMap} from '../../features/storyList/storyListSlice';\n\nimport fileDownload from 'js-file-download';\nimport {WritingWorkspace} from '../../protos_v2';\nimport {addStoryToStorage, readAllStoriesFromStorage} from '../../features/storyList/storyListPersistence';\nimport {addScrapToStorage, readAllScrapsFromStorage} from '../../features/scrapList/scrapListPersistence';\n\nfunction clearWorkspace() {\n  localStorage.clear();\n  window.location.reload();\n}\n\nfunction downloadWorkspace() {\n  const filename = 'writing_workspace_' + Date.now() + '.write';\n\n  fileDownload(loadDataFromStorage(), filename);\n}\n\nasync function uploadWorkspace(files: FileList|null) {\n  if (!files) {\n    return;\n  }\n\n  const fileData = await files[0].arrayBuffer();\n  const parsedData = new Uint8Array(fileData);\n  loadDataToStorage(parsedData);\n\n  window.location.reload();\n}\n\nexport function loadDataFromStorage(): Uint8Array {\n  const workspace = WritingWorkspace.create({\n    stories: readAllStoriesFromStorage(),\n    scraps: readAllScrapsFromStorage(),\n  });\n\n  return WritingWorkspace.encode(workspace).finish();\n}\n\nexport function loadDataToStorage(data: Uint8Array): void {\n  const workspace = WritingWorkspace.decode(data);\n\n  localStorage.clear();\n\n  workspace.stories.forEach((story) => {\n    addStoryToStorage(story);\n  });\n\n  workspace.scraps.forEach((scrap) => {\n    addScrapToStorage(scrap);\n  });\n}\n\n\nexport default function DataManagementPage() {\n  const storyMap = useAppSelector(selectStoryMap);\n\n  return (\n      <div style={{margin: '24px'}}>\n        <Segment.Group >\n          <Segment style={{display: 'flex'}}>\n            <Header size='medium'>Data Management\n              <Header.Subheader>\n                Load, Save, or Clear your Workspace\n              </Header.Subheader>\n            </Header>\n          </Segment>\n          <Segment>\n            {Object.keys(storyMap).length} Stories\n          </Segment>\n          <Segment>\n            <Button color='green'\n                    onClick={() => {downloadWorkspace()}}>\n              Download Workspace\n            </Button>\n            <Button color='red'\n                    onClick={() => {clearWorkspace()}}>\n              Clear Workspace\n            </Button>\n          </Segment>\n          <Segment>\n            <Header size='small'>Upload Workspace</Header>\n            <input type=\"file\" accept=\".write\" onChange={(event) => uploadWorkspace(event.target.files)} />\n          </Segment>\n        </Segment.Group>\n      </div>\n  );\n}\n","import React from 'react';\n\nexport const LINES_PER_PAGE = 55;\nexport const ONE_LINE_DURATION_SEC = 1.0909; // (1 / LINES_PER_PAGE * 60);\nexport const PAGE_WIDTH_EM = '37em';\n\n/** Fields on the data for a block of parsed text */\nexport const scrapIdField = 'scrapId'; // Indicates which scrap defines this block of prose\nexport const ancestorField = 'ancestorField'; // Array of ancestor scrap IDs, excluding the current one\n\nexport const durationSecContribution = 'durationSecContribution'; // Seconds (perhaps partial) contributed to the script duration\n\nexport const isScrapEmbedding = 'isScrapEmbedding';\nexport const scrapLink = 'scrapLink';\nexport const isFountainHeader = 'isFountainHeader';\nexport const isFountainCentered = 'isFountainCentered';\nexport const isFountainTransition = 'isFountainTransition';\nexport const isBlank = 'isBlank';\nexport const isComment = 'isComment';\nexport const isCommentStart = 'isCommentStart';\nexport const isCommentEnd = 'isCommentEnd';\nexport const isFountainCharacter = 'isFountainCharacter';\nexport const character = 'character';\nexport const isFountainDialogue = 'isFountainDialogue';\nexport const isFountainParenthetical = 'isFountainParenthetical';\nexport const isFountainAction = 'isFountainAction';\n\nexport const FOUNTAIN_EDITOR_STYLE: React.CSSProperties = {\n  border: '1px solid',\n  padding: '6em',\n  margin: 'auto',\n  width: '49em', // PAGE_WIDTH_EM + padding\n  overflowY: 'scroll',\n  fontSize: '16px',\n  fontFamily: 'CourierPrime, Courier, monospace',\n  flex: '1'\n}\n\nexport function mergeDataObject(dataObject: { [index: string]: boolean|string|number}, newData: { [index: string]: boolean|string|number}): { [index: string]: boolean|string|number} {\n  return {\n    ...dataObject,\n    ...newData\n  };\n}\n","// Props are:\n// https://github.com/facebook/draft-js/blob/main/src/model/decorators/DraftDecorator.js#L54-L71\nimport {ContentBlock, ContentState} from 'draft-js';\nimport React, {Component} from 'react';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {createScrap, ScrapMap, selectScrapMap} from '../scrapList/scrapListSlice';\nimport {Scrap} from '../../protos_v2';\nimport {\n  useHistory, useLocation\n} from 'react-router-dom';\nimport {durationSecondsToString} from '../utils/durationUtils';\nimport {Button, Icon} from 'semantic-ui-react';\nimport {isComment, isScrapEmbedding, scrapLink} from './usefulConstants';\n\n\nexport function createChildScrap(parentScrapId: string, scrapMap: ScrapMap, scrapId: string): Scrap {\n  let parentStories: string[] = [];\n\n  if (scrapMap[parentScrapId]) {\n    parentStories = scrapMap[parentScrapId].stories;\n  }\n\n  return Scrap.create({\n    id: scrapId,\n    synopsis: 'New Scrap created in editor',\n    prose: 'this has placeholder content for now',\n    stories: parentStories,\n  });\n}\n\nexport function scrapEmbeddingStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isScrapEmbedding)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsScrapEmbed(blockText: string): boolean {\n  return blockText.startsWith('{{') && blockText.endsWith('}}');\n}\n\nexport function scrapEmbedData(blockText: string): { [index: string]: boolean|string} {\n  const scrapId = blockText.replace('{{', '').replace('}}', '').trim();\n\n  return {\n    scrapLink: scrapId,\n    isScrapEmbedding: true,\n  }\n}\n\n/**\n * Embedded component to show a scrap in a DraftJS editor.\n *\n * Assumes that `scrapLink` on the block's data contains the ID\n * */\nexport const ScrapEmbedComponent = (props: any) => {\n  const contentState = props.contentState as ContentState;\n  const data = contentState.getBlockMap().get(props.blockKey).getData();\n  const scrapId = data.get(scrapLink);\n  const inComment = data.get(isComment);\n\n  const scrapMap = useAppSelector(selectScrapMap);\n  const dispatch = useAppDispatch();\n  const history = useHistory();\n  const currentLocation = useLocation();\n\n  const parentScrapId = getScrapIdFromUrl(currentLocation.pathname);\n\n  const backgroundColor = inComment ? '#cfead9' : 'grey';\n  const textColor = inComment ? '#000' : '#fff';\n\n  return (\n      <div\n          style={{background: backgroundColor, fontWeight: 'bold', display: 'flex', padding: '8px'}}\n      >\n        <div style={{margin: 'auto 24px auto 0', color: textColor}} >{props.children}</div>\n        <div style={{flex: '1', cursor: 'pointer', padding: '8px', border: '1px solid', background: 'white', fontWeight: 'normal'}}>\n          <ScrapEmbedSummary\n            parentScrapId={parentScrapId}\n            scrapId={scrapId}\n            scrapMap={scrapMap}\n            onScrapCreate={(scrap) => dispatch(createScrap(scrap.toJSON()))}\n            onGotoScrap={() => { history.push(`/scrap/${scrapId}`) }}\n          />\n        </div>\n      </div>\n  );\n}\n\nfunction getScrapIdFromUrl(url: string): string {\n  return url.replace('/scrap/', '');\n}\n\n\ninterface ScrapEmbedSummaryProps {\n  parentScrapId: string;\n  scrapId: string;\n  scrapMap: ScrapMap;\n  onScrapCreate: (scrap: Scrap) => void;\n  onGotoScrap: () => void;\n}\n\nexport class ScrapEmbedSummary extends Component<ScrapEmbedSummaryProps> {\n  createScrap() {\n    const newScrap = createChildScrap(this.props.parentScrapId, this.props.scrapMap, this.props.scrapId);\n\n    this.props.onScrapCreate(newScrap);\n  }\n\n  render() {\n    const scrap = this.props.scrapMap[this.props.scrapId];\n\n    if (!scrap) {\n      return (<div>\n        Scrap does not exist yet.\n        <button onClick={() => {this.createScrap()}}>Create Now</button>\n      </div>)\n    }\n\n    if (this.props.scrapId === this.props.parentScrapId) {\n      return (<div style={{color: 'red'}}>\n        Scraps shouldn't include themselves\n      </div>);\n    }\n\n    return (<div style={{display: 'flex'}}>\n      <Button icon color='blue'\n              onClick={() => {this.props.onGotoScrap();}}\n      >\n        <Icon name='angle right' />\n      </Button>\n      <div style={{marginLeft: '24px', flex: '1'}}>\n        <div>{scrap.synopsis}</div>\n        <div>{durationSecondsToString(scrap.intendedDurationSec)}</div>\n      </div>\n    </div>);\n  }\n}\n","import {ContentState} from 'draft-js';\nimport {PAGE_WIDTH_EM, scrapIdField} from './usefulConstants';\nimport React, {Component, ReactElement} from 'react';\nimport {Link} from 'react-router-dom';\nimport {Button} from 'semantic-ui-react';\n\ninterface FountainReadOnlyState {\n  isHover: boolean;\n  scrapId: string;\n}\n\nconst parseScrapIdFromProps = (props: any) => {\n  const contentState = props.contentState as ContentState;\n  const data = contentState.getBlockMap().get(props.blockKey).getData();\n  return data.get(scrapIdField);\n}\n\nexport class BaseReadOnlyComponent extends Component<any, FountainReadOnlyState> {\n\n  constructor(props: any) {\n    super(props);\n\n    this.state = {\n      isHover: false,\n      scrapId: parseScrapIdFromProps(props)\n    }\n  }\n\n  buildScrapLinkButton(): ReactElement|null {\n    if (!this.state.isHover) {\n      return null;\n    }\n\n    const scrapLink = `/scrap/${this.state.scrapId}`;\n\n    return <Link to={scrapLink}>\n      <Button style={{cursor: 'pointer', position: 'absolute', top: '-12px', right: '-20px'}} circular color='blue' icon='edit outline' />\n    </Link>;\n  }\n\n  onMouseEnter(): void {\n    this.setState({\n      isHover: true\n    });\n  }\n\n  onMouseLeave(): void {\n    this.setState({\n      isHover: false\n    });\n  }\n\n  getParentStyle(): any {\n    const style: React.CSSProperties = {\n      position: 'relative',\n      paddingRight: '20px',\n      width: PAGE_WIDTH_EM,\n      margin: 0,\n    };\n\n    if (this.state.isHover) {\n      style.backgroundColor = '#c6e1f6';\n    }\n\n    return style;\n  }\n\n  renderSpecific() {\n    return <span>{this.props.children}</span>\n  }\n\n  render() {\n    return (\n        <div style={this.getParentStyle()}\n             onMouseEnter={() => {this.onMouseEnter();}}\n             onMouseLeave={() => {this.onMouseLeave();}}>\n          {this.renderSpecific()}\n          {this.buildScrapLinkButton()}\n        </div>\n    );\n  }\n}\n","import React from 'react';\nimport {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isFountainHeader, ONE_LINE_DURATION_SEC, PAGE_WIDTH_EM} from './usefulConstants';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\nexport function fountainHeaderStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainHeader)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsSceneHeader(blankBefore: boolean, blankAfter: boolean, blockText: string): boolean {\n  return blankBefore && blankAfter && ((/^(int|ext|est|i\\/e)[\\s.]/i).test(blockText) || (blockText.startsWith('.') && !blockText.startsWith('..')));\n}\n\nexport function sceneHeaderDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC; // Assume one line per scene heading\n}\n\nexport function sceneHeaderData(blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainHeader]: true,\n    [durationSecContribution]: sceneHeaderDurationSec(blockText),\n  }\n}\n\n/**\n * Component to show a Fountain scene header in DraftJS.\n *\n */\nexport const FountainHeaderComponent = (props: any) => {\n  return (\n      <div style={{fontWeight: 'bold', width: PAGE_WIDTH_EM}} >{props.children}</div>\n  );\n}\n\nexport class FountainHeaderReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainHeaderComponent(this.props);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isFountainTransition, ONE_LINE_DURATION_SEC, PAGE_WIDTH_EM} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\n\nexport function fountainTransitionStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainTransition)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsSceneTransition(blankBefore: boolean, blankAfter: boolean, blockText: string): boolean {\n  return blankBefore && blankAfter && ((blockText.startsWith('>') && !blockText.endsWith('<')) || (blockText.toUpperCase() === blockText && blockText.endsWith('TO:')));\n}\n\nexport function sceneTransitionDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC; // Assume one line per scene heading\n}\n\nexport function sceneTransitionData(blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainTransition]: true,\n    [durationSecContribution]: sceneTransitionDurationSec(blockText)\n  }\n}\n\n/**\n * Component to show a Fountain transition in DraftJS.\n *\n */\nexport const FountainTransitionComponent = (props: any) => {\n  return (\n      <div style={{fontWeight: 'bold', textAlign: 'right', width: PAGE_WIDTH_EM}} >{props.children}</div>\n  );\n}\n\n\nexport class FountainTransitionReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainTransitionComponent(this.props);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isFountainCentered, ONE_LINE_DURATION_SEC, PAGE_WIDTH_EM} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\n\nexport function fountainCenteredStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainCentered)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsCentered(blockText: string): boolean {\n  return blockText.startsWith('>') && blockText.endsWith('<');\n}\n\nexport function sceneCenteredDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC; // Assume one line per scene heading\n}\n\n\nexport function sceneCenteredData(blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainCentered]: true,\n    [durationSecContribution]: sceneCenteredDurationSec(blockText),\n  }\n}\n\n/**\n * Component to show a Fountain \"centered\" element in DraftJS.\n *\n */\nexport const FountainCenteredComponent = (props: any) => {\n  return (\n      <div style={{fontWeight: 'bold', textAlign: 'center', width: PAGE_WIDTH_EM}} >{props.children}</div>\n  );\n}\n\nexport class FountainCenteredReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainCenteredComponent(this.props);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {character, durationSecContribution, isFountainCharacter, ONE_LINE_DURATION_SEC} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\nexport function fountainCharacterStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainCharacter)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsCharacter(blankBefore: boolean, blankAfter: boolean, blockText: string): boolean {\n  return blankBefore && !blankAfter && (blockText.toUpperCase() === blockText || blockText.startsWith('@'));\n}\n\nexport function characterDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC * Math.ceil(blockText.length / 28); // About 28 characters per line\n}\n\nexport function characterData(blockText: string): { [index: string]: boolean|string|number} {\n  const parsedCharacter = blockText.trim();\n  // TODO: actually parse out things like  (v.o) and (cont'd)\n\n  return {\n    [isFountainCharacter]: true,\n    [character]: parsedCharacter,\n    [durationSecContribution]: characterDurationSec(blockText)\n  }\n}\n\n/**\n * Component to show a Fountain character in DraftJS.\n *\n */\nexport const FountainCharacterComponent = (props: any) => {\n  return (\n      <div style={{fontWeight: 'bold', marginLeft: '12em', width: '17em'}} >{props.children}</div>\n  );\n}\n\n\nexport class FountainCharacterReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainCharacterComponent(this.props);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {character, durationSecContribution, isFountainDialogue, ONE_LINE_DURATION_SEC} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\nexport function fountainDialogueStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainDialogue)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsDialogue(characterBefore: string, blockText: string): boolean {\n  return !!characterBefore && (!blockText.startsWith('(') || !blockText.endsWith(')'));\n}\n\nexport function dialogueDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC * Math.ceil(blockText.length / 36); // About 36 characters per line of dialogue fit\n}\n\nexport function dialogueData(characterBefore: string, blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainDialogue]: true,\n    [character]: characterBefore,\n    [durationSecContribution]: dialogueDurationSec(blockText)\n  }\n}\n\n/**\n * Component to show Fountain dialogue in DraftJS.\n *\n */\nexport const FountainDialogueComponent = (props: any) => {\n  return (\n      <div style={{marginLeft: '6em', width: '23.5em'}} >{props.children}</div>\n  );\n}\n\nexport class FountainDialogueReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainDialogueComponent(this.props);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {character, durationSecContribution, isFountainParenthetical, ONE_LINE_DURATION_SEC} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\nexport function fountainParentheticalStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainParenthetical)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsParenthetical(characterBefore: string, blockText: string): boolean {\n  return !!characterBefore && blockText.startsWith('(') && blockText.endsWith(')');\n}\n\nexport function parentheticalDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC * Math.ceil(blockText.length / 30); // About 30 characters per line\n}\n\nexport function parentheticalData(characterBefore: string, blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainParenthetical]: true,\n    [character]: characterBefore,\n    [durationSecContribution]: parentheticalDurationSec(blockText)\n  }\n}\n\n/**\n * Component to show Fountain parenthetical in DraftJS.\n *\n */\nexport const FountainParentheticalComponent = (props: any) => {\n  return (\n      <div style={{marginLeft: '8.5em', width: '19.5em'}} >{props.children}</div>\n  );\n}\n\nexport class FountainParentheticalReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainParentheticalComponent(this.props);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isFountainAction, ONE_LINE_DURATION_SEC, PAGE_WIDTH_EM} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\nexport function fountainActionStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainAction)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function actionDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC * Math.ceil(blockText.length / 56); // About 56 characters per line of action\n}\n\nexport function actionData(blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainAction]: true,\n    [durationSecContribution]: actionDurationSec(blockText),\n  }\n}\n\n/**\n * Component to show a Fountain action line in DraftJS.\n *\n */\nexport const FountainActionComponent = (props: any) => {\n  return (\n      <div style={{width: PAGE_WIDTH_EM}} >{props.children}</div>\n  );\n}\n\nexport class FountainActionReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainActionComponent(this.props);\n  }\n}\n","import {CharacterMetadata, ContentBlock, ContentState} from 'draft-js';\nimport Immutable from 'immutable';\nimport {ScrapMap} from '../scrapList/scrapListSlice';\nimport {Scrap} from '../../protos_v2';\nimport {character, durationSecContribution, isBlank, isComment, isCommentEnd, isCommentStart, mergeDataObject, ONE_LINE_DURATION_SEC, scrapLink} from './usefulConstants';\nimport {checkIsSceneHeader, sceneHeaderData, sceneHeaderDurationSec} from './FountainHeaderComponent';\nimport {checkIsScrapEmbed, scrapEmbedData} from './ScrapEmbedComponent';\nimport {checkIsSceneTransition, sceneTransitionData, sceneTransitionDurationSec} from './FountainTransitionComponent';\nimport {checkIsCentered, sceneCenteredData, sceneCenteredDurationSec} from './FountainCenteredComponent';\nimport {checkIsCommentEnd, checkIsCommentStart} from './CommentComponent';\nimport {characterData, characterDurationSec, checkIsCharacter} from './FountainCharacterComponent';\nimport {checkIsDialogue, dialogueData, dialogueDurationSec} from './FountainDialogueComponent';\nimport {checkIsParenthetical, parentheticalData, parentheticalDurationSec} from './FountainParentheticalComponent';\nimport {actionData, actionDurationSec} from './FountainActionComponent';\n\nexport interface ProcessProgress {\n  processStartEpoch: number;\n  currentDurationSec: number;\n  childScraps: Immutable.OrderedSet<string>;\n}\n\ninterface ProcessUpdate {\n  processProgress: ProcessProgress;\n  contentBlock: ContentBlock;\n}\n\n\nfunction applyStyles(character: CharacterMetadata, styles: Immutable.OrderedSet<string>): CharacterMetadata {\n  return (character as any).set('style', styles) as CharacterMetadata;\n}\n\nexport function isArrayEqualToImmutableSet(set: Immutable.OrderedSet<string>, array: string[]): boolean {\n  if (set.size !== array.length) {\n    return false;\n  }\n\n  for (let i = 0; i < array.length; i++) {\n    if (!set.includes(array[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Process each content block, resetting the blockData and conditionally setting a flag for if the block\n// is blank or not. This function needs to be able to operate on each contentBlock independent of all the rest\nexport function preProcessProseBlock(contentBlock: ContentBlock): ContentBlock {\n  if (!contentBlock) {\n    return contentBlock;\n  }\n\n  let blockData: { [index: string]: boolean|string} = {};\n  let blockText = contentBlock.getText().trim();\n\n  if (!blockText.length) {\n    blockData[isBlank] = true;\n  } else {\n    if (checkIsCommentStart(blockText)) {\n      blockData[isCommentStart] = true;\n    }\n    if (checkIsCommentEnd(blockText)) {\n      blockData[isCommentEnd] = true;\n    }\n  }\n\n  return contentBlock.set('data', Immutable.fromJS(blockData)) as ContentBlock;\n}\n\nexport function processProseBlock(contentBlock: ContentBlock, blockBefore: null|ContentBlock, blockAfter: null|ContentBlock, processProgress: ProcessProgress, scrapMap: ScrapMap): ProcessUpdate {\n  if (!contentBlock) {\n    return {\n      processProgress: processProgress,\n      contentBlock: contentBlock\n    };\n  }\n\n  let blockData: { [index: string]: boolean|string|number} = contentBlock.getData().toJS();\n  let applyCharacterStyles = true;\n\n  let blockText = contentBlock.getText().trim();\n\n  const blankBefore: boolean = !!blockBefore ? blockBefore.getData().get(isBlank) : true;\n  const blankAfter: boolean = !!blockAfter ? blockAfter.getData().get(isBlank) : true;\n  const characterBefore: string = !!blockBefore ? (blockBefore.getData().get(character) || '') : '';\n\n  if (blockData[isBlank]) {\n    if (!blankBefore && !blockData[isComment]) { // We only want to count 1 contiguous block of \"blank\", since we remove redundant whitespace\n      processProgress.currentDurationSec += ONE_LINE_DURATION_SEC; // Assume one line of whitespace\n      blockData = mergeDataObject(blockData, {\n        [durationSecContribution]: ONE_LINE_DURATION_SEC\n      });\n    }\n  } else {\n    if (!blockData[isComment]) {\n      if (checkIsSceneHeader(blankBefore, blankAfter, blockText)) {\n        /** Scene header */\n        blockData = mergeDataObject(blockData, sceneHeaderData(blockText));\n\n        processProgress.currentDurationSec += sceneHeaderDurationSec(blockText);\n      } else if (checkIsSceneTransition(blankBefore, blankAfter, blockText)) {\n        /** Scene transition */\n        blockData = mergeDataObject(blockData, sceneTransitionData(blockText));\n\n        processProgress.currentDurationSec += sceneTransitionDurationSec(blockText);\n      } else if (checkIsCentered(blockText)) {\n        /** Centered action */\n        blockData = mergeDataObject(blockData, sceneCenteredData(blockText));\n\n        processProgress.currentDurationSec += sceneCenteredDurationSec(blockText);\n      } else if (checkIsCharacter(blankBefore, blankAfter, blockText)) {\n        /** Character */\n        blockData = mergeDataObject(blockData, characterData(blockText));\n\n        processProgress.currentDurationSec += characterDurationSec(blockText);\n      } else if (checkIsDialogue(characterBefore, blockText)) {\n        /** Dialogue */\n        blockData = mergeDataObject(blockData, dialogueData(characterBefore, blockText));\n\n        processProgress.currentDurationSec += dialogueDurationSec(blockText);\n      }\n      else if (checkIsParenthetical(characterBefore, blockText)) {\n        /** Parenthetical */\n        blockData = mergeDataObject(blockData, parentheticalData(characterBefore, blockText));\n\n        processProgress.currentDurationSec += parentheticalDurationSec(blockText);\n      } else {\n        /** Action */\n        blockData = mergeDataObject(blockData, actionData(blockText));\n\n        processProgress.currentDurationSec += actionDurationSec(blockText);\n      }\n    }\n\n    if (checkIsScrapEmbed(blockText)) {\n      /** Scrap link embedded in prose */\n      blockData = mergeDataObject(blockData, scrapEmbedData(blockText));\n\n      const scrapId = blockData[scrapLink] as string;\n\n      if (!!scrapMap[scrapId]) {\n        processProgress.childScraps = processProgress.childScraps.add(scrapId);\n\n        const childScrap = scrapMap[scrapId] as Scrap;\n\n        if (!blockData[isComment]) {\n          processProgress.currentDurationSec += childScrap.intendedDurationSec;\n        }\n      }\n    }\n  }\n\n  const updatedBlock = contentBlock.set('data', Immutable.fromJS(blockData)) as ContentBlock;\n\n  applyCharacterStyles = false;\n\n  const updatedCharacterList = updatedBlock.getCharacterList().map((c, idx) => {\n    if (!c || !applyCharacterStyles) { return c; }\n\n\n    // @ts-ignore\n    if (idx < 5) {\n      return applyStyles(c, Immutable.OrderedSet.of('BOLD', 'GREEN'));\n    } else {\n      return applyStyles(c, Immutable.OrderedSet());\n    }\n  });\n\n  const finalBlockUpdate = updatedBlock.set('characterList', updatedCharacterList) as ContentBlock;\n\n  return {\n    contentBlock: finalBlockUpdate,\n    processProgress: processProgress,\n  }\n}\n\ninterface ParsedProseResult {\n  contentState: ContentState;\n  totalDurationSec: number;\n  childScraps: Immutable.OrderedSet<string>;\n  showTimeoutWarning: boolean;\n}\n\nexport function parseAllProse(contentState: ContentState, scrapMap: ScrapMap, warnParsingThreshold: number, errorParsingThreshold: number): ParsedProseResult {\n\n  let newParseErrorState = false;\n\n  let processProgress = {\n    processStartEpoch: Date.now(),\n    currentDurationSec: 0,\n    childScraps: Immutable.OrderedSet<string>()\n  } as ProcessProgress;\n\n  let currentBlockMap = contentState.getBlockMap();\n  // @ts-ignore\n  const blockKeys = [ ...currentBlockMap.keys()];\n\n  for (let i = 0; i < blockKeys.length; i++) {\n    const nextKey = blockKeys[i];\n    currentBlockMap = currentBlockMap.set(nextKey, preProcessProseBlock(currentBlockMap.get(nextKey)));\n\n    const timeSoFar = Date.now() - processProgress.processStartEpoch;\n    if (timeSoFar > warnParsingThreshold) {\n      newParseErrorState = true;\n    }\n    if (timeSoFar > errorParsingThreshold) {\n      break;\n    }\n  }\n\n  // Mark all comment blocks as such\n  let currentlyInComment = false;\n  for (let i = 0; i < blockKeys.length; i++) {\n    const nextKey = blockKeys[i];\n    const blockData = currentBlockMap.get(nextKey).getData().toJS();\n    if (blockData[isCommentStart]) {\n      currentlyInComment = true;\n    }\n\n    if (currentlyInComment) {\n      const currentBlock = currentBlockMap.get(nextKey);\n\n      blockData[isComment] = true;\n      const updatedData = Immutable.fromJS(blockData);\n\n      const updatedBlock = currentBlock.set('data', updatedData) as ContentBlock;\n      currentBlockMap = currentBlockMap.set(nextKey, updatedBlock);\n    }\n\n    if (blockData[isCommentEnd]) {\n      currentlyInComment = false;\n    }\n    const timeSoFar = Date.now() - processProgress.processStartEpoch;\n    if (timeSoFar > warnParsingThreshold) {\n      newParseErrorState = true;\n    }\n    if (timeSoFar > errorParsingThreshold) {\n      break;\n    }\n  }\n\n  for (let i = 0; i < blockKeys.length; i++) {\n    const blockBefore = i > 0 ? currentBlockMap.get(blockKeys[i - 1]) : null;\n    const nextKey = blockKeys[i];\n    const blockAfter = i + 1 < blockKeys.length ? currentBlockMap.get(blockKeys[i + 1]) : null;\n\n    const update = processProseBlock(currentBlockMap.get(nextKey), blockBefore, blockAfter, processProgress, scrapMap);\n\n    processProgress = update.processProgress;\n\n    currentBlockMap = currentBlockMap.set(nextKey, update.contentBlock);\n    const timeSoFar = Date.now() - processProgress.processStartEpoch;\n    if (timeSoFar > warnParsingThreshold) {\n      newParseErrorState = true;\n    }\n    if (timeSoFar > errorParsingThreshold) {\n      break;\n    }\n  }\n\n  const newContent = contentState.set('blockMap', currentBlockMap) as ContentState;\n\n  const durationMs = Date.now() - processProgress.processStartEpoch;\n  console.log('Update took: ' + durationMs);\n\n  return {\n    contentState: newContent,\n    totalDurationSec: processProgress.currentDurationSec,\n    childScraps: processProgress.childScraps,\n    showTimeoutWarning: newParseErrorState\n  };\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {isComment, isScrapEmbedding, PAGE_WIDTH_EM} from './usefulConstants';\nimport React from 'react';\n\n\nexport function commentStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isComment) && !contentBlock.getData().get(isScrapEmbedding)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsCommentStart(blockText: string): boolean {\n  return blockText.startsWith('/*');\n}\n\n\nexport function checkIsCommentEnd(blockText: string): boolean {\n  return blockText.endsWith('*/');\n}\n\n/**\n * Component to show a block component element in DraftJS.\n *\n */\nexport const CommentComponent = (props: any) => {\n  return (\n      <div style={{fontStyle: 'italic', background: '#cfead9', width: PAGE_WIDTH_EM}}>{props.children}</div>\n  );\n}\n","import {CompositeDecorator} from 'draft-js';\nimport {ScrapEmbedComponent, scrapEmbeddingStrategy} from './ScrapEmbedComponent';\nimport {FountainHeaderComponent, FountainHeaderReadOnlyComponent, fountainHeaderStrategy} from './FountainHeaderComponent';\nimport {FountainTransitionComponent, FountainTransitionReadOnlyComponent, fountainTransitionStrategy} from './FountainTransitionComponent';\nimport {FountainCenteredComponent, FountainCenteredReadOnlyComponent, fountainCenteredStrategy} from './FountainCenteredComponent';\nimport {FountainCharacterComponent, FountainCharacterReadOnlyComponent, fountainCharacterStrategy} from './FountainCharacterComponent';\nimport {FountainDialogueComponent, FountainDialogueReadOnlyComponent, fountainDialogueStrategy} from './FountainDialogueComponent';\nimport {FountainParentheticalComponent, FountainParentheticalReadOnlyComponent, fountainParentheticalStrategy} from './FountainParentheticalComponent';\nimport {CommentComponent, commentStrategy} from './CommentComponent';\nimport {FountainActionComponent, FountainActionReadOnlyComponent, fountainActionStrategy} from './FountainActionComponent';\n\n/** Decorator for the script editor */\nexport const editorDecorator = new CompositeDecorator([\n  {\n    strategy: scrapEmbeddingStrategy,\n    component: ScrapEmbedComponent,\n  },\n  {\n    strategy: fountainHeaderStrategy,\n    component: FountainHeaderComponent,\n  },\n  {\n    strategy: fountainTransitionStrategy,\n    component: FountainTransitionComponent,\n  },\n  {\n    strategy: fountainCenteredStrategy,\n    component: FountainCenteredComponent,\n  },\n  {\n    strategy: fountainCharacterStrategy,\n    component: FountainCharacterComponent,\n  },\n  {\n    strategy: fountainDialogueStrategy,\n    component: FountainDialogueComponent,\n  },\n  {\n    strategy: fountainParentheticalStrategy,\n    component: FountainParentheticalComponent,\n  },\n  {\n    strategy: commentStrategy,\n    component: CommentComponent,\n  },\n  {\n    strategy: fountainActionStrategy,\n    component: FountainActionComponent,\n  },\n]);\n\n/** Decorator for the script viewer (read-only) */\nexport const viewerDecorator = new CompositeDecorator([\n  {\n    strategy: fountainHeaderStrategy,\n    component: FountainHeaderReadOnlyComponent,\n  },\n  {\n    strategy: fountainTransitionStrategy,\n    component: FountainTransitionReadOnlyComponent,\n  },\n  {\n    strategy: fountainCenteredStrategy,\n    component: FountainCenteredReadOnlyComponent,\n  },\n  {\n    strategy: fountainCharacterStrategy,\n    component: FountainCharacterReadOnlyComponent,\n  },\n  {\n    strategy: fountainDialogueStrategy,\n    component: FountainDialogueReadOnlyComponent,\n  },\n  {\n    strategy: fountainParentheticalStrategy,\n    component: FountainParentheticalReadOnlyComponent,\n  },\n  {\n    strategy: fountainActionStrategy,\n    component: FountainActionReadOnlyComponent,\n  },\n]);\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport {ContentBlock, ContentState} from 'draft-js';\nimport {parseAllProse} from '../scrapDetails/parseProse';\nimport {ancestorField, isComment, isScrapEmbedding, scrapIdField, scrapLink} from '../scrapDetails/usefulConstants';\n\nexport function fetchParsedContentBlocksForScrap(scrapId: string, scrapAncestors: string[], scrapMap: ScrapMap): Array<ContentBlock> {\n  let prose = scrapMap[scrapId]?.prose || '';\n\n  let newAncestors = [...scrapAncestors, scrapId];\n\n  const initialContentState = ContentState.createFromText(prose);\n\n  const parseResult = parseAllProse(initialContentState, scrapMap, 500, 5000);\n\n  const allNewContentBlocks: Array<ContentBlock> = [];\n\n  parseResult.contentState.getBlocksAsArray().forEach((block) => {\n    const blockData = block.getData();\n\n    if (blockData.get(isComment)) {\n      // Skip\n      return;\n    }\n\n    if (!blockData.get(isScrapEmbedding)) {\n      // Simple addition, just append the ID of the scrap, and the ancestors at this point\n      let updatedBlock = block.set('data', blockData.set(scrapIdField, scrapId).set(ancestorField, scrapAncestors));\n\n      allNewContentBlocks.push(updatedBlock as ContentBlock);\n      return;\n    }\n\n    const embeddedScrapId = blockData.get(scrapLink);\n\n    if (!scrapMap[embeddedScrapId]) {\n      // Scrap doesn't exist, skip\n      return;\n    }\n\n    if (newAncestors.includes(embeddedScrapId)) {\n      throw Error(`Replacing scrap ${embeddedScrapId} would cause infinite recursion`);\n    }\n\n    const subBlocks = fetchParsedContentBlocksForScrap(embeddedScrapId, newAncestors, scrapMap);\n\n    allNewContentBlocks.push(...subBlocks);\n  });\n\n  return allNewContentBlocks;\n}\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport {Editor, ContentState, EditorState} from 'draft-js';\nimport {Component, ReactElement} from 'react';\nimport {viewerDecorator} from './foutainDecorators';\nimport {FOUNTAIN_EDITOR_STYLE} from './usefulConstants';\nimport {fetchParsedContentBlocksForScrap} from '../utils/fetchParsedContentBlocksForScrap';\n\ninterface ReadOnlyViewerProps {\n  scrapId: string;\n  scrapMap: ScrapMap;\n}\n\ninterface ReadOnlyViewerState {\n  scrapId: string;\n  editorState: EditorState;\n}\n\nexport class ReadOnlyViewer extends Component<ReadOnlyViewerProps, ReadOnlyViewerState> {\n\n  constructor(props: ReadOnlyViewerProps) {\n    super(props);\n\n    this.state = this.initializeState(props);\n  }\n\n  initializeState(props: ReadOnlyViewerProps): ReadOnlyViewerState {\n    return {\n      scrapId: props.scrapId,\n      editorState: this.buildInitialEditorState(props)\n    };\n  }\n\n  componentDidUpdate(prevProps: Readonly<ReadOnlyViewerProps>, prevState: Readonly<ReadOnlyViewerState>, snapshot?: any) {\n    if (this.state.scrapId === this.props.scrapId) {\n      return;\n    }\n\n    // Need to update\n    this.setState(this.initializeState(this.props));\n  }\n\n  buildInitialEditorState(props: ReadOnlyViewerProps): EditorState {\n    let thisScrap = props.scrapMap[props.scrapId];\n\n    if (!thisScrap) {\n      return EditorState.createEmpty();\n    }\n\n    const parsedBlocks = fetchParsedContentBlocksForScrap(props.scrapId, [], this.props.scrapMap);\n\n    return EditorState.createWithContent(\n        ContentState.createFromBlockArray(\n            parsedBlocks),\n        viewerDecorator);\n  }\n\n  normalizeProse(prose: string): string {\n    return prose; // TODO: actually normalize things, remove comments, normalize whitespace\n  }\n\n  render(): ReactElement {\n    return <div\n        style={FOUNTAIN_EDITOR_STYLE}>\n      <Editor\n        readOnly\n        onChange={() => {}}\n        editorState={this.state.editorState}\n      />\n    </div>\n  }\n\n}\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport {TimelineBlock, TimelineRow} from './Timeline';\nimport {fetchParsedContentBlocksForScrap} from '../utils/fetchParsedContentBlocksForScrap';\nimport {ancestorField, durationSecContribution, scrapIdField} from '../scrapDetails/usefulConstants';\n\ninterface ParsedTimeline {\n  totalDurationSec: number;\n  rows: TimelineRow[];\n}\n\nexport function parseTimeline(scrapId: string, scrapMap: ScrapMap): ParsedTimeline {\n  let rows: TimelineRow[] = [];\n\n  // TODO: bring this in from a common place, don't double-parse\n  const parsedBlocks = fetchParsedContentBlocksForScrap(scrapId, [], scrapMap);\n\n  let totalDurationSec = 0;\n  for (let i = 0; i < parsedBlocks.length; i++) {\n\n    const durationContribution = parsedBlocks[i].getData().get(durationSecContribution) || 0;\n    if (!durationContribution) {\n      continue;\n    }\n\n    const ancestors = [\n        ...(parsedBlocks[i].getData().get(ancestorField) || []),\n        parsedBlocks[i].getData().get(scrapIdField) || ''\n    ];\n\n    for (let j = 0; j < ancestors.length; j++) {\n      if (rows.length <= j) {\n        // Need to add a new row\n        rows.push(new TimelineRow());\n      }\n\n      // Check to see what the last block's ID is\n      const lastBlockId = rows[j].lastBlockId();\n\n      if (ancestors[j] === lastBlockId) {\n        // Extend existing block\n        rows[j].blocks[rows[j].blocks.length - 1].durationSec += durationContribution;\n      } else {\n        rows[j].blocks.push(new TimelineBlock(\n            getScrapSynopsis(ancestors[j], scrapMap),\n            ancestors[j],\n            totalDurationSec,\n            durationContribution\n        ));\n      }\n    }\n\n    totalDurationSec += durationContribution;\n  }\n\n  return {\n    totalDurationSec: totalDurationSec,\n    rows: rows,\n  }\n}\n\nfunction getScrapSynopsis(scrapId: string, scrapMap: ScrapMap): string {\n  return scrapMap[scrapId]?.synopsis || '';\n}\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport React, {Component} from 'react';\nimport {Button, Icon, Popup} from 'semantic-ui-react';\nimport {durationSecondsToString} from '../utils/durationUtils';\nimport {parseTimeline} from './timelineParsing';\nimport {\n  Link\n} from 'react-router-dom';\n\nfunction formatPercentString(percent: number): string {\n  return `${percent}%`;\n}\n\nexport class TimelineBlock {\n  headerText: string;\n  id: string;\n  startSec: number;\n  durationSec: number;\n\n  constructor(headerText: string, id: string, startSec: number, durationSec: number) {\n    this.headerText = headerText;\n    this.id = id;\n    this.startSec = startSec;\n    this.durationSec = durationSec;\n  }\n\n  render(totalDurationSec: number) {\n    return <Popup\n        key={'key-' + this.id}\n        content={durationSecondsToString(this.durationSec)}\n        header={this.headerText}\n        mouseEnterDelay={50}\n        mouseLeaveDelay={50}\n        trigger={\n          <Link\n              to={'/scrap/' + this.id}\n              style={{\n                cursor: 'pointer',\n                display: 'inline-block',\n                height: '100%',\n                boxShadow: 'inset 0px 0px 0px 1px #555',\n                position: 'absolute',\n                width: formatPercentString(100 * this.durationSec / totalDurationSec),\n                left: formatPercentString(100 * this.startSec / totalDurationSec),\n                background: 'grey',\n                zIndex: 2,\n              }}\n          >\n          <div\n        >\n          &nbsp;\n          </div></Link>}\n    />\n  }\n}\n\nexport class TimelineRow {\n  blocks: TimelineBlock[] = [];\n\n  lastBlockId(): string {\n    if (!this.blocks.length) {\n      return '';\n    }\n\n    return this.blocks[this.blocks.length - 1].id;\n  }\n\n  render(totalDurationSec: number, zoomLevel: number) {\n    return <div style={{\n      position: 'relative',\n      width: formatPercentString(zoomLevel),\n      height: '40px',\n      borderBottom: '1px solid'\n    }}>\n      {this.blocks.map((block) => block.render(totalDurationSec))}\n    </div>\n  }\n}\n\nexport class Timeline {\n  isValid: boolean = false;\n  durationSec: number = 0;\n  rows: TimelineRow[] = [];\n\n  constructor(scrapId: string, scrapMap: ScrapMap) {\n    if (!scrapMap[scrapId]) {\n      return;\n    }\n\n    const parseResult = parseTimeline(scrapId, scrapMap);\n\n    console.log(parseResult);\n\n    this.durationSec = parseResult.totalDurationSec;\n    if (!this.durationSec) {\n      return;\n    }\n\n    this.isValid = true;\n\n    this.rows = parseResult.rows;\n  }\n\n  getSecondMarkers(zoomLevel: number): number[] {\n    const numLevels = Math.round(4 * (zoomLevel / 100)) + 1;\n    const stepLevel = (this.durationSec / (numLevels - 1));\n\n    let startingPoint = 0;\n    let steps = []\n    for (let i = 0; i < numLevels; i++) {\n      const nextContribution = Math.round(startingPoint);\n      steps.push(nextContribution);\n      startingPoint += stepLevel;\n    }\n\n    return steps;\n  }\n\n  render(zoomLevel: number) {\n    let secondMarkers = this.getSecondMarkers(zoomLevel);\n    let markerTopPadding = 41 * this.rows.length;\n\n    return <div style={{width: '100%', overflowX: 'scroll', background: 'lightgrey'}}>\n      {this.rows.map((row) => row.render(this.durationSec, zoomLevel))}\n      <div style={{height: '24px', position: 'relative', width: formatPercentString(zoomLevel), background: 'white'}}>\n        {secondMarkers.map((value, idx) => {\n\n          const markerStyle: React.CSSProperties = {\n            display: 'inline-block',\n            position: 'absolute',\n            fontSize: '16px',\n            fontFamily: 'CourierPrime, Courier, monospace',\n            paddingTop: `${markerTopPadding}px`,\n            top: `-${markerTopPadding}px`\n          };\n\n          if (idx + 1 === secondMarkers.length) {\n            markerStyle.paddingRight = '8px';\n            markerStyle.textAlign = 'right';\n            markerStyle.borderRight = '2px solid';\n            markerStyle.right = formatPercentString(100 - (100 * value / this.durationSec));\n          } else {\n            markerStyle.paddingLeft = '8px';\n            markerStyle.textAlign = 'left';\n            markerStyle.borderLeft = '2px solid';\n            markerStyle.left = formatPercentString(100 * value / this.durationSec);\n          }\n\n          return <div\n              style={markerStyle}>{durationSecondsToString(value)}</div>\n        })}\n      </div>\n    </div>\n  }\n}\n\ninterface TimelineProps {\n  scrapId: string;\n  scrapMap: ScrapMap;\n}\n\ninterface TimelineState {\n  scrapId: string;\n  timeline: Timeline;\n  zoomLevel: number;\n  minimized: boolean;\n}\n\nexport class TimelineViewer extends Component<TimelineProps, TimelineState> {\n\n  constructor(props: TimelineProps) {\n    super(props);\n\n    this.state = this.initializeState(props);\n  }\n\n  initializeState(props: TimelineProps): TimelineState {\n    return {\n      scrapId: props.scrapId,\n      timeline: new Timeline(props.scrapId, props.scrapMap),\n      zoomLevel: 100,\n      minimized: false,\n    }\n  }\n\n  zoomIn() {\n    this.setState({\n      zoomLevel: this.state.zoomLevel * 2\n    });\n  }\n\n  zoomOut() {\n    this.setState({\n      zoomLevel: Math.max(100, this.state.zoomLevel / 2)\n    });\n  }\n\n  flipMinimization() {\n    this.setState({\n      minimized: !this.state.minimized\n    });\n  }\n\n  render() {\n    if (!this.state.timeline.isValid) {\n      return <div>... loading timeline... </div>\n    }\n\n    const zoomOptions = this.state.minimized ? null : (<div style={{display: 'inline-block'}}>\n      <Button onClick={() => this.zoomOut()} disabled={this.state.zoomLevel === 100} icon>\n        <Icon name='zoom-out' />\n      </Button>\n      <Button onClick={() => this.zoomIn()} icon>\n        <Icon name='zoom-in' />\n      </Button>\n    </div>);\n\n    return (<div>\n      <div style={{marginBottom: '12px', display: 'flex'}}>\n        {zoomOptions}\n        <span style={{flex: '1'}}>&nbsp;</span>\n        <Button onClick={() => this.flipMinimization()} icon>\n          <Icon name={this.state.minimized ? 'window maximize outline' : 'window minimize outline'}/>\n        </Button>\n      </div>\n      {this.state.minimized ? null : this.state.timeline.render(this.state.zoomLevel)}\n    </div>)\n  }\n}\n","import {StoryMap} from '../storyList/storyListSlice';\nimport {ScrapMap} from '../scrapList/scrapListSlice';\nimport React, {Component, ReactElement} from 'react';\nimport * as clipboard from \"clipboard-polyfill/text\";\nimport {Editor, EditorState, ContentState, Modifier} from 'draft-js';\n// @ts-ignore\nimport getFragmentFromSelection from 'draft-js/lib/getFragmentFromSelection';\nimport 'draft-js/dist/Draft.css';\nimport {Scrap, Story} from '../../protos_v2';\nimport {Breadcrumb, BreadcrumbDivider, BreadcrumbSection, Button, Form, Segment, Tab} from 'semantic-ui-react';\nimport {\n  Link\n} from 'react-router-dom';\nimport { v4 as uuid } from 'uuid';\nimport debounce from 'debounce';\nimport {createChildScrap} from './ScrapEmbedComponent';\nimport {durationSecondsToString, durationStringToSeconds} from '../utils/durationUtils';\nimport {isArrayEqualToImmutableSet, parseAllProse} from './parseProse';\nimport {editorDecorator} from './foutainDecorators';\nimport {ReadOnlyViewer} from './ReadOnlyViewer';\nimport {FOUNTAIN_EDITOR_STYLE} from './usefulConstants';\nimport {TimelineViewer} from '../timeline/Timeline';\n\ninterface ScrapDetailsProps {\n  scrapId: string;\n  storyMap: StoryMap;\n  scrapMap: ScrapMap;\n  onScrapCreate: (scrap: Scrap) => void;\n  onScrapUpdate: (scrap: Scrap) => void;\n}\n\ninterface ScrapDetailsState {\n  editorState: EditorState;\n  lastEmittedStr: string;\n  scrapId: string;\n  durationErrorString: string|null;\n  parseErrorState: boolean;\n  actualDurationSec: number;\n  parentScrapIds: string[];\n  durationInputKey: string;\n}\n\n\n\nconst styleMap = {\n  'GREEN': {\n    color: 'green'\n  },\n}\n\nexport default class ScrapDetails extends Component<ScrapDetailsProps, ScrapDetailsState> {\n  domEditor: any;\n\n  constructor(props: ScrapDetailsProps) {\n    super(props);\n\n    this.state = this.initializeState(props);\n    this.remapEditorContent();\n  }\n\n  initializeState(props: ScrapDetailsProps): ScrapDetailsState {\n    return {\n      editorState: this.buildInitialEditorState(props),\n      lastEmittedStr: '',\n      scrapId: props.scrapId,\n      durationErrorString: null,\n      actualDurationSec: 0,\n      parentScrapIds: this.buildParentScrapIds(props),\n      parseErrorState: false,\n      durationInputKey: 'duration-key-' + Date.now(),\n    };\n  }\n\n  buildInitialEditorState(props: ScrapDetailsProps): EditorState {\n    let thisScrap = props.scrapMap[props.scrapId];\n\n    if (!thisScrap) {\n      return EditorState.createEmpty();\n    }\n\n    return EditorState.createWithContent(ContentState.createFromText(thisScrap.prose), editorDecorator)\n  }\n\n  componentDidUpdate(prevProps: Readonly<ScrapDetailsProps>, prevState: Readonly<ScrapDetailsState>, snapshot?: any) {\n    if (this.state.scrapId === this.props.scrapId) {\n      return;\n    }\n\n    // Need to update\n    this.setState(this.initializeState(this.props));\n    this.remapEditorContent();\n  }\n\n  buildParentScrapIds(props: ScrapDetailsProps): string[] {\n    const thisScrap = props.scrapMap[this.props.scrapId];\n    const parentScraps = [];\n    for (let key in props.scrapMap) {\n      const scrap = props.scrapMap[key] as Scrap;\n      if (scrap.childScraps.includes(thisScrap.id)) {\n        parentScraps.push(scrap.id);\n      }\n    }\n\n    return parentScraps;\n  }\n\n  getBreadcrumbs(thisScrap: Scrap): ReactElement {\n    let parentStories = thisScrap.stories.map((storyId) => {\n      return this.props.storyMap[storyId];\n    }).filter(Boolean);\n\n    const parentStoryLinks = parentStories.map<React.ReactNode>(((parentStory: Story) => {\n      return (<BreadcrumbSection link>\n        <Link to={'/story/' + parentStory.id}>{parentStory.name}</Link>\n      </BreadcrumbSection>)\n    }));\n\n    let storyContribution;\n    if (parentStories.length) {\n      storyContribution = (<div>Stories:\n        <Breadcrumb>\n          {\n            parentStoryLinks.reduce((prev, curr) => [prev, <BreadcrumbDivider icon='right chevron' />, curr])\n          }\n        </Breadcrumb>\n      </div>);\n    } else {\n      storyContribution = (<div>No parent stories</div>);\n    }\n\n    const parentScraps = this.state.parentScrapIds.map((scrapId) => {\n        return this.props.scrapMap[scrapId];\n      }).filter(Boolean);\n\n    const parentScrapLinks = parentScraps.map<React.ReactNode>(((parentScrap: Scrap) => {\n      return (<BreadcrumbSection link>\n        <Link to={'/scrap/' + parentScrap.id}>{parentScrap.synopsis}</Link>\n      </BreadcrumbSection>)\n    }));\n\n    let scrapContribution;\n    if (parentScraps.length) {\n      scrapContribution = (<div>Scraps:\n        <Breadcrumb>\n          {\n            parentScrapLinks.reduce((prev, curr) => [prev, <BreadcrumbDivider icon='right chevron' />, curr])\n          }\n        </Breadcrumb>\n      </div>);\n    } else {\n      scrapContribution = (<div>No parent scraps</div>);\n    }\n\n    return (<div>\n      {storyContribution}\n      {scrapContribution}\n    </div>);\n  }\n\n  onSynopsisChange(newSynopsis: string) {\n    const scrap = this.props.scrapMap[this.props.scrapId] as Scrap;\n\n    scrap.synopsis = newSynopsis;\n    this.props.onScrapUpdate(scrap);\n  }\n\n  getPrimaryForm(thisScrap: Scrap): ReactElement {\n    return <Segment>\n      <Form>\n        <div style={{display: 'flex'}}>\n          <div style={{flex: 1, margin: '16px 0'}}>\n            <Form.Input\n                label='Synopsis'\n                defaultValue={thisScrap.synopsis}\n                onChange={(e) => this.onSynopsisChange(e.target.value)}\n            />\n          </div>\n          <div style={{flex: 1, margin: '16px'}}>\n            <Form.Input\n                key={this.state.durationInputKey}\n                style={{flex: 1}}\n                label='Intended Duration (HH:MM:SS)'\n                defaultValue={durationSecondsToString(thisScrap.intendedDurationSec)}\n                error={this.state.durationErrorString}\n                onChange={(e) => this.onDurationChange(e.target.value)}\n            />\n          </div>\n          <div style={{flex: 1, margin: 'auto'}}>\n            <Form.Field>\n              <label>\n                Current Actual Duration: {durationSecondsToString(this.state.actualDurationSec)}\n              </label>\n              <Button\n                  onClick={() => this.updateExpectedDurationSec()}\n                  disabled={this.state.actualDurationSec === thisScrap.intendedDurationSec}\n              >\n                Update expected duration\n              </Button>\n            </Form.Field>\n          </div>\n\n        </div>\n      </Form>\n    </Segment>\n  }\n\n  onDurationChange(newDuration: string) {\n    let durationSec;\n    try {\n      durationSec = durationStringToSeconds(newDuration);\n    } catch {\n      return this.setDurationErrorString(true);\n    }\n\n    const scrap = this.props.scrapMap[this.props.scrapId] as Scrap;\n\n    scrap.intendedDurationSec = durationSec;\n    this.props.onScrapUpdate(scrap);\n    this.setDurationErrorString(false);\n  }\n\n  setDurationErrorString(hasError: boolean) {\n    this.setState({\n      durationErrorString: hasError ? 'Please enter a duration of format HH:MM:SS' : null\n    });\n  }\n\n  updateExpectedDurationSec(): void {\n    const scrap = this.props.scrapMap[this.props.scrapId] as Scrap;\n\n    scrap.intendedDurationSec = this.state.actualDurationSec;\n    this.props.onScrapUpdate(scrap);\n    this.setState({\n      durationInputKey: 'duration-key-' + Date.now()\n    });\n    this.setDurationErrorString(false);\n  }\n\n  getProseEditorToolbar(): ReactElement {\n    const parseWarning = this.state.parseErrorState ?\n        (<div style={{color: 'red'}}>Parsing took too long, please break into smaller chunks</div>) : null;\n\n    return <div>\n      <div>\n        <button onClick={() => this.addChildScrap()}>Add child scrap</button>\n      </div>\n      {parseWarning}\n    </div>;\n  }\n\n  setDomEditorRef(ref: any) {\n    this.domEditor = ref;\n  }\n\n  focus(): void {\n    this.domEditor.focus();\n  }\n\n  onProseChange(newState: EditorState): void {\n    this.setState({editorState: newState});\n\n    this.remapEditorContent(); // Restyle, but only after things settle down a bit\n  }\n\n  getSelectedText(): string {\n    const editorState = this.state.editorState;\n    const selected = getFragmentFromSelection(editorState);\n    return (selected ? selected.map((x: { getText: () => any; }) => x.getText()).join('\\n') : '') as string;\n  }\n\n  onCut(editor: Editor, e: any, removeWhenDone: boolean): void {\n    e.preventDefault();\n\n    const editorState = this.state.editorState;\n    const selectedText = this.getSelectedText();\n    clipboard.writeText(selectedText).then(() => {\n      if (!removeWhenDone) {\n        return;\n      }\n\n      const newContentState = Modifier.replaceText(\n          editorState.getCurrentContent(),\n          editorState.getSelection(),\n          ''\n      );\n\n      this.setState({editorState: EditorState.set(editorState, {currentContent: newContentState})});\n    });\n  }\n\n  persistProse(newProseStr: string): void {\n    const scrap = this.props.scrapMap[this.props.scrapId] as Scrap;\n\n    scrap.prose = newProseStr;\n    this.props.onScrapUpdate(scrap);\n  }\n\n  remapEditorContent = debounce(() => {\n    const newStrToEmit = this.state.editorState.getCurrentContent().getPlainText();\n\n    if (newStrToEmit === this.state.lastEmittedStr) {\n      return; // No need to update\n    }\n\n    this.persistProse(newStrToEmit);\n\n    const parseResult = parseAllProse(this.state.editorState.getCurrentContent(), this.props.scrapMap,50, 500);\n\n    // Check to see if we need to update the scrap b/c the references to child scraps changed\n    const thisScrap = this.props.scrapMap[this.props.scrapId];\n\n    if (!isArrayEqualToImmutableSet(parseResult.childScraps, thisScrap.childScraps)) {\n      const newScrap = Scrap.create({\n        ...thisScrap,\n        childScraps: [ ...(parseResult.childScraps.toArray()) ]\n      });\n\n      this.props.onScrapUpdate(newScrap);\n    }\n\n    this.setState({\n      editorState: EditorState.set(this.state.editorState, {currentContent: parseResult.contentState}),\n      lastEmittedStr: newStrToEmit,\n      actualDurationSec: Math.round(parseResult.totalDurationSec),\n      parseErrorState: parseResult.showTimeoutWarning,\n    });\n  }, 200);\n\n  addChildScrap(): void {\n    const editorState = this.state.editorState;\n    const currentSelection = editorState.getSelection();\n\n    const currentlySelectedText = this.getSelectedText();\n\n    const newScrapId = uuid();\n\n    const newScrap = createChildScrap(this.props.scrapId, this.props.scrapMap, newScrapId);\n    if (!!currentlySelectedText.trim().length) {\n      newScrap.prose = currentlySelectedText;\n    }\n\n    this.props.onScrapCreate(newScrap);\n\n    const thingToInsert = '\\n{{' + newScrapId + '}}\\n';\n\n    const newContentState = currentSelection.isCollapsed() ?\n        Modifier.insertText(\n            editorState.getCurrentContent(),\n            currentSelection,\n            thingToInsert\n        ) : Modifier.replaceText(\n        editorState.getCurrentContent(),\n            currentSelection,\n        thingToInsert\n    );\n\n    this.setState({\n      editorState: EditorState.set(editorState, {currentContent: newContentState})\n    });\n\n    this.remapEditorContent();\n  }\n\n\n\n  render() {\n    let thisScrap = this.props.scrapMap[this.props.scrapId];\n\n    if (!thisScrap) {\n      return (\n          <div>Whoops, could not find scrap</div>\n      );\n    }\n\n    const tabStyle = {\n      height: 'calc(100% - 43px)', // Offset to account for tab height\n      display: 'flex',\n      flexDirection: 'column'\n    }\n\n    const panes = [\n      { menuItem: 'Write', render: () => <Tab.Pane style={tabStyle}>\n          {this.getBreadcrumbs(thisScrap)}\n          {this.getPrimaryForm(thisScrap)}\n          {this.getProseEditorToolbar()}\n          <div\n              onClick={() => {this.focus()}}\n              style={FOUNTAIN_EDITOR_STYLE}>\n            <Editor\n                customStyleMap={styleMap}\n                stripPastedStyles={true}\n                onCut={(editor, e) => {this.onCut(editor, e, true);}}\n                onCopy={(editor, e) => {this.onCut(editor, e, false);}}\n                editorState={this.state.editorState}\n                ref={(ref) => {this.setDomEditorRef(ref);}}\n                onChange={(newState) => {this.onProseChange(newState); }}/>\n          </div>\n        </Tab.Pane>},\n      { menuItem: 'Read', render: () => <Tab.Pane style={tabStyle}>\n          <TimelineViewer\n              scrapId={this.state.scrapId}\n              scrapMap={this.props.scrapMap}/>\n          <ReadOnlyViewer\n            scrapId={this.state.scrapId}\n            scrapMap={this.props.scrapMap}/>\n      </Tab.Pane>},\n    ]\n\n    return (\n        <Tab style={{height: '100%'}} key={'scrap-details-' + this.props.scrapId} panes={panes} />\n    );\n  }\n\n}\n","import { RouteComponentProps } from 'react-router';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {selectStoryMap} from '../../features/storyList/storyListSlice';\nimport {createScrap, selectScrapMap, updateScrap} from '../../features/scrapList/scrapListSlice';\nimport ScrapDetails from '../../features/scrapDetails/ScrapDetails';\n\ninterface MatchParams {\n  id: string\n}\n\ninterface ScrapDetailsProps extends RouteComponentProps<MatchParams> {}\n\nexport default function ScrapDetailsPage (props: ScrapDetailsProps) {\n  const storyMap = useAppSelector(selectStoryMap);\n  const scrapMap = useAppSelector(selectScrapMap);\n  const dispatch = useAppDispatch();\n\n  return (\n      <ScrapDetails\n          scrapId={props.match.params.id}\n          scrapMap={scrapMap}\n          storyMap={storyMap}\n          onScrapCreate={(scrap) => dispatch(createScrap(scrap.toJSON()))}\n          onScrapUpdate={(scrap) => dispatch(updateScrap(scrap.toJSON()))}\n      />\n  )\n}\n","import React, {Component, ReactElement} from 'react';\n\ntype Candidate = {\n  label: string;\n  description: string;\n  currentScore: number;\n  wins: number;\n  losses: number;\n}\n\ntype MyState = {\n  showListInput: boolean;\n  showCurrentScores: boolean;\n  nextCandidateLabel: string;\n  nextCandidateDesc: string;\n\n  candidates: Candidate[];\n  winMatrix: number[][];\n  candidateIndexA: number;\n  candidateIndexB: number;\n}\n\nexport default class DecisionPage extends Component<any, MyState> {\n\n\n  state: MyState = {\n    showListInput: true,\n    showCurrentScores: false,\n    nextCandidateLabel: '',\n    nextCandidateDesc: '',\n    candidates: [],\n    winMatrix: [],\n    candidateIndexA: -1,\n    candidateIndexB: -1,\n  };\n\n  addCandidate(): void {\n    let newCandidates = [...this.state.candidates, {\n      label: this.state.nextCandidateLabel,\n      description: this.state.nextCandidateDesc,\n      currentScore: 1,\n      wins: 0,\n      losses: 0,\n    } as Candidate];\n\n    let defaultValue = 1 / (10 * newCandidates.length);\n    let winMatrix = [...Array(newCandidates.length)].map(e => Array(newCandidates.length).fill(defaultValue)) as number[][];\n\n    for (let i = 0; i < winMatrix.length; i++) {\n      winMatrix[i][i] = 0;\n    }\n\n    this.setState({\n      ...this.state,\n      candidates: newCandidates,\n      winMatrix: winMatrix,\n      nextCandidateLabel: '',\n      nextCandidateDesc: '',\n    });\n  }\n\n  setupNewComparison(): void {\n    let indexAWeights = this.state.candidates.map((ignore, idx) => {\n      return 1 / this.getTotalComparisons(idx);\n    });\n\n    let indexA = this.randomSelectWeighted(indexAWeights);\n\n    let indexBWeights = indexAWeights.map((ignore, idx) => {\n      if (idx === indexA) {\n        return 0;\n      }\n\n      return 1 / (this.state.winMatrix[idx][indexA] + this.state.winMatrix[indexA][idx]);\n    });\n\n    let indexB = this.randomSelectWeighted(indexBWeights);\n\n    this.setState({\n      ...this.state,\n      showListInput: false,\n      candidateIndexA: indexA,\n      candidateIndexB: indexB,\n    })\n  }\n\n  randomSelectWeighted(weights: number[]): number {\n    let sumWeight = weights.reduce(((previousValue, currentValue) => previousValue + currentValue));\n\n    let randomCutoff = Math.random() * sumWeight;\n    let sum = 0;\n    for (let i = 0; i < weights.length; i++) {\n      sum += weights[i];\n      if (sum >= randomCutoff) {\n        return i;\n      }\n    }\n\n    throw Error('should not get here');\n  }\n\n  getTotalComparisons(index: number): number {\n    let totalComparisons = 0;\n    for (let i = 0; i < this.state.winMatrix.length; i++) {\n      totalComparisons += this.state.winMatrix[index][i] + this.state.winMatrix[i][index];\n    }\n\n    return totalComparisons;\n  }\n\n  renderComparison(): ReactElement {\n    if (this.state.candidateIndexA < 0 || this.state.candidateIndexB < 0) {\n      return (<div>no comparison yet</div>);\n    }\n\n    let candidateA = this.state.candidates[this.state.candidateIndexA];\n    let candidateB = this.state.candidates[this.state.candidateIndexB];\n\n    return (<div style={{marginTop: '100px', marginBottom: '100px'}}>\n      <h2>Comparison</h2>\n      <div style={{display: 'flex'}}>\n        <div style={{flex: 1}}>\n          <h3>{candidateA.label}\n            <button onClick={() => this.updateWin(this.state.candidateIndexA, this.state.candidateIndexB)}>Select</button>\n          </h3>\n          {candidateA.description.split('\\n').map(line => (<p>{line}</p>))}\n        </div>\n        <div style={{flex: 1}}>\n          <h3>{candidateB.label}\n            <button onClick={() => this.updateWin(this.state.candidateIndexB, this.state.candidateIndexA)}>Select</button>\n          </h3>\n          {candidateB.description.split('\\n').map(line => (<p>{line}</p>))}\n        </div>\n      </div>\n    </div>)\n  }\n\n  updateWin(winIndex: number, loseIndex: number): void {\n    let winMatrix = this.state.winMatrix;\n    winMatrix[winIndex][loseIndex] += 1;\n\n    let candidates = this.state.candidates;\n    candidates[winIndex].wins += 1;\n    candidates[loseIndex].losses += 1;\n\n    // Update all the scores\n    // Based on sloppy implementation of https://stats.stackexchange.com/questions/83005/how-to-calculate-ratings-rankings-from-paired-comparison-pairwise-comparison-o\n    for (let iteration = 0; iteration < 1000; iteration++) {\n      // Naive iteration for now\n\n      for (let i = 0; i < candidates.length; i++) {\n\n        let W_i = 0;\n        for (let j = 0; j < candidates.length; j++) {\n          W_i += winMatrix[i][j];\n        }\n\n        let denominator = 0;\n        for (let j = 0; j < candidates.length; j++) {\n          if (i !== j) {\n            let N_ij = winMatrix[i][j] + winMatrix[j][i];\n            denominator += (N_ij) / (candidates[i].currentScore + candidates[j].currentScore);\n          }\n        }\n\n        candidates[i].currentScore = W_i / denominator;\n      }\n\n      // Re-normalize\n      let averageValue = 0;\n      for (let i = 0; i < candidates.length; i++) {\n        averageValue += candidates[i].currentScore;\n      }\n      averageValue /= candidates.length;\n      for (let i = 0; i < candidates.length; i++) {\n        candidates[i].currentScore /= averageValue;\n      }\n    }\n\n\n\n    this.setState({\n      ...this.state,\n      candidates: candidates,\n      winMatrix: winMatrix\n    }, () => {\n      this.setupNewComparison();\n    });\n  }\n\n  renderWinMatrix(): ReactElement {\n    if (!this.state.showCurrentScores) {\n      return (<div></div>);\n    }\n\n    return (<div><h2>Current Win Matrix</h2><pre>\n      {this.state.winMatrix.map(line => {\n        return line.join(',\\t') + '\\n';\n      })}\n    </pre></div>)\n  }\n\n  renderCandidates(): ReactElement {\n    if (!this.state.showCurrentScores && !this.state.showListInput) {\n      return (<div></div>);\n    }\n\n    let sortedCandidates = this.state.candidates\n        .map((candidate) => candidate) // Cheap sort\n        .sort((a, b) => b.currentScore - a.currentScore);\n\n    return (<div>\n      <h2>{sortedCandidates.length} Candidates</h2>\n      {sortedCandidates.map((candidate, idx) => {\n        return (<div>\n          <h3>{candidate.label} ({candidate.currentScore}, {candidate.wins} wins, {candidate.losses} losses)</h3>\n        </div>);\n      })}\n    </div>);\n  }\n\n  toggleShowCurrentScores(): void {\n    this.setState(\n        {...this.state, showCurrentScores: !this.state.showCurrentScores}\n    );\n  }\n\n  updateNextCandidateLabel(newValue: string): void {\n    this.setState({\n      ...this.state,\n      nextCandidateLabel: newValue\n    });\n  }\n\n  updateNextCandidateDesc(newValue: string): void {\n    this.setState({\n      ...this.state,\n      nextCandidateDesc: newValue\n    });\n  }\n\n  render() {\n    let mainContent;\n    if (this.state.showListInput) {\n      mainContent = (\n        <div>\n          <h2>Declare Candidates</h2>\n          <p>\n            Let's create some candidates\n          </p>\n          <div>\n            <input\n                type='text'\n                value={this.state.nextCandidateLabel}\n                onChange={(e) => this.updateNextCandidateLabel(e.target.value)} />\n            <textarea\n                value={this.state.nextCandidateDesc}\n                onChange={(e) => this.updateNextCandidateDesc(e.target.value)}></textarea>\n          </div>\n\n          <button style={{display: 'block'}} onClick={() => this.addCandidate()}>Add Candidate</button>\n          <button style={{display: 'block'}} onClick={() => this.setupNewComparison()}>Parse and begin</button>\n          {this.renderCandidates()}\n        </div>\n      );\n    } else {\n      mainContent = (<div>\n        {this.renderComparison()}\n\n        <button style={{display: 'block'}} onClick={() => this.toggleShowCurrentScores()}>Toggle results</button>\n\n        {this.renderWinMatrix()}\n        {this.renderCandidates()}\n      </div>);\n    }\n\n    return (\n        <div style={{margin: '24px'}}>\n          <h1>Decisions</h1>\n          <p>\n            Let's make some decisions based on pairwise comparisons. You know that FaceMash scene in Social Network?\n            It's just like that, except hopefully you're using it for better decisions.\n          </p>\n          {mainContent}\n        </div>\n    );\n  }\n}\n","import React from 'react';\nimport './App.css';\nimport RevisionHeader from './features/revision-header/RevisionHeader';\nimport {\n  HashRouter as Router,\n  Switch,\n  Route\n} from 'react-router-dom';\n\nimport Homepage from './pages/homepage/Homepage';\nimport StoryDetailsPage from './pages/story-details/StoryDetailsPage';\nimport DataManagementPage from './pages/import-export/DataManagementPage';\nimport ScrapDetailsPage from './pages/scrap-details/ScrapDetailsPage';\nimport DecisionPage from './pages/decisions/DecisionPage';\n\nfunction App() {\n  return (\n      <div style={{padding: 0, margin: 0, height: '100vh'}}>\n    <Router >\n      <RevisionHeader />\n      <div style={{\n        //margin: '24px',\n        height: 'calc(100% - 68px)',\n      }}>\n        <Switch>\n          <Route path=\"/decisions\" component={DecisionPage} />\n          <Route path=\"/data\" component={DataManagementPage} />\n          <Route path=\"/story/:id\" component={StoryDetailsPage} />\n          <Route path=\"/scrap/:id\" component={ScrapDetailsPage} />\n          <Route path=\"/\" component={Homepage} />\n        </Switch>\n      </div>\n    </Router>\n      </div>\n  );\n}\n\nexport default App;\n","import {configureStore, ThunkAction, Action} from '@reduxjs/toolkit';\nimport storyListReducer, {storyListPersistenceMiddleware} from '../features/storyList/storyListSlice';\nimport scrapListReducer, {scrapListPersistenceMiddleware} from '../features/scrapList/scrapListSlice';\n\nexport const store = configureStore({\n  reducer: {\n    storyList: storyListReducer,\n    scrapList: scrapListReducer,\n  },\n  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat([\n    storyListPersistenceMiddleware,\n    scrapListPersistenceMiddleware,\n  ])\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\nimport 'semantic-ui-css/semantic.min.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}