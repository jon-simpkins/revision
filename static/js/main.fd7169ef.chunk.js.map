{"version":3,"sources":["protos_v2.js","features/revision-header/RevisionHeader.tsx","features/storyList/StoryCard.tsx","features/storyList/storyListPersistence.ts","features/storyList/storyListSlice.ts","app/hooks.ts","features/scrapList/scrapListPersistence.ts","features/scrapList/scrapListSlice.ts","pages/homepage/Homepage.tsx","features/storyDetails/StoryDetails.tsx","pages/story-details/StoryDetailsPage.tsx","pages/import-export/DataManagementPage.tsx","pages/scrap-details/ScrapDetailsPage.tsx","App.tsx","app/store.ts","serviceWorker.ts","index.tsx"],"names":["define","$protobuf","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","Timestamp","properties","keys","Object","i","length","this","prototype","seconds","nanos","create","encode","message","writer","hasOwnProperty","call","uint32","int32","encodeDelimited","ldelim","decode","reader","end","undefined","len","pos","tag","skipType","decodeDelimited","verify","isInteger","fromObject","object","toObject","options","defaults","toJSON","constructor","toJSONOptions","Duration","Story","relatedStoryIds","id","name","description","duration","emptyArray","string","fork","push","isString","error","Array","isArray","String","TypeError","arrays","j","Scrap","structure","brainstorm","stories","intendedDurationSec","synopsis","prose","WritingWorkspace","scraps","RevisionHeader","Menu","to","Item","header","Icon","Component","StoryCard","props","story","getCardUrl","Card","style","margin","Content","split","map","line","idx","allStoryIdsKey","storyKey","readAllStoriesFromStorage","readStoryIds","storyString","localStorage","getItem","Error","JSON","parse","readStory","storyIdString","writeStoryIds","storyIds","setItem","stringify","writeStory","addStoryToStorage","allStoryIds","initialState","storyMap","forEach","fetchInitialStateFromStorage","actionPrefix","storyListSlice","createSlice","reducers","createStory","state","action","payload","updateStory","removeStory","storyListPersistenceMiddleware","storeAPI","next","result","type","startsWith","handleStoryListPersistence","idToRemove","filter","removeItem","selectStoryMap","compiledStoryMap","entries","storyList","key","value","actions","useAppDispatch","useDispatch","useAppSelector","useSelector","allScrapIdsKey","scrapKey","readAllScrapsFromStorage","readScrapIds","scrapString","readScrap","writeScrapIds","scrapIds","writeScrap","scrap","addScrapToStorage","allScrapIds","scrapMap","ScrapListSlice","createScrap","updateScrap","removeScrap","scrapListPersistenceMiddleware","handleScrapListPersistence","selectScrapMap","compiledScrapMap","scrapList","getStorySection","values","Segment","display","flexWrap","Homepage","dispatch","history","useHistory","Group","Header","size","Subheader","flex","textAlign","Button","icon","color","onClick","newStory","uuid","associatedStoryId","newScrap","StoryDetails","durationErrorString","currentScrapFilter","currentScrapId","newName","onStoryChange","newDescription","durationSec","durationStr","hours","Math","floor","toString","padStart","minutes","newDuration","RegExp","test","setDurationErrorString","splitDurationStr","Boolean","parseInt","hasError","setState","indexOf","linkUnlinkButton","currentScrap","find","editingScrap","storyId","onScrapUpdate","Container","text","marginTop","primary","onStoryDelete","Form","widths","Input","label","defaultValue","onChange","e","onNameChange","target","getDurationString","onDurationChange","Field","TextArea","onDescriptionChange","fontFamily","height","onScrapCreate","createNewScrap","pointing","vertical","Dropdown","fluid","selection","getFilteredScraps","active","marginLeft","renderScrapDetails","StoryDetailsPage","match","params","fetchedStory","topLevelScraps","downloadWorkspace","filename","Date","now","fileDownload","workspace","finish","loadDataFromStorage","files","a","arrayBuffer","fileData","loadDataToStorage","Uint8Array","window","location","reload","data","clear","DataManagementPage","accept","event","uploadWorkspace","ScrapDetailsPage","App","path","component","store","configureStore","reducer","storyListReducer","scrapListReducer","middleware","getDefaultMiddleware","concat","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console"],"mappings":"wFAAA,UAIQA,EAAO,CAAC,aAAF,6BAKL,SAASC,GACd,aAGA,IAAIC,EAAUD,EAAUE,OAAQC,EAAUH,EAAUI,OAAQC,EAAQL,EAAUM,KAG1EC,EAAQP,EAAUQ,MAAV,UAA+BR,EAAUQ,MAAV,QAA6B,IA8zCxE,OA5zCAD,EAAME,UAAa,WAkBf,SAASA,EAAUC,GACf,GAAIA,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAaG,EAAI,EAAGA,EAAIF,EAAKG,SAAUD,EACpC,MAAvBH,EAAWC,EAAKE,MAChBE,KAAKJ,EAAKE,IAAMH,EAAWC,EAAKE,KAyLhD,OAhLAJ,EAAUO,UAAUC,QAAU,EAQ9BR,EAAUO,UAAUE,MAAQ,EAU5BT,EAAUU,OAAS,SAAgBT,GAC/B,OAAO,IAAID,EAAUC,IAYzBD,EAAUW,OAAS,SAAgBC,EAASC,GAOxC,OANKA,IACDA,EAASnB,EAAQgB,UACE,MAAnBE,EAAQJ,SAAmBL,OAAOW,eAAeC,KAAKH,EAAS,YAC/DC,EAAOG,OAA8B,GAAGC,MAAML,EAAQJ,SACrC,MAAjBI,EAAQH,OAAiBN,OAAOW,eAAeC,KAAKH,EAAS,UAC7DC,EAAOG,OAA8B,IAAIC,MAAML,EAAQH,OACpDI,GAYXb,EAAUkB,gBAAkB,SAAyBN,EAASC,GAC1D,OAAOP,KAAKK,OAAOC,EAASC,GAAQM,UAcxCnB,EAAUoB,OAAS,SAAgBC,EAAQhB,GACjCgB,aAAkB7B,IACpB6B,EAAS7B,EAAQkB,OAAOW,IAE5B,IADA,IAAIC,OAAiBC,IAAXlB,EAAuBgB,EAAOG,IAAMH,EAAOI,IAAMpB,EAAQO,EAAU,IAAId,EAAME,UAChFqB,EAAOI,IAAMH,GAAK,CACrB,IAAII,EAAML,EAAOL,SACjB,OAAQU,IAAQ,GAChB,KAAK,EACDd,EAAQJ,QAAUa,EAAOJ,QACzB,MACJ,KAAK,EACDL,EAAQH,MAAQY,EAAOJ,QACvB,MACJ,QACII,EAAOM,SAAe,EAAND,IAIxB,OAAOd,GAaXZ,EAAU4B,gBAAkB,SAAyBP,GAGjD,OAFMA,aAAkB7B,IACpB6B,EAAS,IAAI7B,EAAQ6B,IAClBf,KAAKc,OAAOC,EAAQA,EAAOL,WAWtChB,EAAU6B,OAAS,SAAgBjB,GAC/B,MAAuB,kBAAZA,GAAoC,OAAZA,EACxB,kBACY,MAAnBA,EAAQJ,SAAmBI,EAAQE,eAAe,aAC7ClB,EAAMkC,UAAUlB,EAAQJ,SAClB,4BACM,MAAjBI,EAAQH,OAAiBG,EAAQE,eAAe,WAC3ClB,EAAMkC,UAAUlB,EAAQH,OAClB,0BACR,MAWXT,EAAU+B,WAAa,SAAoBC,GACvC,GAAIA,aAAkBlC,EAAME,UACxB,OAAOgC,EACX,IAAIpB,EAAU,IAAId,EAAME,UAKxB,OAJsB,MAAlBgC,EAAOxB,UACPI,EAAQJ,QAA2B,EAAjBwB,EAAOxB,SACT,MAAhBwB,EAAOvB,QACPG,EAAQH,MAAuB,EAAfuB,EAAOvB,OACpBG,GAYXZ,EAAUiC,SAAW,SAAkBrB,EAASsB,GACvCA,IACDA,EAAU,IACd,IAAIF,EAAS,GASb,OARIE,EAAQC,WACRH,EAAOxB,QAAU,EACjBwB,EAAOvB,MAAQ,GAEI,MAAnBG,EAAQJ,SAAmBI,EAAQE,eAAe,aAClDkB,EAAOxB,QAAUI,EAAQJ,SACR,MAAjBI,EAAQH,OAAiBG,EAAQE,eAAe,WAChDkB,EAAOvB,MAAQG,EAAQH,OACpBuB,GAUXhC,EAAUO,UAAU6B,OAAS,WACzB,OAAO9B,KAAK+B,YAAYJ,SAAS3B,KAAMf,EAAUM,KAAKyC,gBAGnDtC,EA/MQ,GAkNnBF,EAAMyC,SAAY,WAkBd,SAASA,EAAStC,GACd,GAAIA,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAaG,EAAI,EAAGA,EAAIF,EAAKG,SAAUD,EACpC,MAAvBH,EAAWC,EAAKE,MAChBE,KAAKJ,EAAKE,IAAMH,EAAWC,EAAKE,KAyLhD,OAhLAmC,EAAShC,UAAUC,QAAU,EAQ7B+B,EAAShC,UAAUE,MAAQ,EAU3B8B,EAAS7B,OAAS,SAAgBT,GAC9B,OAAO,IAAIsC,EAAStC,IAYxBsC,EAAS5B,OAAS,SAAgBC,EAASC,GAOvC,OANKA,IACDA,EAASnB,EAAQgB,UACE,MAAnBE,EAAQJ,SAAmBL,OAAOW,eAAeC,KAAKH,EAAS,YAC/DC,EAAOG,OAA8B,GAAGC,MAAML,EAAQJ,SACrC,MAAjBI,EAAQH,OAAiBN,OAAOW,eAAeC,KAAKH,EAAS,UAC7DC,EAAOG,OAA8B,IAAIC,MAAML,EAAQH,OACpDI,GAYX0B,EAASrB,gBAAkB,SAAyBN,EAASC,GACzD,OAAOP,KAAKK,OAAOC,EAASC,GAAQM,UAcxCoB,EAASnB,OAAS,SAAgBC,EAAQhB,GAChCgB,aAAkB7B,IACpB6B,EAAS7B,EAAQkB,OAAOW,IAE5B,IADA,IAAIC,OAAiBC,IAAXlB,EAAuBgB,EAAOG,IAAMH,EAAOI,IAAMpB,EAAQO,EAAU,IAAId,EAAMyC,SAChFlB,EAAOI,IAAMH,GAAK,CACrB,IAAII,EAAML,EAAOL,SACjB,OAAQU,IAAQ,GAChB,KAAK,EACDd,EAAQJ,QAAUa,EAAOJ,QACzB,MACJ,KAAK,EACDL,EAAQH,MAAQY,EAAOJ,QACvB,MACJ,QACII,EAAOM,SAAe,EAAND,IAIxB,OAAOd,GAaX2B,EAASX,gBAAkB,SAAyBP,GAGhD,OAFMA,aAAkB7B,IACpB6B,EAAS,IAAI7B,EAAQ6B,IAClBf,KAAKc,OAAOC,EAAQA,EAAOL,WAWtCuB,EAASV,OAAS,SAAgBjB,GAC9B,MAAuB,kBAAZA,GAAoC,OAAZA,EACxB,kBACY,MAAnBA,EAAQJ,SAAmBI,EAAQE,eAAe,aAC7ClB,EAAMkC,UAAUlB,EAAQJ,SAClB,4BACM,MAAjBI,EAAQH,OAAiBG,EAAQE,eAAe,WAC3ClB,EAAMkC,UAAUlB,EAAQH,OAClB,0BACR,MAWX8B,EAASR,WAAa,SAAoBC,GACtC,GAAIA,aAAkBlC,EAAMyC,SACxB,OAAOP,EACX,IAAIpB,EAAU,IAAId,EAAMyC,SAKxB,OAJsB,MAAlBP,EAAOxB,UACPI,EAAQJ,QAA2B,EAAjBwB,EAAOxB,SACT,MAAhBwB,EAAOvB,QACPG,EAAQH,MAAuB,EAAfuB,EAAOvB,OACpBG,GAYX2B,EAASN,SAAW,SAAkBrB,EAASsB,GACtCA,IACDA,EAAU,IACd,IAAIF,EAAS,GASb,OARIE,EAAQC,WACRH,EAAOxB,QAAU,EACjBwB,EAAOvB,MAAQ,GAEI,MAAnBG,EAAQJ,SAAmBI,EAAQE,eAAe,aAClDkB,EAAOxB,QAAUI,EAAQJ,SACR,MAAjBI,EAAQH,OAAiBG,EAAQE,eAAe,WAChDkB,EAAOvB,MAAQG,EAAQH,OACpBuB,GAUXO,EAAShC,UAAU6B,OAAS,WACxB,OAAO9B,KAAK+B,YAAYJ,SAAS3B,KAAMf,EAAUM,KAAKyC,gBAGnDC,EA/MO,GAkNlBzC,EAAM0C,MAAS,WAqBX,SAASA,EAAMvC,GAEX,GADAK,KAAKmC,gBAAkB,GACnBxC,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAaG,EAAI,EAAGA,EAAIF,EAAKG,SAAUD,EACpC,MAAvBH,EAAWC,EAAKE,MAChBE,KAAKJ,EAAKE,IAAMH,EAAWC,EAAKE,KA6QhD,OApQAoC,EAAMjC,UAAUmC,GAAK,GAQrBF,EAAMjC,UAAUoC,KAAO,GAQvBH,EAAMjC,UAAUqC,YAAc,GAQ9BJ,EAAMjC,UAAUsC,SAAW,KAQ3BL,EAAMjC,UAAUkC,gBAAkB7C,EAAMkD,WAUxCN,EAAM9B,OAAS,SAAgBT,GAC3B,OAAO,IAAIuC,EAAMvC,IAYrBuC,EAAM7B,OAAS,SAAgBC,EAASC,GASpC,GARKA,IACDA,EAASnB,EAAQgB,UACH,MAAdE,EAAQ8B,IAAcvC,OAAOW,eAAeC,KAAKH,EAAS,OAC1DC,EAAOG,OAA8B,IAAI+B,OAAOnC,EAAQ8B,IACxC,MAAhB9B,EAAQ+B,MAAgBxC,OAAOW,eAAeC,KAAKH,EAAS,SAC5DC,EAAOG,OAA8B,IAAI+B,OAAOnC,EAAQ+B,MACpC,MAApB/B,EAAQiC,UAAoB1C,OAAOW,eAAeC,KAAKH,EAAS,aAChEd,EAAMyC,SAAS5B,OAAOC,EAAQiC,SAAUhC,EAAOG,OAA8B,IAAIgC,QAAQ7B,SAC9D,MAA3BP,EAAQ6B,iBAA2B7B,EAAQ6B,gBAAgBpC,OAC3D,IAAK,IAAID,EAAI,EAAGA,EAAIQ,EAAQ6B,gBAAgBpC,SAAUD,EAClDS,EAAOG,OAA8B,IAAI+B,OAAOnC,EAAQ6B,gBAAgBrC,IAGhF,OAF2B,MAAvBQ,EAAQgC,aAAuBzC,OAAOW,eAAeC,KAAKH,EAAS,gBACnEC,EAAOG,OAA8B,IAAI+B,OAAOnC,EAAQgC,aACrD/B,GAYX2B,EAAMtB,gBAAkB,SAAyBN,EAASC,GACtD,OAAOP,KAAKK,OAAOC,EAASC,GAAQM,UAcxCqB,EAAMpB,OAAS,SAAgBC,EAAQhB,GAC7BgB,aAAkB7B,IACpB6B,EAAS7B,EAAQkB,OAAOW,IAE5B,IADA,IAAIC,OAAiBC,IAAXlB,EAAuBgB,EAAOG,IAAMH,EAAOI,IAAMpB,EAAQO,EAAU,IAAId,EAAM0C,MAChFnB,EAAOI,IAAMH,GAAK,CACrB,IAAII,EAAML,EAAOL,SACjB,OAAQU,IAAQ,GAChB,KAAK,EACDd,EAAQ8B,GAAKrB,EAAO0B,SACpB,MACJ,KAAK,EACDnC,EAAQ+B,KAAOtB,EAAO0B,SACtB,MACJ,KAAK,EACDnC,EAAQgC,YAAcvB,EAAO0B,SAC7B,MACJ,KAAK,EACDnC,EAAQiC,SAAW/C,EAAMyC,SAASnB,OAAOC,EAAQA,EAAOL,UACxD,MACJ,KAAK,EACKJ,EAAQ6B,iBAAmB7B,EAAQ6B,gBAAgBpC,SACrDO,EAAQ6B,gBAAkB,IAC9B7B,EAAQ6B,gBAAgBQ,KAAK5B,EAAO0B,UACpC,MACJ,QACI1B,EAAOM,SAAe,EAAND,IAIxB,OAAOd,GAaX4B,EAAMZ,gBAAkB,SAAyBP,GAG7C,OAFMA,aAAkB7B,IACpB6B,EAAS,IAAI7B,EAAQ6B,IAClBf,KAAKc,OAAOC,EAAQA,EAAOL,WAWtCwB,EAAMX,OAAS,SAAgBjB,GAC3B,GAAuB,kBAAZA,GAAoC,OAAZA,EAC/B,MAAO,kBACX,GAAkB,MAAdA,EAAQ8B,IAAc9B,EAAQE,eAAe,QACxClB,EAAMsD,SAAStC,EAAQ8B,IACxB,MAAO,sBACf,GAAoB,MAAhB9B,EAAQ+B,MAAgB/B,EAAQE,eAAe,UAC1ClB,EAAMsD,SAAStC,EAAQ+B,MACxB,MAAO,wBACf,GAA2B,MAAvB/B,EAAQgC,aAAuBhC,EAAQE,eAAe,iBACjDlB,EAAMsD,SAAStC,EAAQgC,aACxB,MAAO,+BACf,GAAwB,MAApBhC,EAAQiC,UAAoBjC,EAAQE,eAAe,YAAa,CAChE,IAAIqC,EAAQrD,EAAMyC,SAASV,OAAOjB,EAAQiC,UAC1C,GAAIM,EACA,MAAO,YAAcA,EAE7B,GAA+B,MAA3BvC,EAAQ6B,iBAA2B7B,EAAQE,eAAe,mBAAoB,CAC9E,IAAKsC,MAAMC,QAAQzC,EAAQ6B,iBACvB,MAAO,kCACX,IAAK,IAAIrC,EAAI,EAAGA,EAAIQ,EAAQ6B,gBAAgBpC,SAAUD,EAClD,IAAKR,EAAMsD,SAAStC,EAAQ6B,gBAAgBrC,IACxC,MAAO,qCAEnB,OAAO,MAWXoC,EAAMT,WAAa,SAAoBC,GACnC,GAAIA,aAAkBlC,EAAM0C,MACxB,OAAOR,EACX,IAAIpB,EAAU,IAAId,EAAM0C,MAOxB,GANiB,MAAbR,EAAOU,KACP9B,EAAQ8B,GAAKY,OAAOtB,EAAOU,KACZ,MAAfV,EAAOW,OACP/B,EAAQ+B,KAAOW,OAAOtB,EAAOW,OACP,MAAtBX,EAAOY,cACPhC,EAAQgC,YAAcU,OAAOtB,EAAOY,cACjB,MAAnBZ,EAAOa,SAAkB,CACzB,GAA+B,kBAApBb,EAAOa,SACd,MAAMU,UAAU,oCACpB3C,EAAQiC,SAAW/C,EAAMyC,SAASR,WAAWC,EAAOa,UAExD,GAAIb,EAAOS,gBAAiB,CACxB,IAAKW,MAAMC,QAAQrB,EAAOS,iBACtB,MAAMc,UAAU,0CACpB3C,EAAQ6B,gBAAkB,GAC1B,IAAK,IAAIrC,EAAI,EAAGA,EAAI4B,EAAOS,gBAAgBpC,SAAUD,EACjDQ,EAAQ6B,gBAAgBrC,GAAKkD,OAAOtB,EAAOS,gBAAgBrC,IAEnE,OAAOQ,GAYX4B,EAAMP,SAAW,SAAkBrB,EAASsB,GACnCA,IACDA,EAAU,IACd,IAAIF,EAAS,GAeb,IAdIE,EAAQsB,QAAUtB,EAAQC,YAC1BH,EAAOS,gBAAkB,IACzBP,EAAQC,WACRH,EAAOU,GAAK,GACZV,EAAOW,KAAO,GACdX,EAAOa,SAAW,KAClBb,EAAOY,YAAc,IAEP,MAAdhC,EAAQ8B,IAAc9B,EAAQE,eAAe,QAC7CkB,EAAOU,GAAK9B,EAAQ8B,IACJ,MAAhB9B,EAAQ+B,MAAgB/B,EAAQE,eAAe,UAC/CkB,EAAOW,KAAO/B,EAAQ+B,MACF,MAApB/B,EAAQiC,UAAoBjC,EAAQE,eAAe,cACnDkB,EAAOa,SAAW/C,EAAMyC,SAASN,SAASrB,EAAQiC,SAAUX,IAC5DtB,EAAQ6B,iBAAmB7B,EAAQ6B,gBAAgBpC,OAAQ,CAC3D2B,EAAOS,gBAAkB,GACzB,IAAK,IAAIgB,EAAI,EAAGA,EAAI7C,EAAQ6B,gBAAgBpC,SAAUoD,EAClDzB,EAAOS,gBAAgBgB,GAAK7C,EAAQ6B,gBAAgBgB,GAI5D,OAF2B,MAAvB7C,EAAQgC,aAAuBhC,EAAQE,eAAe,iBACtDkB,EAAOY,YAAchC,EAAQgC,aAC1BZ,GAUXQ,EAAMjC,UAAU6B,OAAS,WACrB,OAAO9B,KAAK+B,YAAYJ,SAAS3B,KAAMf,EAAUM,KAAKyC,gBAGnDE,EAvSI,GA0Sf1C,EAAM4D,MAAS,WAuBX,SAASA,EAAMzD,GAIX,GAHAK,KAAKqD,UAAY,GACjBrD,KAAKsD,WAAa,GAClBtD,KAAKuD,QAAU,GACX5D,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAaG,EAAI,EAAGA,EAAIF,EAAKG,SAAUD,EACpC,MAAvBH,EAAWC,EAAKE,MAChBE,KAAKJ,EAAKE,IAAMH,EAAWC,EAAKE,KAiVhD,OAxUAsD,EAAMnD,UAAUmC,GAAK,GAQrBgB,EAAMnD,UAAUuD,oBAAsB,EAQtCJ,EAAMnD,UAAUwD,SAAW,GAQ3BL,EAAMnD,UAAUyD,MAAQ,GAQxBN,EAAMnD,UAAUoD,UAAY/D,EAAMkD,WAQlCY,EAAMnD,UAAUqD,WAAahE,EAAMkD,WAQnCY,EAAMnD,UAAUsD,QAAUjE,EAAMkD,WAUhCY,EAAMhD,OAAS,SAAgBT,GAC3B,OAAO,IAAIyD,EAAMzD,IAYrByD,EAAM/C,OAAS,SAAgBC,EAASC,GAWpC,GAVKA,IACDA,EAASnB,EAAQgB,UACH,MAAdE,EAAQ8B,IAAcvC,OAAOW,eAAeC,KAAKH,EAAS,OAC1DC,EAAOG,OAA8B,IAAI+B,OAAOnC,EAAQ8B,IACzB,MAA/B9B,EAAQkD,qBAA+B3D,OAAOW,eAAeC,KAAKH,EAAS,wBAC3EC,EAAOG,OAA8B,IAAIA,OAAOJ,EAAQkD,qBACpC,MAApBlD,EAAQmD,UAAoB5D,OAAOW,eAAeC,KAAKH,EAAS,aAChEC,EAAOG,OAA8B,IAAI+B,OAAOnC,EAAQmD,UACvC,MAAjBnD,EAAQoD,OAAiB7D,OAAOW,eAAeC,KAAKH,EAAS,UAC7DC,EAAOG,OAA8B,IAAI+B,OAAOnC,EAAQoD,OACnC,MAArBpD,EAAQ+C,WAAqB/C,EAAQ+C,UAAUtD,OAC/C,IAAK,IAAID,EAAI,EAAGA,EAAIQ,EAAQ+C,UAAUtD,SAAUD,EAC5CS,EAAOG,OAA8B,IAAI+B,OAAOnC,EAAQ+C,UAAUvD,IAC1E,GAA0B,MAAtBQ,EAAQgD,YAAsBhD,EAAQgD,WAAWvD,OACjD,IAASD,EAAI,EAAGA,EAAIQ,EAAQgD,WAAWvD,SAAUD,EAC7CS,EAAOG,OAA8B,IAAI+B,OAAOnC,EAAQgD,WAAWxD,IAC3E,GAAuB,MAAnBQ,EAAQiD,SAAmBjD,EAAQiD,QAAQxD,OAC3C,IAASD,EAAI,EAAGA,EAAIQ,EAAQiD,QAAQxD,SAAUD,EAC1CS,EAAOG,OAA8B,IAAI+B,OAAOnC,EAAQiD,QAAQzD,IACxE,OAAOS,GAYX6C,EAAMxC,gBAAkB,SAAyBN,EAASC,GACtD,OAAOP,KAAKK,OAAOC,EAASC,GAAQM,UAcxCuC,EAAMtC,OAAS,SAAgBC,EAAQhB,GAC7BgB,aAAkB7B,IACpB6B,EAAS7B,EAAQkB,OAAOW,IAE5B,IADA,IAAIC,OAAiBC,IAAXlB,EAAuBgB,EAAOG,IAAMH,EAAOI,IAAMpB,EAAQO,EAAU,IAAId,EAAM4D,MAChFrC,EAAOI,IAAMH,GAAK,CACrB,IAAII,EAAML,EAAOL,SACjB,OAAQU,IAAQ,GAChB,KAAK,EACDd,EAAQ8B,GAAKrB,EAAO0B,SACpB,MACJ,KAAK,EACDnC,EAAQkD,oBAAsBzC,EAAOL,SACrC,MACJ,KAAK,EACDJ,EAAQmD,SAAW1C,EAAO0B,SAC1B,MACJ,KAAK,EACDnC,EAAQoD,MAAQ3C,EAAO0B,SACvB,MACJ,KAAK,EACKnC,EAAQ+C,WAAa/C,EAAQ+C,UAAUtD,SACzCO,EAAQ+C,UAAY,IACxB/C,EAAQ+C,UAAUV,KAAK5B,EAAO0B,UAC9B,MACJ,KAAK,EACKnC,EAAQgD,YAAchD,EAAQgD,WAAWvD,SAC3CO,EAAQgD,WAAa,IACzBhD,EAAQgD,WAAWX,KAAK5B,EAAO0B,UAC/B,MACJ,KAAK,EACKnC,EAAQiD,SAAWjD,EAAQiD,QAAQxD,SACrCO,EAAQiD,QAAU,IACtBjD,EAAQiD,QAAQZ,KAAK5B,EAAO0B,UAC5B,MACJ,QACI1B,EAAOM,SAAe,EAAND,IAIxB,OAAOd,GAaX8C,EAAM9B,gBAAkB,SAAyBP,GAG7C,OAFMA,aAAkB7B,IACpB6B,EAAS,IAAI7B,EAAQ6B,IAClBf,KAAKc,OAAOC,EAAQA,EAAOL,WAWtC0C,EAAM7B,OAAS,SAAgBjB,GAC3B,GAAuB,kBAAZA,GAAoC,OAAZA,EAC/B,MAAO,kBACX,GAAkB,MAAdA,EAAQ8B,IAAc9B,EAAQE,eAAe,QACxClB,EAAMsD,SAAStC,EAAQ8B,IACxB,MAAO,sBACf,GAAmC,MAA/B9B,EAAQkD,qBAA+BlD,EAAQE,eAAe,yBACzDlB,EAAMkC,UAAUlB,EAAQkD,qBACzB,MAAO,wCACf,GAAwB,MAApBlD,EAAQmD,UAAoBnD,EAAQE,eAAe,cAC9ClB,EAAMsD,SAAStC,EAAQmD,UACxB,MAAO,4BACf,GAAqB,MAAjBnD,EAAQoD,OAAiBpD,EAAQE,eAAe,WAC3ClB,EAAMsD,SAAStC,EAAQoD,OACxB,MAAO,yBACf,GAAyB,MAArBpD,EAAQ+C,WAAqB/C,EAAQE,eAAe,aAAc,CAClE,IAAKsC,MAAMC,QAAQzC,EAAQ+C,WACvB,MAAO,4BACX,IAAK,IAAIvD,EAAI,EAAGA,EAAIQ,EAAQ+C,UAAUtD,SAAUD,EAC5C,IAAKR,EAAMsD,SAAStC,EAAQ+C,UAAUvD,IAClC,MAAO,+BAEnB,GAA0B,MAAtBQ,EAAQgD,YAAsBhD,EAAQE,eAAe,cAAe,CACpE,IAAKsC,MAAMC,QAAQzC,EAAQgD,YACvB,MAAO,6BACX,IAASxD,EAAI,EAAGA,EAAIQ,EAAQgD,WAAWvD,SAAUD,EAC7C,IAAKR,EAAMsD,SAAStC,EAAQgD,WAAWxD,IACnC,MAAO,gCAEnB,GAAuB,MAAnBQ,EAAQiD,SAAmBjD,EAAQE,eAAe,WAAY,CAC9D,IAAKsC,MAAMC,QAAQzC,EAAQiD,SACvB,MAAO,0BACX,IAASzD,EAAI,EAAGA,EAAIQ,EAAQiD,QAAQxD,SAAUD,EAC1C,IAAKR,EAAMsD,SAAStC,EAAQiD,QAAQzD,IAChC,MAAO,6BAEnB,OAAO,MAWXsD,EAAM3B,WAAa,SAAoBC,GACnC,GAAIA,aAAkBlC,EAAM4D,MACxB,OAAO1B,EACX,IAAIpB,EAAU,IAAId,EAAM4D,MASxB,GARiB,MAAb1B,EAAOU,KACP9B,EAAQ8B,GAAKY,OAAOtB,EAAOU,KACG,MAA9BV,EAAO8B,sBACPlD,EAAQkD,oBAAsB9B,EAAO8B,sBAAwB,GAC1C,MAAnB9B,EAAO+B,WACPnD,EAAQmD,SAAWT,OAAOtB,EAAO+B,WACjB,MAAhB/B,EAAOgC,QACPpD,EAAQoD,MAAQV,OAAOtB,EAAOgC,QAC9BhC,EAAO2B,UAAW,CAClB,IAAKP,MAAMC,QAAQrB,EAAO2B,WACtB,MAAMJ,UAAU,oCACpB3C,EAAQ+C,UAAY,GACpB,IAAK,IAAIvD,EAAI,EAAGA,EAAI4B,EAAO2B,UAAUtD,SAAUD,EAC3CQ,EAAQ+C,UAAUvD,GAAKkD,OAAOtB,EAAO2B,UAAUvD,IAEvD,GAAI4B,EAAO4B,WAAY,CACnB,IAAKR,MAAMC,QAAQrB,EAAO4B,YACtB,MAAML,UAAU,qCAEpB,IADA3C,EAAQgD,WAAa,GACZxD,EAAI,EAAGA,EAAI4B,EAAO4B,WAAWvD,SAAUD,EAC5CQ,EAAQgD,WAAWxD,GAAKkD,OAAOtB,EAAO4B,WAAWxD,IAEzD,GAAI4B,EAAO6B,QAAS,CAChB,IAAKT,MAAMC,QAAQrB,EAAO6B,SACtB,MAAMN,UAAU,kCAEpB,IADA3C,EAAQiD,QAAU,GACTzD,EAAI,EAAGA,EAAI4B,EAAO6B,QAAQxD,SAAUD,EACzCQ,EAAQiD,QAAQzD,GAAKkD,OAAOtB,EAAO6B,QAAQzD,IAEnD,OAAOQ,GAYX8C,EAAMzB,SAAW,SAAkBrB,EAASsB,GACnCA,IACDA,EAAU,IACd,IAAIF,EAAS,GAoBb,IAnBIE,EAAQsB,QAAUtB,EAAQC,YAC1BH,EAAO2B,UAAY,GACnB3B,EAAO4B,WAAa,GACpB5B,EAAO6B,QAAU,IAEjB3B,EAAQC,WACRH,EAAOU,GAAK,GACZV,EAAO8B,oBAAsB,EAC7B9B,EAAO+B,SAAW,GAClB/B,EAAOgC,MAAQ,IAED,MAAdpD,EAAQ8B,IAAc9B,EAAQE,eAAe,QAC7CkB,EAAOU,GAAK9B,EAAQ8B,IACW,MAA/B9B,EAAQkD,qBAA+BlD,EAAQE,eAAe,yBAC9DkB,EAAO8B,oBAAsBlD,EAAQkD,qBACjB,MAApBlD,EAAQmD,UAAoBnD,EAAQE,eAAe,cACnDkB,EAAO+B,SAAWnD,EAAQmD,UACT,MAAjBnD,EAAQoD,OAAiBpD,EAAQE,eAAe,WAChDkB,EAAOgC,MAAQpD,EAAQoD,OACvBpD,EAAQ+C,WAAa/C,EAAQ+C,UAAUtD,OAAQ,CAC/C2B,EAAO2B,UAAY,GACnB,IAAK,IAAIF,EAAI,EAAGA,EAAI7C,EAAQ+C,UAAUtD,SAAUoD,EAC5CzB,EAAO2B,UAAUF,GAAK7C,EAAQ+C,UAAUF,GAEhD,GAAI7C,EAAQgD,YAAchD,EAAQgD,WAAWvD,OAEzC,IADA2B,EAAO4B,WAAa,GACXH,EAAI,EAAGA,EAAI7C,EAAQgD,WAAWvD,SAAUoD,EAC7CzB,EAAO4B,WAAWH,GAAK7C,EAAQgD,WAAWH,GAElD,GAAI7C,EAAQiD,SAAWjD,EAAQiD,QAAQxD,OAEnC,IADA2B,EAAO6B,QAAU,GACRJ,EAAI,EAAGA,EAAI7C,EAAQiD,QAAQxD,SAAUoD,EAC1CzB,EAAO6B,QAAQJ,GAAK7C,EAAQiD,QAAQJ,GAE5C,OAAOzB,GAUX0B,EAAMnD,UAAU6B,OAAS,WACrB,OAAO9B,KAAK+B,YAAYJ,SAAS3B,KAAMf,EAAUM,KAAKyC,gBAGnDoB,EA/WI,GAkXf5D,EAAMmE,iBAAoB,WAkBtB,SAASA,EAAiBhE,GAGtB,GAFAK,KAAKuD,QAAU,GACfvD,KAAK4D,OAAS,GACVjE,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAaG,EAAI,EAAGA,EAAIF,EAAKG,SAAUD,EACpC,MAAvBH,EAAWC,EAAKE,MAChBE,KAAKJ,EAAKE,IAAMH,EAAWC,EAAKE,KAiOhD,OAxNA6D,EAAiB1D,UAAUsD,QAAUjE,EAAMkD,WAQ3CmB,EAAiB1D,UAAU2D,OAAStE,EAAMkD,WAU1CmB,EAAiBvD,OAAS,SAAgBT,GACtC,OAAO,IAAIgE,EAAiBhE,IAYhCgE,EAAiBtD,OAAS,SAAgBC,EAASC,GAG/C,GAFKA,IACDA,EAASnB,EAAQgB,UACE,MAAnBE,EAAQiD,SAAmBjD,EAAQiD,QAAQxD,OAC3C,IAAK,IAAID,EAAI,EAAGA,EAAIQ,EAAQiD,QAAQxD,SAAUD,EAC1CN,EAAM0C,MAAM7B,OAAOC,EAAQiD,QAAQzD,GAAIS,EAAOG,OAA8B,IAAIgC,QAAQ7B,SAChG,GAAsB,MAAlBP,EAAQsD,QAAkBtD,EAAQsD,OAAO7D,OACzC,IAASD,EAAI,EAAGA,EAAIQ,EAAQsD,OAAO7D,SAAUD,EACzCN,EAAM4D,MAAM/C,OAAOC,EAAQsD,OAAO9D,GAAIS,EAAOG,OAA8B,IAAIgC,QAAQ7B,SAC/F,OAAON,GAYXoD,EAAiB/C,gBAAkB,SAAyBN,EAASC,GACjE,OAAOP,KAAKK,OAAOC,EAASC,GAAQM,UAcxC8C,EAAiB7C,OAAS,SAAgBC,EAAQhB,GACxCgB,aAAkB7B,IACpB6B,EAAS7B,EAAQkB,OAAOW,IAE5B,IADA,IAAIC,OAAiBC,IAAXlB,EAAuBgB,EAAOG,IAAMH,EAAOI,IAAMpB,EAAQO,EAAU,IAAId,EAAMmE,iBAChF5C,EAAOI,IAAMH,GAAK,CACrB,IAAII,EAAML,EAAOL,SACjB,OAAQU,IAAQ,GAChB,KAAK,EACKd,EAAQiD,SAAWjD,EAAQiD,QAAQxD,SACrCO,EAAQiD,QAAU,IACtBjD,EAAQiD,QAAQZ,KAAKnD,EAAM0C,MAAMpB,OAAOC,EAAQA,EAAOL,WACvD,MACJ,KAAK,EACKJ,EAAQsD,QAAUtD,EAAQsD,OAAO7D,SACnCO,EAAQsD,OAAS,IACrBtD,EAAQsD,OAAOjB,KAAKnD,EAAM4D,MAAMtC,OAAOC,EAAQA,EAAOL,WACtD,MACJ,QACIK,EAAOM,SAAe,EAAND,IAIxB,OAAOd,GAaXqD,EAAiBrC,gBAAkB,SAAyBP,GAGxD,OAFMA,aAAkB7B,IACpB6B,EAAS,IAAI7B,EAAQ6B,IAClBf,KAAKc,OAAOC,EAAQA,EAAOL,WAWtCiD,EAAiBpC,OAAS,SAAgBjB,GACtC,GAAuB,kBAAZA,GAAoC,OAAZA,EAC/B,MAAO,kBACX,GAAuB,MAAnBA,EAAQiD,SAAmBjD,EAAQE,eAAe,WAAY,CAC9D,IAAKsC,MAAMC,QAAQzC,EAAQiD,SACvB,MAAO,0BACX,IAAK,IAAIzD,EAAI,EAAGA,EAAIQ,EAAQiD,QAAQxD,SAAUD,EAE1C,GADI+C,EAAQrD,EAAM0C,MAAMX,OAAOjB,EAAQiD,QAAQzD,IAE3C,MAAO,WAAa+C,EAGhC,GAAsB,MAAlBvC,EAAQsD,QAAkBtD,EAAQE,eAAe,UAAW,CAC5D,IAAKsC,MAAMC,QAAQzC,EAAQsD,QACvB,MAAO,yBACX,IAAS9D,EAAI,EAAGA,EAAIQ,EAAQsD,OAAO7D,SAAUD,EAAG,CAC5C,IAAI+C,EACJ,GADIA,EAAQrD,EAAM4D,MAAM7B,OAAOjB,EAAQsD,OAAO9D,IAE1C,MAAO,UAAY+C,GAG/B,OAAO,MAWXc,EAAiBlC,WAAa,SAAoBC,GAC9C,GAAIA,aAAkBlC,EAAMmE,iBACxB,OAAOjC,EACX,IAAIpB,EAAU,IAAId,EAAMmE,iBACxB,GAAIjC,EAAO6B,QAAS,CAChB,IAAKT,MAAMC,QAAQrB,EAAO6B,SACtB,MAAMN,UAAU,6CACpB3C,EAAQiD,QAAU,GAClB,IAAK,IAAIzD,EAAI,EAAGA,EAAI4B,EAAO6B,QAAQxD,SAAUD,EAAG,CAC5C,GAAiC,kBAAtB4B,EAAO6B,QAAQzD,GACtB,MAAMmD,UAAU,8CACpB3C,EAAQiD,QAAQzD,GAAKN,EAAM0C,MAAMT,WAAWC,EAAO6B,QAAQzD,KAGnE,GAAI4B,EAAOkC,OAAQ,CACf,IAAKd,MAAMC,QAAQrB,EAAOkC,QACtB,MAAMX,UAAU,4CAEpB,IADA3C,EAAQsD,OAAS,GACR9D,EAAI,EAAGA,EAAI4B,EAAOkC,OAAO7D,SAAUD,EAAG,CAC3C,GAAgC,kBAArB4B,EAAOkC,OAAO9D,GACrB,MAAMmD,UAAU,6CACpB3C,EAAQsD,OAAO9D,GAAKN,EAAM4D,MAAM3B,WAAWC,EAAOkC,OAAO9D,KAGjE,OAAOQ,GAYXqD,EAAiBhC,SAAW,SAAkBrB,EAASsB,GAC9CA,IACDA,EAAU,IACd,IAAIF,EAAS,GAKb,IAJIE,EAAQsB,QAAUtB,EAAQC,YAC1BH,EAAO6B,QAAU,GACjB7B,EAAOkC,OAAS,IAEhBtD,EAAQiD,SAAWjD,EAAQiD,QAAQxD,OAAQ,CAC3C2B,EAAO6B,QAAU,GACjB,IAAK,IAAIJ,EAAI,EAAGA,EAAI7C,EAAQiD,QAAQxD,SAAUoD,EAC1CzB,EAAO6B,QAAQJ,GAAK3D,EAAM0C,MAAMP,SAASrB,EAAQiD,QAAQJ,GAAIvB,GAErE,GAAItB,EAAQsD,QAAUtD,EAAQsD,OAAO7D,OAEjC,IADA2B,EAAOkC,OAAS,GACPT,EAAI,EAAGA,EAAI7C,EAAQsD,OAAO7D,SAAUoD,EACzCzB,EAAOkC,OAAOT,GAAK3D,EAAM4D,MAAMzB,SAASrB,EAAQsD,OAAOT,GAAIvB,GAEnE,OAAOF,GAUXiC,EAAiB1D,UAAU6B,OAAS,WAChC,OAAO9B,KAAK+B,YAAYJ,SAAS3B,KAAMf,EAAUM,KAAKyC,gBAGnD2B,EAzPe,GA4PnBnE,IA10CG,gC,yMCEOqE,E,4JAEnB,WACE,OACI,eAACC,EAAA,EAAD,WACE,cAAC,IAAD,CAAMC,GAAI,IAAV,SACE,cAACD,EAAA,EAAKE,KAAN,CAAWC,QAAM,EAAjB,wBAEF,cAAC,IAAD,CAAMF,GAAI,QAAV,SACE,cAACD,EAAA,EAAKE,KAAN,UACE,cAACE,EAAA,EAAD,CAAM7B,KAAK,oB,GAVmB8B,a,iBCKvBC,E,gKACnB,WACE,MAAO,UAAYpE,KAAKqE,MAAMC,MAAMlC,K,oBAGtC,WACE,OACE,cAAC,IAAD,CAAM2B,GAAI/D,KAAKuE,aAAf,SACE,eAACC,EAAA,EAAD,CAAMC,MAAO,CAACC,OAAQ,OAAtB,UACE,cAACF,EAAA,EAAKG,QAAN,CAAcV,OAAQjE,KAAKqE,MAAMC,MAAMjC,OACvC,cAACmC,EAAA,EAAKG,QAAN,UAEG3E,KAAKqE,MAAMC,MAAMhC,YAAYsC,MAAM,MAAMC,KAAI,SAACC,EAAMC,GACnD,OAAQ,4BAAcD,GAANC,iB,GAbSZ,a,oDCRjCa,EAAiB,YAEvB,SAASC,EAAS7C,GAChB,MAAM,SAAN,OAAgBA,GAGX,SAAS8C,IACd,OAAOC,IAAeN,KAAI,SAACzC,GACzB,OAaJ,SAAmBA,GACjB,IAAIgD,EAAcC,aAAaC,QAAQL,EAAS7C,IAChD,IAAKgD,EACH,MAAMG,MAAM,wBAAD,OAAyBnD,EAAzB,wBAGb,OAAOF,QAAM9B,OAAOoF,KAAKC,MAAML,IAnBtBM,CAAUtD,MAIrB,SAAS+C,IACP,IAAIQ,EAAgBN,aAAaC,QAAQN,IAAmB,KAC5D,OAAOQ,KAAKC,MAAME,GAGpB,SAASC,EAAcC,GACrBR,aAAaS,QAAQd,EAAgBQ,KAAKO,UAAUF,IAY/C,SAASG,EAAW1B,GACzBe,aAAaS,QAAQb,EAASX,EAAMlC,IAAeoD,KAAKO,UAAUzB,IAG7D,SAAS2B,EAAkB3B,GAChC0B,EAAW1B,GAEX,IAAM4B,EAAcf,IACpBe,EAAYvD,KAAK2B,EAAMlC,IACvBwD,EAAcM,GCvBhB,IAAMC,EDoCC,WACL,IAAMA,EAAe,CACnBC,SAAU,IAMZ,OAJAlB,IAA4BmB,SAAQ,SAAC/B,GACnC6B,EAAaC,SAAS9B,EAAMlC,IAAMkC,EAAMxC,YAGnCqE,EC5CYG,GAEfC,EAAe,YAEfC,EAAiBC,YAAY,CACjCpE,KAAMkE,EACNJ,eACAO,SAAU,CACRC,YADQ,SACIC,EAAOC,GACjBD,EAAMR,SAASS,EAAOC,QAAQ1E,IAAgByE,EAAOC,SAEvDC,YAJQ,SAIIH,EAAOC,GACjBD,EAAMR,SAASS,EAAOC,QAAQ1E,IAAgByE,EAAOC,SAEvDE,YAPQ,SAOIJ,EAAOC,UACVD,EAAMR,SAASS,EAAOC,aAKtBG,EACP,SAAAC,GAAQ,OAAI,SAAAC,GAAI,OAAI,SAAAN,GACxB,IAAIO,EAASD,EAAKN,GAMlB,OAJIA,EAAOQ,KAAKC,WAAWf,eACzBgB,EAA2BV,GAGtBO,KAGIG,EAA6B,SAACV,GACzC,OAAQA,EAAOQ,MACb,IAAI,GAAJ,OAAQd,EAAR,gBACEN,EAAkBY,EAAOC,SACzB,MACF,IAAI,GAAJ,OAAQP,EAAR,gBACEP,EAAWa,EAAOC,SAClB,MACF,IAAI,GAAJ,OAAQP,EAAR,gBDbkCiB,ECcVX,EAAOC,QDXjClB,EAFkBT,IAEQsC,QAAO,SAACrF,GAChC,OAAOA,IAAOoF,MAGhBnC,aAAaqC,WAAWzC,EAASuC,IAP5B,IAA+BA,GCoBzBG,EAAiB,SAACf,GAG7B,IAFA,IAAMgB,EAA6B,GAEnC,MAA2B/H,OAAOgI,QAAQjB,EAAMkB,UAAU1B,UAA1D,eAAqE,CAAhE,0BAAO2B,EAAP,KAAYC,EAAZ,KACHJ,EAAiBG,GAAO7F,QAAMT,WAAWuG,GAG3C,OAAOJ,GAcF,EAAkDpB,EAAeyB,QAAzDtB,EAAR,EAAQA,YAAaI,EAArB,EAAqBA,YAAaC,EAAlC,EAAkCA,YAC1BR,IAAf,Q,QCnFa0B,EAAiB,kBAAMC,eACvBC,EAAkDC,I,SCFzDC,EAAiB,YAEvB,SAASC,EAASnG,GAChB,MAAM,SAAN,OAAgBA,GAGX,SAASoG,IACd,OAAOC,IAAe5D,KAAI,SAACzC,GACzB,OAaJ,SAAmBA,GACjB,IAAIsG,EAAcrD,aAAaC,QAAQiD,EAASnG,IAChD,IAAKsG,EACH,MAAMnD,MAAM,wBAAD,OAAyBnD,EAAzB,wBAGb,OAAOgB,QAAMhD,OAAOoF,KAAKC,MAAMiD,IAnBtBC,CAAUvG,MAIrB,SAASqG,IACP,IAAI9C,EAAgBN,aAAaC,QAAQgD,IAAmB,KAC5D,OAAO9C,KAAKC,MAAME,GAGpB,SAASiD,EAAcC,GACrBxD,aAAaS,QAAQwC,EAAgB9C,KAAKO,UAAU8C,IAY/C,SAASC,EAAWC,GACzB1D,aAAaS,QAAQyC,EAASQ,EAAM3G,IAAeoD,KAAKO,UAAUgD,IAG7D,SAASC,EAAkBD,GAChCD,EAAWC,GAEX,IAAME,EAAcR,IACpBQ,EAAYtG,KAAKoG,EAAM3G,IACvBwG,EAAcK,GCvBhB,IAAM9C,GDqCC,WACL,IAAMA,EAAe,CACnB+C,SAAU,IAMZ,OAJAV,IAA2BnC,SAAQ,SAAC0C,GAClC5C,EAAa+C,SAASH,EAAM3G,IAAM2G,EAAMjH,YAGnCqE,EC7CYG,GAEfC,GAAe,YAEf4C,GAAiB1C,YAAY,CACjCpE,KAAMkE,GACNJ,gBACAO,SAAU,CACR0C,YADQ,SACIxC,EAAOC,GACjBD,EAAMsC,SAASrC,EAAOC,QAAQ1E,IAAgByE,EAAOC,SAEvDuC,YAJQ,SAIIzC,EAAOC,GACjBD,EAAMsC,SAASrC,EAAOC,QAAQ1E,IAAgByE,EAAOC,SAEvDwC,YAPQ,SAOI1C,EAAOC,UACVD,EAAMsC,SAASrC,EAAOC,aAKtByC,GACP,SAAArC,GAAQ,OAAI,SAAAC,GAAI,OAAI,SAAAN,GACxB,IAAIO,EAASD,EAAKN,GAMlB,OAJIA,EAAOQ,KAAKC,WAAWf,eACzBiD,GAA2B3C,GAGtBO,KAGIoC,GAA6B,SAAC3C,GACzC,OAAQA,EAAOQ,MACb,IAAI,GAAJ,OAAQd,GAAR,gBACEyC,EAAkBnC,EAAOC,SACzB,MACF,IAAI,GAAJ,OAAQP,GAAR,gBACEuC,EAAWjC,EAAOC,SAClB,MACF,IAAI,GAAJ,OAAQP,GAAR,gBDZkCiB,ECaVX,EAAOC,QDVjC8B,EAFkBH,IAEQhB,QAAO,SAACrF,GAChC,OAAOA,IAAOoF,MAGhBnC,aAAaqC,WAAWa,EAASf,IAP5B,IAA+BA,GCmBzBiC,GAAiB,SAAC7C,GAG7B,IAFA,IAAM8C,EAA6B,GAEnC,MAA2B7J,OAAOgI,QAAQjB,EAAM+C,UAAUT,UAA1D,eAAqE,CAAhE,0BAAOnB,EAAP,KAAYC,EAAZ,KACH0B,EAAiB3B,GAAO3E,QAAM3B,WAAWuG,GAG3C,OAAO0B,GAcF,GAAkDP,GAAelB,QAAzDmB,GAAR,GAAQA,YAAaC,GAArB,GAAqBA,YACbF,IADR,GAAkCG,YAC1BH,GAAf,SC3DA,SAASS,GAAgBxD,GACvB,IAAM0B,EAAYjI,OAAOgK,OAAOzD,GAEhC,OAAK0B,EAAU/H,OAMR,cAAC+J,EAAA,EAAD,CAASrF,MAAO,CAACsF,QAAS,OAAQC,SAAU,QAA5C,SACJlC,EAAUjD,KAAI,SAACP,EAAOS,GACrB,OACI,cAAC,EAAD,CAAqBT,MAAOA,GAAZS,QAPlB,cAAC+E,EAAA,EAAD,qCAaO,SAASG,KACtB,IAAM7D,EAAWgC,EAAeT,GAC1BuC,EAAWhC,IACXiC,EAAUC,cAEhB,OACI,qBAAK3F,MAAO,CAACC,OAAQ,QAArB,SACE,eAACoF,EAAA,EAAQO,MAAT,WACE,eAACP,EAAA,EAAD,CAASrF,MAAO,CAACsF,QAAS,QAA1B,UACE,eAACO,EAAA,EAAD,CAAQC,KAAK,SAAb,uBACE,cAACD,EAAA,EAAOE,UAAR,kCAIF,qBAAK/F,MAAO,CAACgG,KAAM,EAAGC,UAAW,SAAjC,SACE,cAACC,EAAA,EAAD,CAAQC,MAAI,EAACC,MAAM,QACjBC,QAAS,WACP,IAAMC,EArDf7I,QAAM9B,OAAO,CAClBgC,GAAI4I,cACJ3I,KAAM,YACNC,YAAa,4BACZR,SAkDaoI,EAASvD,EAAYoE,IACrB,IAhDME,EAgDAC,GAhDAD,EAgD0BF,EAAS3I,GA/ClDgB,QAAMhD,OAAO,CAClBgC,GAAI4I,cACJvH,SAAU,gBACVC,MAAO,yLAGPH,QAAS,CAAC0H,KACTnJ,UAyCaoI,EAASd,GAAY8B,IAErBf,EAAQxH,KAAR,iBAAuBoI,EAAS3I,MAPpC,SAUE,cAAC8B,EAAA,EAAD,CAAM7B,KAAK,eAIhBuH,GAAgBxD,Q,qDCpDN+E,G,4MACnBvE,MAA2B,CACzBwE,oBAAqB,KACrBC,mBAAoB,OACpBC,eAAgB,I,kDAGlB,SAAaC,GACX,IAAMjH,EAAQtE,KAAKqE,MAAMC,MAEzBA,EAAMjC,KAAOkJ,EACbvL,KAAKqE,MAAMmH,cAAclH,K,iCAG3B,SAAoBmH,GAClB,IAAMnH,EAAQtE,KAAKqE,MAAMC,MAEzBA,EAAMhC,YAAcmJ,EACpBzL,KAAKqE,MAAMmH,cAAclH,K,+BAG3B,WAA6B,IAAD,IACtBoH,GAAe,UAAA1L,KAAKqE,MAAMC,aAAX,mBAAkB/B,gBAAlB,eAA4BrC,UAAW,EAEtDyL,EAAc,GAEZC,EAAQC,KAAKC,MAAMJ,EAAc,MACvCA,GAAe,KAAOE,EACtBD,GAAeC,EAAMG,WAAWC,SAAS,EAAG,KAAO,IAEnD,IAAMC,EAAUJ,KAAKC,MAAMJ,EAAc,IAMzC,OALAA,GAAe,GAAKO,EACpBN,GAAeM,EAAQF,WAAWC,SAAS,EAAG,KAAO,IAErDL,GAAeD,EAAYK,WAAWC,SAAS,EAAG,O,8BAKpD,SAAiBE,GAEf,IADsB,IAAIC,OAAO,aACdC,KAAKF,GACtB,OAAOlM,KAAKqM,wBAAuB,GAGrC,IAAMC,EAAmBJ,EAAYtH,MAAM,KAAK6C,OAAO8E,SAEvD,GAAID,EAAiBvM,OAAS,EAC5B,OAAOC,KAAKqM,wBAAuB,GAIrC,IADA,IAAIX,EAAc,EACT5L,EAAI,EAAGA,EAAIwM,EAAiBvM,OAAQD,IAC3C4L,EAAe,GAAKA,EAAec,SAASF,EAAiBxM,GAAI,IAGnE,IAAMwE,EAAQtE,KAAKqE,MAAMC,MACzBA,EAAM/B,SAAWN,WAAS7B,OAAO,CAC/BF,QAASwL,IAGX1L,KAAKqE,MAAMmH,cAAclH,GACzBtE,KAAKqM,wBAAuB,K,oCAG9B,SAAuBI,GACrBzM,KAAK0M,UAAS,SAAC9F,GAAD,oBAAC,gBACVA,GADS,IAEZwE,oBAAqBqB,EAAW,6CAA+C,Y,+BAInF,SAAkBhF,GAAiB,IAAD,OAChC,OAAOzH,KAAKqE,MAAMT,OAAO6D,QAAO,SAACsB,GAAW,IAAD,IACzC,QAAe,SAAXtB,GAAqBsB,EAAMxF,QAAQoJ,SAAQ,YAAKtI,MAAMC,aAAX,eAAkBlC,KAAM,IAAM,MAI9D,WAAXqF,GAAuBsB,EAAMxF,QAAQoJ,SAAQ,YAAKtI,MAAMC,aAAX,eAAkBlC,KAAM,KAAO,Q,4BAQpF,WAAyB,IAAD,IACtB,OAAOgB,QAAMhD,OAAO,CAClBgC,GAAI4I,cACJvH,SAAU,YACVC,MAAO,6BAAoB1D,KAAKqE,MAAMC,aAA/B,aAAoB,EAAkBjC,MAAO,qDACpDkB,QAAS,WAACvD,KAAKqE,MAAMC,aAAZ,aAAC,EAAkBlC,Q,gCAIhC,WAAiC,IAAD,EAW1BwK,EAX0B,OAC1BC,EAAe7M,KAAKqE,MAAMT,OAAOkJ,MAAK,SAAC/D,GACzC,OAAOA,EAAM3G,KAAO,EAAKwE,MAAM0E,kBAGjC,OAAKuB,GASHD,EAFEC,EAAatJ,QAAQoJ,SAAQ,UAAA3M,KAAKqE,MAAMC,aAAX,eAAkBlC,KAAM,KAAO,EAGzD,cAACuI,EAAA,EAAD,CAAQC,MAAI,EAACC,MAAM,MACXC,QAAS,WACP,IAAMiC,EAAeF,EACrBE,EAAaxJ,QAAUwJ,EAAaxJ,QAAQkE,QAAO,SAACuF,GAAa,IAAD,EAC9D,OAAOA,KAAO,UAAK,EAAK3I,MAAMC,aAAhB,aAAK,EAAkBlC,OAGvC,EAAKiC,MAAM4I,cAAcF,IAPnC,SASH,cAAC7I,EAAA,EAAD,CAAM7B,KAAK,aAIT,cAACsI,EAAA,EAAD,CAAQC,MAAI,EAACC,MAAM,QACXC,QAAS,WAAO,IAAD,EACPiC,EAAeF,EACrBE,EAAaxJ,QAAQZ,MAAK,YAAK0B,MAAMC,aAAX,eAAkBlC,KAAM,IAClD,EAAKiC,MAAM4I,cAAcF,IAJnC,SAME,cAAC7I,EAAA,EAAD,CAAM7B,KAAK,cAMf,gCACE,sBAAKoC,MAAO,CAACsF,QAAS,QAAtB,UACE,cAACO,EAAA,EAAD,UACGuC,EAAapJ,WAEhB,qBAAKgB,MAAO,CAACgG,KAAM,EAAGC,UAAW,SAAjC,SACGkC,OAGL,cAACM,GAAA,EAAD,CAAWC,MAAI,EAAf,SACGN,EAAanJ,MAAMkB,MAAM,MAAMC,KAAI,SAACC,EAAMC,GACzC,OAAQ,4BAAuBD,GAAf,QAASC,QAG7B,qBAAKN,MAAO,CAAC2I,UAAW,QAAxB,SACE,cAAC,IAAD,CAAMrJ,GAAE,iBAAY8I,EAAazK,IAAjC,SACE,cAACuI,EAAA,EAAD,CAAQ0C,SAAO,EAAf,mCAjDJ,cAAC/C,EAAA,EAAD,sC,oBAyDR,WAAU,IAAD,OACP,OAAKtK,KAAKqE,MAAMC,MAOZ,sBAAKG,MAAO,CAACC,OAAQ,QAArB,UACE,eAACoF,EAAA,EAAQO,MAAT,WACE,eAACP,EAAA,EAAD,CAASrF,MAAO,CAACsF,QAAS,QAA1B,UACE,eAACO,EAAA,EAAD,2BAEE,cAACA,EAAA,EAAOE,UAAR,2DAKF,qBAAK/F,MAAO,CAACgG,KAAM,EAAGC,UAAW,SAAjC,SACE,cAACC,EAAA,EAAD,CAAQC,MAAI,EAACC,MAAM,MACXC,QAAS,kBAAM,EAAKzG,MAAMiJ,iBADlC,SAGE,cAACpJ,EAAA,EAAD,CAAM7B,KAAK,kBAIjB,cAACyH,EAAA,EAAD,UACE,eAACyD,GAAA,EAAD,WACE,eAACA,GAAA,EAAKlD,MAAN,CAAYmD,OAAO,QAAnB,UACE,cAACD,GAAA,EAAKE,MAAN,CACIC,MAAM,aACNC,aAAc3N,KAAKqE,MAAMC,MAAMjC,KAC/BuL,SAAU,SAACC,GAAD,OAAO,EAAKC,aAAaD,EAAEE,OAAO/F,UAEhD,cAACuF,GAAA,EAAKE,MAAN,CACIC,MAAM,+BACNC,aAAc3N,KAAKgO,oBACnBnL,MAAO7C,KAAK4G,MAAMwE,oBAClBwC,SAAU,SAACC,GAAD,OAAO,EAAKI,iBAAiBJ,EAAEE,OAAO/F,aAGtD,eAACuF,GAAA,EAAKW,MAAN,WACE,sDACA,cAACC,GAAA,EAAD,CACIR,aAAc3N,KAAKqE,MAAMC,MAAMhC,YAC/BsL,SAAU,SAACC,GAAD,OAAO,EAAKO,oBAAoBP,EAAEE,OAAO/F,QACnDvD,MAAO,CAAC4J,WAAY,eAAgBC,OAAQ,sBAMxD,eAACxE,EAAA,EAAQO,MAAT,WACE,eAACP,EAAA,EAAD,CAASrF,MAAO,CAACsF,QAAS,QAA1B,UACE,eAACO,EAAA,EAAD,oBAEE,cAACA,EAAA,EAAOE,UAAR,sEAKF,qBAAK/F,MAAO,CAACgG,KAAM,EAAGC,UAAW,SAAjC,SACE,cAACC,EAAA,EAAD,CAAQC,MAAI,EAACC,MAAM,QACXC,QAAS,WACP,EAAKzG,MAAMkK,cAAc,EAAKC,mBAFxC,SAKE,cAACtK,EAAA,EAAD,CAAM7B,KAAK,eAIjB,eAACyH,EAAA,EAAD,CAASrF,MAAO,CAACsF,QAAS,QAA1B,UACE,eAACjG,EAAA,EAAD,CAAM2K,UAAQ,EAACC,UAAQ,EAAvB,UAEI,cAAC5K,EAAA,EAAKE,KAAN,UACE,cAAC2K,GAAA,EAAD,CACIC,OAAK,EACLC,WAAS,EACTjB,SAAU,SAACC,EAAD,GAAmB,IAAb7F,EAAY,EAAZA,MACd,EAAK0E,SAAL,6BACK,EAAK9F,OADV,IAEEyE,mBAAoBrD,MAGxB2F,aAAc3N,KAAK4G,MAAMyE,mBACzBzJ,QAAS,CACP,CACEoG,MAAO,MACPmF,KAAM,cACN7K,YAAa,GAAMtC,KAAK8O,kBAAkB,OAAO/O,QAEnD,CACEiI,MAAO,OACPmF,KAAM,aACN7K,YAAa,GAAMtC,KAAK8O,kBAAkB,QAAQ/O,QAEpD,CACEiI,MAAO,SACPmF,KAAM,gBACN7K,YAAa,GAAMtC,KAAK8O,kBAAkB,UAAU/O,aAK/DC,KAAK8O,kBAAkB9O,KAAK4G,MAAMyE,oBAAoBxG,KAAI,SAACkE,EAAOhE,GACjE,OAAQ,cAACjB,EAAA,EAAKE,KAAN,CAEJ3B,KAAM0G,EAAM3G,GACZ2M,OAAQhG,EAAM3G,KAAO,EAAKwE,MAAM0E,eAChCR,QAAS,kBAAM,EAAK4B,SAAL,6BAAkB,EAAK9F,OAAvB,IAA8B0E,eAAgBvC,EAAM3G,OAJ/D,SAKN2G,EAAMtF,UAJC,cAAgBsB,MAKxB0C,OAAO8E,YAEZ,qBAAK9H,MAAO,CAACgG,KAAM,EAAGuE,WAAY,QAAlC,SACGhP,KAAKiP,gCA/GZ,mE,GAlKgC9K,aCT3B,SAAS+K,GAAkB7K,GAA2B,IAAD,EN8DhCjC,EM7D5BkC,EAAQ8D,GN6DoBhG,EM7Dc,UAACiC,EAAM8K,MAAMC,cAAb,aAAC,EAAoBhN,GN6DpB,SAACwE,GAClD,IAAMyI,EAAezI,EAAMkB,UAAU1B,SAAShE,GAE9C,OAAKiN,EAIEnN,QAAM9B,OAAOiP,GAHX,QMhEHC,EAA0BzP,OAAOgK,OAAOzB,EAAeqB,KACvDS,EAAWhC,IACXiC,EAAUC,cAEhB,OACE,cAAC,GAAD,CACE9F,MAAOA,EACPV,OAAQ0L,EACR9D,cAAe,SAAClH,GAAD,OAAW4F,EAASnD,EAAYzC,EAAMxC,YACrDwL,cAAe,WACbpD,EAASlD,EAAa1C,EAAgBlC,KACtC+H,EAAQxH,KAAK,MAEf4L,cAAe,SAACxF,GACdmB,EAASd,GAAYL,EAAMjH,WAC3BqI,EAAQxH,KAAK,UAAYoG,EAAM3G,KAEjC6K,cAAe,SAAClE,GACdmB,EAASb,GAAYN,EAAMjH,c,wDCpBnC,SAASyN,KACP,IAAMC,EAAW,qBAAuBC,KAAKC,MAAQ,SAErDC,KAeK,WACL,IAAMC,EAAYjM,mBAAiBvD,OAAO,CACxCmD,QAAS2B,IACTtB,OAAQ4E,MAGV,OAAO7E,mBAAiBtD,OAAOuP,GAAWC,SArB7BC,GAAuBN,G,gDAGtC,WAA+BO,GAA/B,gBAAAC,EAAA,yDACOD,EADP,iEAKyBA,EAAM,GAAGE,cALlC,OAKQC,EALR,OAOEC,GADmB,IAAIC,WAAWF,IAGlCG,OAAOC,SAASC,SATlB,4C,sBAqBO,SAASJ,GAAkBK,GAChC,IAAMZ,EAAYjM,mBAAiB7C,OAAO0P,GAE1CnL,aAAaoL,QAEbb,EAAUrM,QAAQ8C,SAAQ,SAAC/B,GACzB2B,EAAkB3B,MAGpBsL,EAAUhM,OAAOyC,SAAQ,SAAC0C,GACxBC,EAAkBD,MAKP,SAAS2H,KACtB,IAAMtK,EAAWgC,EAAeT,GAEhC,OACI,qBAAKlD,MAAO,CAACC,OAAQ,QAArB,SACE,eAACoF,EAAA,EAAQO,MAAT,WACE,cAACP,EAAA,EAAD,CAASrF,MAAO,CAACsF,QAAS,QAA1B,SACE,eAACO,EAAA,EAAD,CAAQC,KAAK,SAAb,4BACE,cAACD,EAAA,EAAOE,UAAR,uDAKJ,eAACV,EAAA,EAAD,WACGjK,OAAOD,KAAKwG,GAAUrG,OADzB,cAGA,eAAC+J,EAAA,EAAD,WACE,cAACa,EAAA,EAAD,CAAQE,MAAM,QACNC,QAAS,WAAOyE,MADxB,gCAIA,cAAC5E,EAAA,EAAD,CAAQE,MAAM,MACNC,QAAS,WApE3BzF,aAAaoL,QACbJ,OAAOC,SAASC,UAkEN,gCAKF,eAACzG,EAAA,EAAD,WACE,cAACQ,EAAA,EAAD,CAAQC,KAAK,QAAb,8BACA,uBAAOlD,KAAK,OAAOsJ,OAAO,SAAS/C,SAAU,SAACgD,GAAD,O,4CAAWC,CAAgBD,EAAM7C,OAAOgC,kBC3ElF,SAASe,GAAkBzM,GAExC,OACI,kEAAqCA,EAAM8K,MAAMC,OAAOhN,MCgB/C2O,OAdf,WACE,OACE,eAAC,IAAD,WACE,cAAC,EAAD,IACA,eAAC,IAAD,WACE,cAAC,IAAD,CAAOC,KAAK,QAAQC,UAAWP,KAC/B,cAAC,IAAD,CAAOM,KAAK,aAAaC,UAAW/B,KACpC,cAAC,IAAD,CAAO8B,KAAK,aAAaC,UAAWH,KACpC,cAAC,IAAD,CAAOE,KAAK,IAAIC,UAAWhH,YClBtBiH,GAAQC,YAAe,CAClCC,QAAS,CACPtJ,UAAWuJ,EACX1H,UAAW2H,IAEbC,WAAY,SAACC,GAAD,OAA0BA,IAAuBC,OAAO,CAClExK,EACAsC,QCCgBgD,QACW,cAA7B8D,OAAOC,SAASoB,UAEe,UAA7BrB,OAAOC,SAASoB,UAEhBrB,OAAOC,SAASoB,SAASvC,MACvB,2D,OCTNwC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,IAAD,CAAUX,MAAOA,GAAjB,SACE,cAAC,GAAD,QAGJY,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAACC,GACLA,EAAaC,gBAEdC,OAAM,SAACzP,GACN0P,QAAQ1P,MAAMA,EAAMvC,c","file":"static/js/main.fd7169ef.chunk.js","sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n(function(global, factory) { /* global define, require, module */\n\n    /* AMD */ if (typeof define === 'function' && define.amd)\n        define([\"protobufjs/minimal\"], factory);\n\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)\n        module.exports = factory(require(\"protobufjs/minimal\"));\n\n})(this, function($protobuf) {\n    \"use strict\";\n\n    // Common aliases\n    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n    \n    // Exported root namespace\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    \n    $root.Timestamp = (function() {\n    \n        /**\n         * Properties of a Timestamp.\n         * @exports ITimestamp\n         * @interface ITimestamp\n         * @property {number|null} [seconds] Timestamp seconds\n         * @property {number|null} [nanos] Timestamp nanos\n         */\n    \n        /**\n         * Constructs a new Timestamp.\n         * @exports Timestamp\n         * @classdesc Represents a Timestamp.\n         * @implements ITimestamp\n         * @constructor\n         * @param {ITimestamp=} [properties] Properties to set\n         */\n        function Timestamp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Timestamp seconds.\n         * @member {number} seconds\n         * @memberof Timestamp\n         * @instance\n         */\n        Timestamp.prototype.seconds = 0;\n    \n        /**\n         * Timestamp nanos.\n         * @member {number} nanos\n         * @memberof Timestamp\n         * @instance\n         */\n        Timestamp.prototype.nanos = 0;\n    \n        /**\n         * Creates a new Timestamp instance using the specified properties.\n         * @function create\n         * @memberof Timestamp\n         * @static\n         * @param {ITimestamp=} [properties] Properties to set\n         * @returns {Timestamp} Timestamp instance\n         */\n        Timestamp.create = function create(properties) {\n            return new Timestamp(properties);\n        };\n    \n        /**\n         * Encodes the specified Timestamp message. Does not implicitly {@link Timestamp.verify|verify} messages.\n         * @function encode\n         * @memberof Timestamp\n         * @static\n         * @param {ITimestamp} message Timestamp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Timestamp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.seconds != null && Object.hasOwnProperty.call(message, \"seconds\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seconds);\n            if (message.nanos != null && Object.hasOwnProperty.call(message, \"nanos\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link Timestamp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Timestamp\n         * @static\n         * @param {ITimestamp} message Timestamp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Timestamp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Timestamp message from the specified reader or buffer.\n         * @function decode\n         * @memberof Timestamp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Timestamp} Timestamp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Timestamp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Timestamp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.seconds = reader.int32();\n                    break;\n                case 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Timestamp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Timestamp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Timestamp} Timestamp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Timestamp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Timestamp message.\n         * @function verify\n         * @memberof Timestamp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Timestamp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                if (!$util.isInteger(message.seconds))\n                    return \"seconds: integer expected\";\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                if (!$util.isInteger(message.nanos))\n                    return \"nanos: integer expected\";\n            return null;\n        };\n    \n        /**\n         * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Timestamp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Timestamp} Timestamp\n         */\n        Timestamp.fromObject = function fromObject(object) {\n            if (object instanceof $root.Timestamp)\n                return object;\n            var message = new $root.Timestamp();\n            if (object.seconds != null)\n                message.seconds = object.seconds | 0;\n            if (object.nanos != null)\n                message.nanos = object.nanos | 0;\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Timestamp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Timestamp\n         * @static\n         * @param {Timestamp} message Timestamp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Timestamp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.seconds = 0;\n                object.nanos = 0;\n            }\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                object.seconds = message.seconds;\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                object.nanos = message.nanos;\n            return object;\n        };\n    \n        /**\n         * Converts this Timestamp to JSON.\n         * @function toJSON\n         * @memberof Timestamp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Timestamp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return Timestamp;\n    })();\n    \n    $root.Duration = (function() {\n    \n        /**\n         * Properties of a Duration.\n         * @exports IDuration\n         * @interface IDuration\n         * @property {number|null} [seconds] Duration seconds\n         * @property {number|null} [nanos] Duration nanos\n         */\n    \n        /**\n         * Constructs a new Duration.\n         * @exports Duration\n         * @classdesc Represents a Duration.\n         * @implements IDuration\n         * @constructor\n         * @param {IDuration=} [properties] Properties to set\n         */\n        function Duration(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Duration seconds.\n         * @member {number} seconds\n         * @memberof Duration\n         * @instance\n         */\n        Duration.prototype.seconds = 0;\n    \n        /**\n         * Duration nanos.\n         * @member {number} nanos\n         * @memberof Duration\n         * @instance\n         */\n        Duration.prototype.nanos = 0;\n    \n        /**\n         * Creates a new Duration instance using the specified properties.\n         * @function create\n         * @memberof Duration\n         * @static\n         * @param {IDuration=} [properties] Properties to set\n         * @returns {Duration} Duration instance\n         */\n        Duration.create = function create(properties) {\n            return new Duration(properties);\n        };\n    \n        /**\n         * Encodes the specified Duration message. Does not implicitly {@link Duration.verify|verify} messages.\n         * @function encode\n         * @memberof Duration\n         * @static\n         * @param {IDuration} message Duration message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Duration.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.seconds != null && Object.hasOwnProperty.call(message, \"seconds\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seconds);\n            if (message.nanos != null && Object.hasOwnProperty.call(message, \"nanos\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Duration message, length delimited. Does not implicitly {@link Duration.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Duration\n         * @static\n         * @param {IDuration} message Duration message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Duration.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Duration message from the specified reader or buffer.\n         * @function decode\n         * @memberof Duration\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Duration} Duration\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Duration.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Duration();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.seconds = reader.int32();\n                    break;\n                case 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Duration message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Duration\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Duration} Duration\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Duration.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Duration message.\n         * @function verify\n         * @memberof Duration\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Duration.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                if (!$util.isInteger(message.seconds))\n                    return \"seconds: integer expected\";\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                if (!$util.isInteger(message.nanos))\n                    return \"nanos: integer expected\";\n            return null;\n        };\n    \n        /**\n         * Creates a Duration message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Duration\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Duration} Duration\n         */\n        Duration.fromObject = function fromObject(object) {\n            if (object instanceof $root.Duration)\n                return object;\n            var message = new $root.Duration();\n            if (object.seconds != null)\n                message.seconds = object.seconds | 0;\n            if (object.nanos != null)\n                message.nanos = object.nanos | 0;\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Duration message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Duration\n         * @static\n         * @param {Duration} message Duration\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Duration.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.seconds = 0;\n                object.nanos = 0;\n            }\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                object.seconds = message.seconds;\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                object.nanos = message.nanos;\n            return object;\n        };\n    \n        /**\n         * Converts this Duration to JSON.\n         * @function toJSON\n         * @memberof Duration\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Duration.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return Duration;\n    })();\n    \n    $root.Story = (function() {\n    \n        /**\n         * Properties of a Story.\n         * @exports IStory\n         * @interface IStory\n         * @property {string|null} [id] Story id\n         * @property {string|null} [name] Story name\n         * @property {string|null} [description] Story description\n         * @property {IDuration|null} [duration] Story duration\n         * @property {Array.<string>|null} [relatedStoryIds] Story relatedStoryIds\n         */\n    \n        /**\n         * Constructs a new Story.\n         * @exports Story\n         * @classdesc Represents a Story.\n         * @implements IStory\n         * @constructor\n         * @param {IStory=} [properties] Properties to set\n         */\n        function Story(properties) {\n            this.relatedStoryIds = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Story id.\n         * @member {string} id\n         * @memberof Story\n         * @instance\n         */\n        Story.prototype.id = \"\";\n    \n        /**\n         * Story name.\n         * @member {string} name\n         * @memberof Story\n         * @instance\n         */\n        Story.prototype.name = \"\";\n    \n        /**\n         * Story description.\n         * @member {string} description\n         * @memberof Story\n         * @instance\n         */\n        Story.prototype.description = \"\";\n    \n        /**\n         * Story duration.\n         * @member {IDuration|null|undefined} duration\n         * @memberof Story\n         * @instance\n         */\n        Story.prototype.duration = null;\n    \n        /**\n         * Story relatedStoryIds.\n         * @member {Array.<string>} relatedStoryIds\n         * @memberof Story\n         * @instance\n         */\n        Story.prototype.relatedStoryIds = $util.emptyArray;\n    \n        /**\n         * Creates a new Story instance using the specified properties.\n         * @function create\n         * @memberof Story\n         * @static\n         * @param {IStory=} [properties] Properties to set\n         * @returns {Story} Story instance\n         */\n        Story.create = function create(properties) {\n            return new Story(properties);\n        };\n    \n        /**\n         * Encodes the specified Story message. Does not implicitly {@link Story.verify|verify} messages.\n         * @function encode\n         * @memberof Story\n         * @static\n         * @param {IStory} message Story message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Story.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n            if (message.duration != null && Object.hasOwnProperty.call(message, \"duration\"))\n                $root.Duration.encode(message.duration, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.relatedStoryIds != null && message.relatedStoryIds.length)\n                for (var i = 0; i < message.relatedStoryIds.length; ++i)\n                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.relatedStoryIds[i]);\n            if (message.description != null && Object.hasOwnProperty.call(message, \"description\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Story message, length delimited. Does not implicitly {@link Story.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Story\n         * @static\n         * @param {IStory} message Story message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Story.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Story message from the specified reader or buffer.\n         * @function decode\n         * @memberof Story\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Story} Story\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Story.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Story();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                case 5:\n                    message.description = reader.string();\n                    break;\n                case 3:\n                    message.duration = $root.Duration.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.relatedStoryIds && message.relatedStoryIds.length))\n                        message.relatedStoryIds = [];\n                    message.relatedStoryIds.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Story message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Story\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Story} Story\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Story.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Story message.\n         * @function verify\n         * @memberof Story\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Story.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                if (!$util.isString(message.id))\n                    return \"id: string expected\";\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.description != null && message.hasOwnProperty(\"description\"))\n                if (!$util.isString(message.description))\n                    return \"description: string expected\";\n            if (message.duration != null && message.hasOwnProperty(\"duration\")) {\n                var error = $root.Duration.verify(message.duration);\n                if (error)\n                    return \"duration.\" + error;\n            }\n            if (message.relatedStoryIds != null && message.hasOwnProperty(\"relatedStoryIds\")) {\n                if (!Array.isArray(message.relatedStoryIds))\n                    return \"relatedStoryIds: array expected\";\n                for (var i = 0; i < message.relatedStoryIds.length; ++i)\n                    if (!$util.isString(message.relatedStoryIds[i]))\n                        return \"relatedStoryIds: string[] expected\";\n            }\n            return null;\n        };\n    \n        /**\n         * Creates a Story message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Story\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Story} Story\n         */\n        Story.fromObject = function fromObject(object) {\n            if (object instanceof $root.Story)\n                return object;\n            var message = new $root.Story();\n            if (object.id != null)\n                message.id = String(object.id);\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.description != null)\n                message.description = String(object.description);\n            if (object.duration != null) {\n                if (typeof object.duration !== \"object\")\n                    throw TypeError(\".Story.duration: object expected\");\n                message.duration = $root.Duration.fromObject(object.duration);\n            }\n            if (object.relatedStoryIds) {\n                if (!Array.isArray(object.relatedStoryIds))\n                    throw TypeError(\".Story.relatedStoryIds: array expected\");\n                message.relatedStoryIds = [];\n                for (var i = 0; i < object.relatedStoryIds.length; ++i)\n                    message.relatedStoryIds[i] = String(object.relatedStoryIds[i]);\n            }\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Story message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Story\n         * @static\n         * @param {Story} message Story\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Story.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.relatedStoryIds = [];\n            if (options.defaults) {\n                object.id = \"\";\n                object.name = \"\";\n                object.duration = null;\n                object.description = \"\";\n            }\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                object.id = message.id;\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.duration != null && message.hasOwnProperty(\"duration\"))\n                object.duration = $root.Duration.toObject(message.duration, options);\n            if (message.relatedStoryIds && message.relatedStoryIds.length) {\n                object.relatedStoryIds = [];\n                for (var j = 0; j < message.relatedStoryIds.length; ++j)\n                    object.relatedStoryIds[j] = message.relatedStoryIds[j];\n            }\n            if (message.description != null && message.hasOwnProperty(\"description\"))\n                object.description = message.description;\n            return object;\n        };\n    \n        /**\n         * Converts this Story to JSON.\n         * @function toJSON\n         * @memberof Story\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Story.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return Story;\n    })();\n    \n    $root.Scrap = (function() {\n    \n        /**\n         * Properties of a Scrap.\n         * @exports IScrap\n         * @interface IScrap\n         * @property {string|null} [id] Scrap id\n         * @property {number|null} [intendedDurationSec] Scrap intendedDurationSec\n         * @property {string|null} [synopsis] Scrap synopsis\n         * @property {string|null} [prose] Scrap prose\n         * @property {Array.<string>|null} [structure] Scrap structure\n         * @property {Array.<string>|null} [brainstorm] Scrap brainstorm\n         * @property {Array.<string>|null} [stories] Scrap stories\n         */\n    \n        /**\n         * Constructs a new Scrap.\n         * @exports Scrap\n         * @classdesc Represents a Scrap.\n         * @implements IScrap\n         * @constructor\n         * @param {IScrap=} [properties] Properties to set\n         */\n        function Scrap(properties) {\n            this.structure = [];\n            this.brainstorm = [];\n            this.stories = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Scrap id.\n         * @member {string} id\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.id = \"\";\n    \n        /**\n         * Scrap intendedDurationSec.\n         * @member {number} intendedDurationSec\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.intendedDurationSec = 0;\n    \n        /**\n         * Scrap synopsis.\n         * @member {string} synopsis\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.synopsis = \"\";\n    \n        /**\n         * Scrap prose.\n         * @member {string} prose\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.prose = \"\";\n    \n        /**\n         * Scrap structure.\n         * @member {Array.<string>} structure\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.structure = $util.emptyArray;\n    \n        /**\n         * Scrap brainstorm.\n         * @member {Array.<string>} brainstorm\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.brainstorm = $util.emptyArray;\n    \n        /**\n         * Scrap stories.\n         * @member {Array.<string>} stories\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.stories = $util.emptyArray;\n    \n        /**\n         * Creates a new Scrap instance using the specified properties.\n         * @function create\n         * @memberof Scrap\n         * @static\n         * @param {IScrap=} [properties] Properties to set\n         * @returns {Scrap} Scrap instance\n         */\n        Scrap.create = function create(properties) {\n            return new Scrap(properties);\n        };\n    \n        /**\n         * Encodes the specified Scrap message. Does not implicitly {@link Scrap.verify|verify} messages.\n         * @function encode\n         * @memberof Scrap\n         * @static\n         * @param {IScrap} message Scrap message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Scrap.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n            if (message.intendedDurationSec != null && Object.hasOwnProperty.call(message, \"intendedDurationSec\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.intendedDurationSec);\n            if (message.synopsis != null && Object.hasOwnProperty.call(message, \"synopsis\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.synopsis);\n            if (message.prose != null && Object.hasOwnProperty.call(message, \"prose\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.prose);\n            if (message.structure != null && message.structure.length)\n                for (var i = 0; i < message.structure.length; ++i)\n                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.structure[i]);\n            if (message.brainstorm != null && message.brainstorm.length)\n                for (var i = 0; i < message.brainstorm.length; ++i)\n                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.brainstorm[i]);\n            if (message.stories != null && message.stories.length)\n                for (var i = 0; i < message.stories.length; ++i)\n                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.stories[i]);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Scrap message, length delimited. Does not implicitly {@link Scrap.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Scrap\n         * @static\n         * @param {IScrap} message Scrap message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Scrap.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Scrap message from the specified reader or buffer.\n         * @function decode\n         * @memberof Scrap\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Scrap} Scrap\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Scrap.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Scrap();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.intendedDurationSec = reader.uint32();\n                    break;\n                case 3:\n                    message.synopsis = reader.string();\n                    break;\n                case 4:\n                    message.prose = reader.string();\n                    break;\n                case 5:\n                    if (!(message.structure && message.structure.length))\n                        message.structure = [];\n                    message.structure.push(reader.string());\n                    break;\n                case 7:\n                    if (!(message.brainstorm && message.brainstorm.length))\n                        message.brainstorm = [];\n                    message.brainstorm.push(reader.string());\n                    break;\n                case 8:\n                    if (!(message.stories && message.stories.length))\n                        message.stories = [];\n                    message.stories.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Scrap message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Scrap\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Scrap} Scrap\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Scrap.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Scrap message.\n         * @function verify\n         * @memberof Scrap\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Scrap.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                if (!$util.isString(message.id))\n                    return \"id: string expected\";\n            if (message.intendedDurationSec != null && message.hasOwnProperty(\"intendedDurationSec\"))\n                if (!$util.isInteger(message.intendedDurationSec))\n                    return \"intendedDurationSec: integer expected\";\n            if (message.synopsis != null && message.hasOwnProperty(\"synopsis\"))\n                if (!$util.isString(message.synopsis))\n                    return \"synopsis: string expected\";\n            if (message.prose != null && message.hasOwnProperty(\"prose\"))\n                if (!$util.isString(message.prose))\n                    return \"prose: string expected\";\n            if (message.structure != null && message.hasOwnProperty(\"structure\")) {\n                if (!Array.isArray(message.structure))\n                    return \"structure: array expected\";\n                for (var i = 0; i < message.structure.length; ++i)\n                    if (!$util.isString(message.structure[i]))\n                        return \"structure: string[] expected\";\n            }\n            if (message.brainstorm != null && message.hasOwnProperty(\"brainstorm\")) {\n                if (!Array.isArray(message.brainstorm))\n                    return \"brainstorm: array expected\";\n                for (var i = 0; i < message.brainstorm.length; ++i)\n                    if (!$util.isString(message.brainstorm[i]))\n                        return \"brainstorm: string[] expected\";\n            }\n            if (message.stories != null && message.hasOwnProperty(\"stories\")) {\n                if (!Array.isArray(message.stories))\n                    return \"stories: array expected\";\n                for (var i = 0; i < message.stories.length; ++i)\n                    if (!$util.isString(message.stories[i]))\n                        return \"stories: string[] expected\";\n            }\n            return null;\n        };\n    \n        /**\n         * Creates a Scrap message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Scrap\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Scrap} Scrap\n         */\n        Scrap.fromObject = function fromObject(object) {\n            if (object instanceof $root.Scrap)\n                return object;\n            var message = new $root.Scrap();\n            if (object.id != null)\n                message.id = String(object.id);\n            if (object.intendedDurationSec != null)\n                message.intendedDurationSec = object.intendedDurationSec >>> 0;\n            if (object.synopsis != null)\n                message.synopsis = String(object.synopsis);\n            if (object.prose != null)\n                message.prose = String(object.prose);\n            if (object.structure) {\n                if (!Array.isArray(object.structure))\n                    throw TypeError(\".Scrap.structure: array expected\");\n                message.structure = [];\n                for (var i = 0; i < object.structure.length; ++i)\n                    message.structure[i] = String(object.structure[i]);\n            }\n            if (object.brainstorm) {\n                if (!Array.isArray(object.brainstorm))\n                    throw TypeError(\".Scrap.brainstorm: array expected\");\n                message.brainstorm = [];\n                for (var i = 0; i < object.brainstorm.length; ++i)\n                    message.brainstorm[i] = String(object.brainstorm[i]);\n            }\n            if (object.stories) {\n                if (!Array.isArray(object.stories))\n                    throw TypeError(\".Scrap.stories: array expected\");\n                message.stories = [];\n                for (var i = 0; i < object.stories.length; ++i)\n                    message.stories[i] = String(object.stories[i]);\n            }\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Scrap message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Scrap\n         * @static\n         * @param {Scrap} message Scrap\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Scrap.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.structure = [];\n                object.brainstorm = [];\n                object.stories = [];\n            }\n            if (options.defaults) {\n                object.id = \"\";\n                object.intendedDurationSec = 0;\n                object.synopsis = \"\";\n                object.prose = \"\";\n            }\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                object.id = message.id;\n            if (message.intendedDurationSec != null && message.hasOwnProperty(\"intendedDurationSec\"))\n                object.intendedDurationSec = message.intendedDurationSec;\n            if (message.synopsis != null && message.hasOwnProperty(\"synopsis\"))\n                object.synopsis = message.synopsis;\n            if (message.prose != null && message.hasOwnProperty(\"prose\"))\n                object.prose = message.prose;\n            if (message.structure && message.structure.length) {\n                object.structure = [];\n                for (var j = 0; j < message.structure.length; ++j)\n                    object.structure[j] = message.structure[j];\n            }\n            if (message.brainstorm && message.brainstorm.length) {\n                object.brainstorm = [];\n                for (var j = 0; j < message.brainstorm.length; ++j)\n                    object.brainstorm[j] = message.brainstorm[j];\n            }\n            if (message.stories && message.stories.length) {\n                object.stories = [];\n                for (var j = 0; j < message.stories.length; ++j)\n                    object.stories[j] = message.stories[j];\n            }\n            return object;\n        };\n    \n        /**\n         * Converts this Scrap to JSON.\n         * @function toJSON\n         * @memberof Scrap\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Scrap.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return Scrap;\n    })();\n    \n    $root.WritingWorkspace = (function() {\n    \n        /**\n         * Properties of a WritingWorkspace.\n         * @exports IWritingWorkspace\n         * @interface IWritingWorkspace\n         * @property {Array.<IStory>|null} [stories] WritingWorkspace stories\n         * @property {Array.<IScrap>|null} [scraps] WritingWorkspace scraps\n         */\n    \n        /**\n         * Constructs a new WritingWorkspace.\n         * @exports WritingWorkspace\n         * @classdesc Represents a WritingWorkspace.\n         * @implements IWritingWorkspace\n         * @constructor\n         * @param {IWritingWorkspace=} [properties] Properties to set\n         */\n        function WritingWorkspace(properties) {\n            this.stories = [];\n            this.scraps = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * WritingWorkspace stories.\n         * @member {Array.<IStory>} stories\n         * @memberof WritingWorkspace\n         * @instance\n         */\n        WritingWorkspace.prototype.stories = $util.emptyArray;\n    \n        /**\n         * WritingWorkspace scraps.\n         * @member {Array.<IScrap>} scraps\n         * @memberof WritingWorkspace\n         * @instance\n         */\n        WritingWorkspace.prototype.scraps = $util.emptyArray;\n    \n        /**\n         * Creates a new WritingWorkspace instance using the specified properties.\n         * @function create\n         * @memberof WritingWorkspace\n         * @static\n         * @param {IWritingWorkspace=} [properties] Properties to set\n         * @returns {WritingWorkspace} WritingWorkspace instance\n         */\n        WritingWorkspace.create = function create(properties) {\n            return new WritingWorkspace(properties);\n        };\n    \n        /**\n         * Encodes the specified WritingWorkspace message. Does not implicitly {@link WritingWorkspace.verify|verify} messages.\n         * @function encode\n         * @memberof WritingWorkspace\n         * @static\n         * @param {IWritingWorkspace} message WritingWorkspace message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        WritingWorkspace.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.stories != null && message.stories.length)\n                for (var i = 0; i < message.stories.length; ++i)\n                    $root.Story.encode(message.stories[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.scraps != null && message.scraps.length)\n                for (var i = 0; i < message.scraps.length; ++i)\n                    $root.Scrap.encode(message.scraps[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified WritingWorkspace message, length delimited. Does not implicitly {@link WritingWorkspace.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof WritingWorkspace\n         * @static\n         * @param {IWritingWorkspace} message WritingWorkspace message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        WritingWorkspace.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a WritingWorkspace message from the specified reader or buffer.\n         * @function decode\n         * @memberof WritingWorkspace\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {WritingWorkspace} WritingWorkspace\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        WritingWorkspace.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WritingWorkspace();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.stories && message.stories.length))\n                        message.stories = [];\n                    message.stories.push($root.Story.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    if (!(message.scraps && message.scraps.length))\n                        message.scraps = [];\n                    message.scraps.push($root.Scrap.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a WritingWorkspace message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof WritingWorkspace\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {WritingWorkspace} WritingWorkspace\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        WritingWorkspace.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a WritingWorkspace message.\n         * @function verify\n         * @memberof WritingWorkspace\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        WritingWorkspace.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.stories != null && message.hasOwnProperty(\"stories\")) {\n                if (!Array.isArray(message.stories))\n                    return \"stories: array expected\";\n                for (var i = 0; i < message.stories.length; ++i) {\n                    var error = $root.Story.verify(message.stories[i]);\n                    if (error)\n                        return \"stories.\" + error;\n                }\n            }\n            if (message.scraps != null && message.hasOwnProperty(\"scraps\")) {\n                if (!Array.isArray(message.scraps))\n                    return \"scraps: array expected\";\n                for (var i = 0; i < message.scraps.length; ++i) {\n                    var error = $root.Scrap.verify(message.scraps[i]);\n                    if (error)\n                        return \"scraps.\" + error;\n                }\n            }\n            return null;\n        };\n    \n        /**\n         * Creates a WritingWorkspace message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof WritingWorkspace\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {WritingWorkspace} WritingWorkspace\n         */\n        WritingWorkspace.fromObject = function fromObject(object) {\n            if (object instanceof $root.WritingWorkspace)\n                return object;\n            var message = new $root.WritingWorkspace();\n            if (object.stories) {\n                if (!Array.isArray(object.stories))\n                    throw TypeError(\".WritingWorkspace.stories: array expected\");\n                message.stories = [];\n                for (var i = 0; i < object.stories.length; ++i) {\n                    if (typeof object.stories[i] !== \"object\")\n                        throw TypeError(\".WritingWorkspace.stories: object expected\");\n                    message.stories[i] = $root.Story.fromObject(object.stories[i]);\n                }\n            }\n            if (object.scraps) {\n                if (!Array.isArray(object.scraps))\n                    throw TypeError(\".WritingWorkspace.scraps: array expected\");\n                message.scraps = [];\n                for (var i = 0; i < object.scraps.length; ++i) {\n                    if (typeof object.scraps[i] !== \"object\")\n                        throw TypeError(\".WritingWorkspace.scraps: object expected\");\n                    message.scraps[i] = $root.Scrap.fromObject(object.scraps[i]);\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a WritingWorkspace message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof WritingWorkspace\n         * @static\n         * @param {WritingWorkspace} message WritingWorkspace\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        WritingWorkspace.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.stories = [];\n                object.scraps = [];\n            }\n            if (message.stories && message.stories.length) {\n                object.stories = [];\n                for (var j = 0; j < message.stories.length; ++j)\n                    object.stories[j] = $root.Story.toObject(message.stories[j], options);\n            }\n            if (message.scraps && message.scraps.length) {\n                object.scraps = [];\n                for (var j = 0; j < message.scraps.length; ++j)\n                    object.scraps[j] = $root.Scrap.toObject(message.scraps[j], options);\n            }\n            return object;\n        };\n    \n        /**\n         * Converts this WritingWorkspace to JSON.\n         * @function toJSON\n         * @memberof WritingWorkspace\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        WritingWorkspace.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return WritingWorkspace;\n    })();\n\n    return $root;\n});\n","import React, {Component} from 'react';\nimport {\n  Link\n} from 'react-router-dom';\nimport {Icon, Menu} from 'semantic-ui-react';\n\nexport default class RevisionHeader extends Component {\n\n  render() {\n    return (\n        <Menu>\n          <Link to={'/'}>\n            <Menu.Item header>Revision</Menu.Item>\n          </Link>\n          <Link to={'/data'}>\n            <Menu.Item>\n              <Icon name=\"save\" />\n            </Menu.Item>\n          </Link>\n        </Menu>\n    );\n  }\n}\n","import React, {Component} from 'react';\nimport {\n  Link\n} from 'react-router-dom';\nimport { Card } from 'semantic-ui-react';\nimport {Story} from '../../protos_v2';\n\ninterface StoryCardProps {\n  story: Story;\n}\n\nexport default class StoryCard extends Component<StoryCardProps> {\n  getCardUrl(): string {\n    return '/story/' + this.props.story.id;\n  }\n\n  render() {\n    return (\n      <Link to={this.getCardUrl()}>\n        <Card style={{margin: '8px'}}>\n          <Card.Content header={this.props.story.name} />\n          <Card.Content>\n            {/* For each line of the description, print it in a paragraph */}\n            {this.props.story.description.split('\\n').map((line, idx) => {\n              return (<p key={idx}>{line}</p>);\n            })}\n          </Card.Content>\n        </Card>\n      </Link>\n    );\n  }\n}\n","import {IStory, Story} from '../../protos_v2';\nimport {StoryMapInState} from './storyListSlice';\n\nconst allStoryIdsKey = 'story-ids';\n\nfunction storyKey(id: string): string {\n  return `story-${id}`;\n}\n\nexport function readAllStoriesFromStorage(): Story[] {\n  return readStoryIds().map((id) => {\n    return readStory(id);\n  });\n}\n\nfunction readStoryIds(): string[] {\n  let storyIdString = localStorage.getItem(allStoryIdsKey) || '[]';\n  return JSON.parse(storyIdString) as string[];\n}\n\nfunction writeStoryIds(storyIds: string[]): void {\n  localStorage.setItem(allStoryIdsKey, JSON.stringify(storyIds));\n}\n\nfunction readStory(id: string): Story {\n  let storyString = localStorage.getItem(storyKey(id));\n  if (!storyString) {\n    throw Error(`Unable to read story ${id} from local storage`);\n  }\n\n  return Story.create(JSON.parse(storyString));\n}\n\nexport function writeStory(story: IStory) {\n  localStorage.setItem(storyKey(story.id as string), JSON.stringify(story));\n}\n\nexport function addStoryToStorage(story: IStory): void {\n  writeStory(story);\n\n  const allStoryIds = readStoryIds();\n  allStoryIds.push(story.id as string);\n  writeStoryIds(allStoryIds);\n}\n\nexport function clearStoryFromStorage(idToRemove: string): void {\n  let allStoryIds = readStoryIds();\n\n  writeStoryIds(allStoryIds.filter((id) => {\n    return id !== idToRemove;\n  }));\n\n  localStorage.removeItem(storyKey(idToRemove));\n}\n\nexport function fetchInitialStateFromStorage() {\n  const initialState = {\n    storyMap: {} as StoryMapInState\n  };\n  readAllStoriesFromStorage().forEach((story) => {\n    initialState.storyMap[story.id] = story.toJSON();\n  });\n\n  return initialState;\n}\n\n","import {createSlice, Middleware, PayloadAction} from '@reduxjs/toolkit';\nimport {RootState} from '../../app/store';\nimport {IStory, Story} from '../../protos_v2';\nimport {addStoryToStorage, clearStoryFromStorage, fetchInitialStateFromStorage, writeStory} from './storyListPersistence';\n\nexport interface StoryMap {\n  [key: string]: Story;\n}\n\nexport interface StoryMapInState {\n  [key: string]: IStory\n}\n\ninterface storyListInState {\n  storyList: {\n    storyMap: StoryMapInState\n  }\n}\n\nconst initialState = fetchInitialStateFromStorage();\n\nconst actionPrefix = 'storyList';\n\nconst storyListSlice = createSlice({\n  name: actionPrefix,\n  initialState,\n  reducers: {\n    createStory(state, action: PayloadAction<IStory>) {\n      state.storyMap[action.payload.id as string] = action.payload;\n    },\n    updateStory(state, action: PayloadAction<IStory>) {\n      state.storyMap[action.payload.id as string] = action.payload;\n    },\n    removeStory(state, action: PayloadAction<string>) {\n      delete state.storyMap[action.payload];\n    }\n  }\n});\n\nexport const storyListPersistenceMiddleware: Middleware<{}, storyListInState>\n    = storeAPI => next => action => {\n  let result = next(action);\n\n  if (action.type.startsWith(actionPrefix + '/')) {\n    handleStoryListPersistence(action);\n  }\n\n  return result;\n}\n\nexport const handleStoryListPersistence = (action: PayloadAction<string|IStory>) => {\n  switch (action.type) {\n    case `${actionPrefix}/createStory`:\n      addStoryToStorage(action.payload as IStory);\n      break;\n    case `${actionPrefix}/updateStory`:\n      writeStory(action.payload as IStory);\n      break;\n    case `${actionPrefix}/removeStory`:\n      clearStoryFromStorage(action.payload as string);\n      break;\n  }\n}\n\n// Selector for fetching full map of stories\nexport const selectStoryMap = (state: storyListInState|RootState): StoryMap => {\n  const compiledStoryMap: StoryMap = {};\n\n  for (const [key, value] of Object.entries(state.storyList.storyMap)) {\n    compiledStoryMap[key] = Story.fromObject(value);\n  }\n\n  return compiledStoryMap;\n}\n\n// Creates selector for particular story\nexport const selectSpecificStory = (id: string) => (state: storyListInState|RootState): Story|null => {\n  const fetchedStory = state.storyList.storyMap[id];\n\n  if (!fetchedStory) {\n    return null;\n  }\n\n  return Story.create(fetchedStory);\n}\n\nexport const { createStory, updateStory, removeStory } = storyListSlice.actions;\nexport default storyListSlice.reducer;\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import {IScrap, Scrap} from '../../protos_v2';\nimport {ScrapMapInState} from './scrapListSlice';\n\nconst allScrapIdsKey = 'scrap-ids';\n\nfunction scrapKey(id: string): string {\n  return `scrap-${id}`;\n}\n\nexport function readAllScrapsFromStorage(): Scrap[] {\n  return readScrapIds().map((id) => {\n    return readScrap(id);\n  });\n}\n\nfunction readScrapIds(): string[] {\n  let storyIdString = localStorage.getItem(allScrapIdsKey) || '[]';\n  return JSON.parse(storyIdString) as string[];\n}\n\nfunction writeScrapIds(scrapIds: string[]): void {\n  localStorage.setItem(allScrapIdsKey, JSON.stringify(scrapIds));\n}\n\nfunction readScrap(id: string): Scrap {\n  let scrapString = localStorage.getItem(scrapKey(id));\n  if (!scrapString) {\n    throw Error(`Unable to read scrap ${id} from local storage`);\n  }\n\n  return Scrap.create(JSON.parse(scrapString));\n}\n\nexport function writeScrap(scrap: IScrap) {\n  localStorage.setItem(scrapKey(scrap.id as string), JSON.stringify(scrap));\n}\n\nexport function addScrapToStorage(scrap: IScrap): void {\n  writeScrap(scrap);\n\n  const allScrapIds = readScrapIds();\n  allScrapIds.push(scrap.id as string);\n  writeScrapIds(allScrapIds);\n}\n\n\nexport function clearScrapFromStorage(idToRemove: string): void {\n  let allScrapIds = readScrapIds();\n\n  writeScrapIds(allScrapIds.filter((id) => {\n    return id !== idToRemove;\n  }));\n\n  localStorage.removeItem(scrapKey(idToRemove));\n}\n\nexport function fetchInitialStateFromStorage() {\n  const initialState = {\n    scrapMap: {} as ScrapMapInState\n  };\n  readAllScrapsFromStorage().forEach((scrap) => {\n    initialState.scrapMap[scrap.id] = scrap.toJSON();\n  });\n\n  return initialState;\n}\n","import {createSlice, Middleware, PayloadAction} from '@reduxjs/toolkit';\nimport {RootState} from '../../app/store';\nimport {IScrap, Scrap} from '../../protos_v2';\nimport {addScrapToStorage, clearScrapFromStorage, fetchInitialStateFromStorage, writeScrap} from './scrapListPersistence';\n\nexport interface ScrapMap {\n  [key: string]: Scrap;\n}\n\nexport interface ScrapMapInState {\n  [key: string]: IScrap\n}\n\ninterface ScrapListInState {\n  scrapList: {\n    scrapMap: ScrapMapInState\n  }\n}\n\nconst initialState = fetchInitialStateFromStorage();\n\nconst actionPrefix = 'scrapList';\n\nconst ScrapListSlice = createSlice({\n  name: actionPrefix,\n  initialState,\n  reducers: {\n    createScrap(state, action: PayloadAction<IScrap>) {\n      state.scrapMap[action.payload.id as string] = action.payload;\n    },\n    updateScrap(state, action: PayloadAction<IScrap>) {\n      state.scrapMap[action.payload.id as string] = action.payload;\n    },\n    removeScrap(state, action: PayloadAction<string>) {\n      delete state.scrapMap[action.payload];\n    }\n  }\n});\n\nexport const scrapListPersistenceMiddleware: Middleware<{}, ScrapListInState>\n    = storeAPI => next => action => {\n  let result = next(action);\n\n  if (action.type.startsWith(actionPrefix + '/')) {\n    handleScrapListPersistence(action);\n  }\n\n  return result;\n}\n\nexport const handleScrapListPersistence = (action: PayloadAction<string|IScrap>) => {\n  switch (action.type) {\n    case `${actionPrefix}/createScrap`:\n      addScrapToStorage(action.payload as IScrap);\n      break;\n    case `${actionPrefix}/updateScrap`:\n      writeScrap(action.payload as IScrap);\n      break;\n    case `${actionPrefix}/removeScrap`:\n      clearScrapFromStorage(action.payload as string);\n      break;\n  }\n}\n\n// Selector for fetching full map of stories\nexport const selectScrapMap = (state: ScrapListInState|RootState): ScrapMap => {\n  const compiledScrapMap: ScrapMap = {};\n\n  for (const [key, value] of Object.entries(state.scrapList.scrapMap)) {\n    compiledScrapMap[key] = Scrap.fromObject(value);\n  }\n\n  return compiledScrapMap;\n}\n\n// Creates selector for particular Scrap\nexport const selectSpecificScrap = (id: string) => (state: ScrapListInState|RootState): Scrap|null => {\n  const fetchedScrap = state.scrapList.scrapMap[id];\n\n  if (!fetchedScrap) {\n    return null;\n  }\n\n  return Scrap.create(fetchedScrap);\n}\n\nexport const { createScrap, updateScrap, removeScrap } = ScrapListSlice.actions;\nexport default ScrapListSlice.reducer;\n","import StoryCard from '../../features/storyList/StoryCard';\nimport {Button, Header, Icon, Segment} from 'semantic-ui-react';\nimport { useHistory } from 'react-router-dom';\nimport {createStory, selectStoryMap, StoryMap} from '../../features/storyList/storyListSlice';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {IScrap, IStory, Scrap, Story} from '../../protos_v2';\nimport { v4 as uuid } from 'uuid';\nimport {createScrap} from '../../features/scrapList/scrapListSlice';\n\nfunction createNewStory(): IStory {\n  return Story.create({\n    id: uuid(),\n    name: 'New Story',\n    description: 'A story about something'\n  }).toJSON();\n}\n\nfunction createNewScrap(associatedStoryId: string): IScrap {\n  return Scrap.create({\n    id: uuid(),\n    synopsis: 'Story Content',\n    prose: 'Here is where you can summarize the story, and start to structure / brainstorm\\n'\n      + 'Feel free to create new scraps for alternative starting points, or new supporting docs '\n      + 'for this story.',\n    stories: [associatedStoryId]\n  }).toJSON();\n}\n\nfunction getStorySection(storyMap: StoryMap): JSX.Element {\n  const storyList = Object.values(storyMap);\n\n  if (!storyList.length) {\n    return (\n        <Segment>Whoops, no stories yet</Segment>\n    );\n  }\n\n  return <Segment style={{display: 'flex', flexWrap: 'wrap'}}>\n    {storyList.map((story, idx) => {\n      return (\n          <StoryCard key={idx} story={story} />\n      );\n    })}\n  </Segment>\n}\n\nexport default function Homepage() {\n  const storyMap = useAppSelector(selectStoryMap);\n  const dispatch = useAppDispatch();\n  const history = useHistory();\n\n  return (\n      <div style={{margin: '24px'}}>\n        <Segment.Group >\n          <Segment style={{display: 'flex'}}>\n            <Header size='medium'>Story List\n              <Header.Subheader>\n                All your stories\n              </Header.Subheader>\n            </Header>\n            <div style={{flex: 1, textAlign: 'right'}}>\n              <Button icon color='green'\n                onClick={() => {\n                  const newStory = createNewStory();\n                  dispatch(createStory(newStory));\n                  const newScrap = createNewScrap(newStory.id as string);\n                  dispatch(createScrap(newScrap));\n\n                  history.push(`/story/${newStory.id}`);\n                }}\n              >\n                <Icon name='add' />\n              </Button>\n            </div>\n          </Segment>\n          {getStorySection(storyMap)}\n        </Segment.Group>\n      </div>\n  );\n}\n","import React, {Component, ReactNode} from 'react';\nimport {Button, Container, Dropdown, Form, Header, Icon, Menu, Segment, TextArea} from 'semantic-ui-react';\nimport {Duration, Scrap, Story} from '../../protos_v2';\nimport {\n  Link\n} from 'react-router-dom';\nimport { v4 as uuid } from 'uuid';\n\ninterface StoryDetailsProps {\n  story: Story|null;\n  scraps: Scrap[];\n  onStoryChange: (story: Story) => void;\n  onStoryDelete: () => void;\n  onScrapCreate: (scrap: Scrap) => void;\n  onScrapUpdate: (scrap: Scrap) => void;\n}\n\ninterface StoryDetailsState {\n  durationErrorString: string|null;\n  currentScrapFilter: string;\n  currentScrapId: string;\n}\n\nexport default class StoryDetails extends Component<StoryDetailsProps, StoryDetailsState> {\n  state: StoryDetailsState = {\n    durationErrorString: null,\n    currentScrapFilter: 'mine',\n    currentScrapId: '',\n  };\n\n  onNameChange(newName: string) {\n    const story = this.props.story as Story;\n\n    story.name = newName;\n    this.props.onStoryChange(story);\n  }\n\n  onDescriptionChange(newDescription: string) {\n    const story = this.props.story as Story;\n\n    story.description = newDescription;\n    this.props.onStoryChange(story);\n  }\n\n  getDurationString(): string {\n    let durationSec = (this.props.story?.duration?.seconds || 0) as number;\n\n    let durationStr = '';\n\n    const hours = Math.floor(durationSec / 3600);\n    durationSec -= 3600 * hours;\n    durationStr += hours.toString().padStart(2, '0') + ':';\n\n    const minutes = Math.floor(durationSec / 60);\n    durationSec -= 60 * minutes;\n    durationStr += minutes.toString().padStart(2, '0') + ':';\n\n    durationStr += durationSec.toString().padStart(2, '0');\n\n    return durationStr;\n  }\n\n  onDurationChange(newDuration: string) {\n    const expectedRegex = new RegExp('^[0-9:]+$');\n    if (!expectedRegex.test(newDuration)) {\n      return this.setDurationErrorString(true);\n    }\n\n    const splitDurationStr = newDuration.split(':').filter(Boolean);\n\n    if (splitDurationStr.length > 3) {\n      return this.setDurationErrorString(true);\n    }\n\n    let durationSec = 0;\n    for (let i = 0; i < splitDurationStr.length; i++) {\n      durationSec = (60 * durationSec) + parseInt(splitDurationStr[i], 10);\n    }\n\n    const story = this.props.story as Story;\n    story.duration = Duration.create({\n      seconds: durationSec\n    });\n\n    this.props.onStoryChange(story);\n    this.setDurationErrorString(false);\n  }\n\n  setDurationErrorString(hasError: boolean) {\n    this.setState((state) => ({\n      ...state,\n      durationErrorString: hasError ? 'Please enter a duration of format HH:MM:SS' : null\n    }));\n  }\n\n  getFilteredScraps(filter: string) {\n    return this.props.scraps.filter((scrap) => {\n      if (filter === 'mine' && scrap.stories.indexOf(this.props.story?.id || '') < 0) {\n        return false;\n      }\n\n      if (filter === 'others' && scrap.stories.indexOf(this.props.story?.id || '') >= 0) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  createNewScrap(): Scrap {\n    return Scrap.create({\n      id: uuid(),\n      synopsis: 'New Scrap',\n      prose: 'New scrap for \"' + this.props.story?.name + '\" story\\nFill this out with notes or prose content',\n      stories: [this.props.story?.id as string]\n    });\n  }\n\n  renderScrapDetails(): ReactNode {\n    let currentScrap = this.props.scraps.find((scrap) => {\n      return scrap.id === this.state.currentScrapId;\n    });\n\n    if (!currentScrap) {\n      return (\n          <Header>Please select a scrap</Header>\n      )\n    }\n\n    let linkUnlinkButton;\n    if (currentScrap.stories.indexOf(this.props.story?.id || '') >= 0) {\n      // Need unlink button\n      linkUnlinkButton =\n          (<Button icon color='red'\n                   onClick={() => {\n                     const editingScrap = currentScrap as Scrap;\n                     editingScrap.stories = editingScrap.stories.filter((storyId) => {\n                       return storyId !== this.props.story?.id;\n                     });\n\n                     this.props.onScrapUpdate(editingScrap);\n                   }}>\n        <Icon name='unlink' />\n      </Button>);\n    } else {\n      linkUnlinkButton = (\n          <Button icon color='green'\n                  onClick={() => {\n                    const editingScrap = currentScrap as Scrap;\n                    editingScrap.stories.push(this.props.story?.id || '');\n                    this.props.onScrapUpdate(editingScrap);\n                  }}>\n            <Icon name='linkify' />\n          </Button>\n      );\n    }\n\n    return (\n        <div>\n          <div style={{display: 'flex'}}>\n            <Header>\n              {currentScrap.synopsis}\n            </Header>\n            <div style={{flex: 1, textAlign: 'right'}}>\n              {linkUnlinkButton}\n            </div>\n          </div>\n          <Container text>\n            {currentScrap.prose.split('\\n').map((line, idx) => {\n              return (<p key={'line-' +idx}>{line}</p>);\n            })}\n          </Container>\n          <div style={{marginTop: '32px'}}>\n            <Link to={`/scrap/${currentScrap.id}`}>\n              <Button primary>Start writing</Button>\n            </Link>\n          </div>\n        </div>\n    );\n\n  }\n\n  render() {\n    if (!this.props.story) {\n      return (\n          <div>Whoops, could not find story</div>\n      );\n    }\n\n    return (\n        <div style={{margin: '24px'}}>\n          <Segment.Group>\n            <Segment style={{display: 'flex'}}>\n              <Header>\n                Story Details\n                <Header.Subheader>\n                  Set the title, top-level description here\n                </Header.Subheader>\n              </Header>\n\n              <div style={{flex: 1, textAlign: 'right'}}>\n                <Button icon color='red'\n                        onClick={() => this.props.onStoryDelete()}\n                >\n                  <Icon name='delete' />\n                </Button>\n              </div>\n            </Segment>\n            <Segment>\n              <Form>\n                <Form.Group widths='equal'>\n                  <Form.Input\n                      label='Story Name'\n                      defaultValue={this.props.story.name}\n                      onChange={(e) => this.onNameChange(e.target.value)}\n                  />\n                  <Form.Input\n                      label='Intended Duration (HH:MM:SS)'\n                      defaultValue={this.getDurationString()}\n                      error={this.state.durationErrorString}\n                      onChange={(e) => this.onDurationChange(e.target.value)}\n                  />\n                </Form.Group>\n                <Form.Field>\n                  <label>Story Description</label>\n                  <TextArea\n                      defaultValue={this.props.story.description}\n                      onChange={(e) => this.onDescriptionChange(e.target.value)}\n                      style={{fontFamily: 'CourierPrime', height: '125px'}}\n                  />\n                </Form.Field>\n              </Form>\n            </Segment>\n          </Segment.Group>\n          <Segment.Group>\n            <Segment style={{display: 'flex'}}>\n              <Header>\n                Scraps\n                <Header.Subheader>\n                  These are the bits and pieces that make up the story\n                </Header.Subheader>\n              </Header>\n\n              <div style={{flex: 1, textAlign: 'right'}}>\n                <Button icon color='green'\n                        onClick={() => {\n                          this.props.onScrapCreate(this.createNewScrap())\n                        }}\n                >\n                  <Icon name='add' />\n                </Button>\n              </div>\n            </Segment>\n            <Segment style={{display: 'flex'}}>\n              <Menu pointing vertical>\n\n                  <Menu.Item>\n                    <Dropdown\n                        fluid\n                        selection\n                        onChange={(e, { value }) => {\n                          this.setState({\n                            ...this.state,\n                            currentScrapFilter: value as string,\n                          })\n                        }}\n                        defaultValue={this.state.currentScrapFilter}\n                        options={[\n                          {\n                            value: 'all',\n                            text: 'All stories',\n                            description: '' + (this.getFilteredScraps('all').length)\n                          },\n                          {\n                            value: 'mine',\n                            text: 'This story',\n                            description: '' + (this.getFilteredScraps('mine').length)\n                          },\n                          {\n                            value: 'others',\n                            text: 'Other stories',\n                            description: '' + (this.getFilteredScraps('others').length)\n                          },\n                        ]}>\n                    </Dropdown>\n                  </Menu.Item>\n                {this.getFilteredScraps(this.state.currentScrapFilter).map((scrap, idx) => {\n                  return (<Menu.Item\n                      key={'scrap-menu-' + idx}\n                      name={scrap.id}\n                      active={scrap.id === this.state.currentScrapId}\n                      onClick={() => this.setState({...this.state, currentScrapId: scrap.id})}\n                  >{scrap.synopsis}</Menu.Item>);\n                }).filter(Boolean)}\n              </Menu>\n              <div style={{flex: 1, marginLeft: '32px'}}>\n                {this.renderScrapDetails()}\n              </div>\n            </Segment>\n          </Segment.Group>\n        </div>\n    );\n  }\n}\n","import { RouteComponentProps } from 'react-router';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {removeStory, selectSpecificStory, updateStory} from '../../features/storyList/storyListSlice';\nimport StoryDetails from '../../features/storyDetails/StoryDetails';\nimport {Scrap, Story} from '../../protos_v2';\nimport {useHistory} from 'react-router-dom';\nimport {createScrap, selectScrapMap, updateScrap} from '../../features/scrapList/scrapListSlice';\n\ninterface MatchParams {\n  id: string\n}\n\ninterface StoryDetailsProps extends RouteComponentProps<MatchParams> {}\n\nexport default function StoryDetailsPage (props: StoryDetailsProps) {\n  const story = useAppSelector(selectSpecificStory(props.match.params?.id));\n  const topLevelScraps: Scrap[] = Object.values(useAppSelector(selectScrapMap));\n  const dispatch = useAppDispatch();\n  const history = useHistory();\n\n  return (\n    <StoryDetails\n      story={story}\n      scraps={topLevelScraps}\n      onStoryChange={(story) => dispatch(updateStory(story.toJSON()))}\n      onStoryDelete={() => {\n        dispatch(removeStory((story as Story).id));\n        history.push('/');\n      }}\n      onScrapCreate={(scrap) => {\n        dispatch(createScrap(scrap.toJSON()));\n        history.push('/scrap/' + scrap.id);\n      }}\n      onScrapUpdate={(scrap) => {\n        dispatch(updateScrap(scrap.toJSON()));\n      }}\n    />\n  )\n}\n","import {useAppSelector} from '../../app/hooks';\nimport {Button, Header, Segment} from 'semantic-ui-react';\nimport {selectStoryMap} from '../../features/storyList/storyListSlice';\n\nimport fileDownload from 'js-file-download';\nimport {WritingWorkspace} from '../../protos_v2';\nimport {addStoryToStorage, readAllStoriesFromStorage} from '../../features/storyList/storyListPersistence';\nimport {addScrapToStorage, readAllScrapsFromStorage} from '../../features/scrapList/scrapListPersistence';\n\nfunction clearWorkspace() {\n  localStorage.clear();\n  window.location.reload();\n}\n\nfunction downloadWorkspace() {\n  const filename = 'writing_workspace_' + Date.now() + '.write';\n\n  fileDownload(loadDataFromStorage(), filename);\n}\n\nasync function uploadWorkspace(files: FileList|null) {\n  if (!files) {\n    return;\n  }\n\n  const fileData = await files[0].arrayBuffer();\n  const parsedData = new Uint8Array(fileData);\n  loadDataToStorage(parsedData);\n\n  window.location.reload();\n}\n\nexport function loadDataFromStorage(): Uint8Array {\n  const workspace = WritingWorkspace.create({\n    stories: readAllStoriesFromStorage(),\n    scraps: readAllScrapsFromStorage(),\n  });\n\n  return WritingWorkspace.encode(workspace).finish();\n}\n\nexport function loadDataToStorage(data: Uint8Array): void {\n  const workspace = WritingWorkspace.decode(data);\n\n  localStorage.clear();\n\n  workspace.stories.forEach((story) => {\n    addStoryToStorage(story);\n  });\n\n  workspace.scraps.forEach((scrap) => {\n    addScrapToStorage(scrap);\n  });\n}\n\n\nexport default function DataManagementPage() {\n  const storyMap = useAppSelector(selectStoryMap);\n\n  return (\n      <div style={{margin: '24px'}}>\n        <Segment.Group >\n          <Segment style={{display: 'flex'}}>\n            <Header size='medium'>Data Management\n              <Header.Subheader>\n                Load, Save, or Clear your Workspace\n              </Header.Subheader>\n            </Header>\n          </Segment>\n          <Segment>\n            {Object.keys(storyMap).length} Stories\n          </Segment>\n          <Segment>\n            <Button color='green'\n                    onClick={() => {downloadWorkspace()}}>\n              Download Workspace\n            </Button>\n            <Button color='red'\n                    onClick={() => {clearWorkspace()}}>\n              Clear Workspace\n            </Button>\n          </Segment>\n          <Segment>\n            <Header size='small'>Upload Workspace</Header>\n            <input type=\"file\" accept=\".write\" onChange={(event) => uploadWorkspace(event.target.files)} />\n          </Segment>\n        </Segment.Group>\n      </div>\n  );\n}\n","import { RouteComponentProps } from 'react-router';\n\n\ninterface MatchParams {\n  id: string\n}\n\ninterface ScrapDetailsProps extends RouteComponentProps<MatchParams> {}\n\nexport default function ScrapDetailsPage (props: ScrapDetailsProps) {\n\n  return (\n      <div>This will be details for scrap {props.match.params.id}</div>\n  )\n}\n","import React from 'react';\nimport './App.css';\nimport RevisionHeader from './features/revision-header/RevisionHeader';\nimport {\n  HashRouter as Router,\n  Switch,\n  Route\n} from 'react-router-dom';\n\nimport Homepage from './pages/homepage/Homepage';\nimport StoryDetailsPage from './pages/story-details/StoryDetailsPage';\nimport DataManagementPage from './pages/import-export/DataManagementPage';\nimport ScrapDetailsPage from './pages/scrap-details/ScrapDetailsPage';\n\nfunction App() {\n  return (\n    <Router>\n      <RevisionHeader />\n      <Switch>\n        <Route path=\"/data\" component={DataManagementPage} />\n        <Route path=\"/story/:id\" component={StoryDetailsPage} />\n        <Route path=\"/scrap/:id\" component={ScrapDetailsPage} />\n        <Route path=\"/\" component={Homepage} />\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n","import {configureStore, ThunkAction, Action} from '@reduxjs/toolkit';\nimport storyListReducer, {storyListPersistenceMiddleware} from '../features/storyList/storyListSlice';\nimport scrapListReducer, {scrapListPersistenceMiddleware} from '../features/scrapList/scrapListSlice';\n\nexport const store = configureStore({\n  reducer: {\n    storyList: storyListReducer,\n    scrapList: scrapListReducer,\n  },\n  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat([\n    storyListPersistenceMiddleware,\n    scrapListPersistenceMiddleware,\n  ])\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\nimport 'semantic-ui-css/semantic.min.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}