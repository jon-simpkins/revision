{"version":3,"sources":["protos_v2.js","app/hooks.ts","features/revision-header/headerOptionsSlice.ts","features/utils/durationUtils.ts","features/revision-header/RevisionHeader.tsx","features/scrapList/scrapListPersistence.ts","features/scrapList/scrapListSlice.ts","pages/homepage/Homepage.tsx","pages/import-export/DataManagementPage.tsx","features/scrapDetails/usefulConstants.ts","features/scrapDetails/ScrapEmbedComponent.tsx","features/scrapDetails/BaseReadOnlyComponent.tsx","features/scrapDetails/FountainHeaderComponent.tsx","features/scrapDetails/FountainTransitionComponent.tsx","features/scrapDetails/FountainCenteredComponent.tsx","features/scrapDetails/FountainCharacterComponent.tsx","features/scrapDetails/FountainDialogueComponent.tsx","features/scrapDetails/FountainParentheticalComponent.tsx","features/scrapDetails/FountainActionComponent.tsx","features/scrapDetails/ScrapPlaceholderComponent.tsx","features/scrapDetails/ScrapTraitComponent.tsx","features/scrapDetails/parseProse.ts","features/scrapDetails/CommentComponent.tsx","features/scrapDetails/foutainDecorators.ts","features/scrapDetails/ScrapDetails.tsx","pages/scrap-details/ScrapDetailsPage.tsx","pages/decisions/DecisionPage.tsx","features/utils/fetchParsedContentBlocksForScrap.ts","features/timeline/timelineParsing.ts","features/timeline/Timeline.tsx","features/scrapDetails/ReadOnlyViewer.tsx","pages/read-scrap/ReadScrapPage.tsx","features/utils/fetchCharacters.ts","features/utils/fetchTraits.ts","App.tsx","app/store.ts","serviceWorker.ts","index.tsx"],"names":["define","$protobuf","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","Timestamp","properties","keys","Object","i","length","this","prototype","seconds","nanos","create","encode","message","writer","hasOwnProperty","call","uint32","int32","encodeDelimited","ldelim","decode","reader","end","undefined","len","pos","tag","skipType","decodeDelimited","verify","isInteger","fromObject","object","toObject","options","defaults","toJSON","constructor","toJSONOptions","Duration","Scrap","childScraps","id","intendedDurationSec","synopsis","prose","emptyArray","string","push","isString","Array","isArray","String","TypeError","arrays","j","WritingWorkspace","scraps","fork","error","useAppDispatch","useDispatch","useAppSelector","useSelector","headerOptionsSlice","createSlice","name","initialState","currentScrapId","showEditLink","showReadLink","characterFilters","currentCharacterFilter","currentCompletionFilter","traitFilters","currentTraitFilter","isCurrentlyInSession","currentWritingSessionStartEpoch","lastCheckedWritingSessionEpoch","reducers","updateHeaderOptions","state","action","payload","readHeaderOptions","headerOptions","actions","durationSecondsToString","durationSeconds","durationStr","hours","Math","floor","toString","padStart","minutes","round","durationStringToSeconds","durationString","RegExp","test","Error","splitDurationStr","split","filter","Boolean","durationSec","parseInt","RevisionHeader","completionFilters","editEntry","readEntry","timerEntry","dispatch","dispatchPartialOptionsUpdate","partialUpdate","characterOptions","map","characterFilter","key","character","text","percentDurationSec","value","unshift","Dropdown","floating","labeled","scrolling","item","className","onChange","e","data","traitOptions","traitFilter","trait","numberOfAppearances","to","Menu","Item","Icon","Date","now","Button","onClick","setInterval","header","position","allScrapIdsKey","scrapKey","readAllScrapsFromStorage","readScrapIds","scrapString","localStorage","getItem","JSON","parse","readScrap","storyIdString","writeScrapIds","scrapIds","setItem","stringify","writeScrap","scrap","addScrapToStorage","allScrapIds","scrapMap","forEach","fetchInitialStateFromStorage","actionPrefix","ScrapListSlice","createScrap","updateScrap","removeScrap","scrapListPersistenceMiddleware","storeAPI","next","result","type","startsWith","handleScrapListPersistence","idToRemove","removeItem","selectScrapMap","compiledScrapMap","entries","scrapList","getScrapSection","values","hasParentMap","childId","Segment","preparedScrapList","sort","a","b","style","display","flexWrap","idx","Card","margin","Content","Homepage","history","useHistory","Group","Header","size","Subheader","flex","textAlign","icon","color","newScrap","uuid","downloadWorkspace","filename","fileDownload","workspace","finish","loadDataFromStorage","files","arrayBuffer","fileData","loadDataToStorage","Uint8Array","window","location","reload","clear","DataManagementPage","accept","event","uploadWorkspace","target","ONE_LINE_DURATION_SEC","PAGE_WIDTH_EM","scrapIdField","ancestorField","pendingDurationSecContribution","durationSecContribution","isScrapTrait","scrapTraitText","isScrapPlaceholder","scrapPlaceholderText","scrapPlaceholderDurationSecField","isScrapEmbedding","scrapLink","isFountainHeader","isFountainCentered","isFountainTransition","isBlank","isComment","isFountainCharacter","isFountainDialogue","isFountainParenthetical","isFountainAction","FOUNTAIN_EDITOR_STYLE","border","padding","width","overflowY","fontSize","fontFamily","mergeDataObject","dataObject","newData","checkIsScrapEmbed","blockText","endsWith","includes","ScrapEmbedSummary","props","scrapId","parentScrapId","onGotoScrap","marginLeft","Component","parseScrapIdFromProps","contentState","getBlockMap","get","blockKey","getData","BaseReadOnlyComponent","isHover","cursor","top","right","circular","setState","paddingRight","isFilterSelected","backgroundColor","children","getParentStyle","onMouseEnter","onMouseLeave","renderSpecific","buildScrapLinkButton","fountainHeaderStrategy","contentBlock","callback","getText","sceneHeaderDurationSec","FountainHeaderComponent","fontWeight","FountainHeaderReadOnlyComponent","fountainTransitionStrategy","sceneTransitionDurationSec","FountainTransitionComponent","FountainTransitionReadOnlyComponent","fountainCenteredStrategy","sceneCenteredDurationSec","FountainCenteredComponent","FountainCenteredReadOnlyComponent","fountainCharacterStrategy","characterDurationSec","ceil","FountainCharacterComponent","FountainCharacterReadOnlyClassComponent","fountainDialogueStrategy","dialogueDurationSec","FountainDialogueComponent","FountainDialogueReadOnlyClassComponent","fountainParentheticalStrategy","parentheticalDurationSec","FountainParentheticalComponent","FountainParentheticalReadOnlyClassComponent","fountainActionStrategy","actionDurationSec","FountainActionComponent","FountainActionReadOnlyComponent","scrapPlaceholderStrategy","scrapPlaceholderDurationSec","content","replace","trim","ScrapPlaceholderReadOnlyComponent","placeholderText","displayText","linesOfText","numberOfLines","heightStyle","numberOfInstances","height","background","overflow","fill","bottom","zIndex","scrapTraitStrategy","preProcessProseBlock","blockData","checkIsCommentStart","checkIsCommentEnd","set","Immutable","fromJS","processProseBlock","blockBefore","blockAfter","processProgress","toJS","blankBefore","blankAfter","characterBefore","currentDurationSec","checkIsSceneHeader","toUpperCase","checkIsSceneTransition","checkIsCentered","checkIsCharacter","checkIsDialogue","checkIsParenthetical","checkIsScrapPlaceholder","checkIsScrapTrait","actionData","scrapTraitData","scrapPlaceholderData","parentheticalData","dialogueData","parsedCharacter","characterData","sceneCenteredData","sceneTransitionData","sceneHeaderData","scrapEmbedData","add","childScrap","updatedBlock","updatedCharacterList","getCharacterList","c","parseAllProse","warnParsingThreshold","errorParsingThreshold","newParseErrorState","processStartEpoch","OrderedSet","currentBlockMap","blockKeys","nextKey","timeSoFar","currentlyInComment","currentBlock","updatedData","update","newContent","durationMs","console","log","totalDurationSec","showTimeoutWarning","editorDecorator","CompositeDecorator","strategy","component","inComment","currentLocation","useLocation","pathname","fontStyle","viewerDecorator","styleMap","ScrapDetails","domEditor","remapEditorContent","debounce","newStrToEmit","editorState","getCurrentContent","getPlainText","lastEmittedStr","persistProse","parseResult","thisScrap","array","isArrayEqualToImmutableSet","toArray","onScrapUpdate","EditorState","currentContent","actualDurationSec","parseErrorState","initializeState","buildInitialEditorState","durationErrorString","parentScrapIds","buildParentScrapIds","durationInputKey","focusMode","onUpdateHeaderOptions","createWithContent","ContentState","createFromText","createEmpty","setHeaderOptions","prevProps","prevState","snapshot","parentScraps","scrapContribution","parentScrapLinks","parentScrap","BreadcrumbSection","link","Breadcrumb","reduce","prev","curr","BreadcrumbDivider","newSynopsis","Form","Input","label","defaultValue","onSynopsisChange","onDurationChange","Field","updateExpectedDurationSec","disabled","newDuration","setDurationErrorString","hasError","parseWarning","focusLabel","durationPercentLabel","addChildScrap","replacePlaceholderScraps","toggleFocusMode","ref","focus","newState","selected","getFragmentFromSelection","x","join","editor","removeWhenDone","preventDefault","selectedText","getSelectedText","clipboard","then","newContentState","Modifier","replaceText","getSelection","newProseStr","currentSelection","currentlySelectedText","newScrapId","onScrapCreate","thingToInsert","isCollapsed","insertText","match","textToSwap","re","exec","textToReplace","splitText","noFocusSection","getBreadcrumbs","getPrimaryForm","flexDirection","getProseEditorToolbar","customStyleMap","stripPastedStyles","onCut","onCopy","setDomEditorRef","onProseChange","ScrapDetailsPage","params","DecisionPage","showListInput","showCurrentScores","nextCandidateLabel","nextCandidateDesc","candidates","winMatrix","candidateIndexA","candidateIndexB","newCandidates","description","currentScore","wins","losses","indexAWeights","ignore","getTotalComparisons","indexA","randomSelectWeighted","indexBWeights","indexB","weights","sumWeight","previousValue","currentValue","randomCutoff","random","sum","index","totalComparisons","candidateA","candidateB","marginTop","marginBottom","updateWin","line","winIndex","loseIndex","iteration","W_i","denominator","averageValue","setupNewComparison","sortedCandidates","candidate","newValue","mainContent","updateNextCandidateLabel","updateNextCandidateDesc","addCandidate","renderCandidates","renderComparison","toggleShowCurrentScores","renderWinMatrix","fetchParsedContentBlocksForScrap","scrapAncestors","newAncestors","allNewContentBlocks","getBlocksAsArray","block","embeddedScrapId","subBlocks","getScrapSynopsis","formatPercentString","percent","TimelineBlock","headerText","startSec","characters","pendingCompletion","traits","Set","highlightPendingCompletion","has","Popup","mouseEnterDelay","mouseLeaveDelay","trigger","boxShadow","left","TimelineRow","blocks","zoomLevel","borderBottom","render","Timeline","parsedContentBlocks","isValid","percentComplete","rows","parsedBlocks","totalPendingSec","durationContribution","incompleteContribution","characterContribution","parsedTraits","untrimmed","ancestors","lastBlockId","parseTimeline","numLevels","stepLevel","startingPoint","steps","nextContribution","secondMarkers","getSecondMarkers","markerTopPadding","overflowX","row","markerStyle","paddingTop","borderRight","paddingLeft","borderLeft","TimelineViewer","timeline","minimized","max","zoomOptions","zoomOut","zoomIn","flipMinimization","ReadOnlyViewer","createFromBlockArray","readOnly","ReadScrapPage","newHeaderOptions","ReadScrap","hasLoaded","characterMap","thisCharacter","thisDurationSecContribution","characterEntry","fetchCharacters","traitMap","untrimmedTrait","fetchTraits","App","path","store","configureStore","reducer","scrapListReducer","headerOptionsReducer","middleware","getDefaultMiddleware","concat","hostname","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch"],"mappings":"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","file":"static/js/main.c9767619.chunk.js","sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n(function(global, factory) { /* global define, require, module */\n\n    /* AMD */ if (typeof define === 'function' && define.amd)\n        define([\"protobufjs/minimal\"], factory);\n\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)\n        module.exports = factory(require(\"protobufjs/minimal\"));\n\n})(this, function($protobuf) {\n    \"use strict\";\n\n    // Common aliases\n    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n    \n    // Exported root namespace\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    \n    $root.Timestamp = (function() {\n    \n        /**\n         * Properties of a Timestamp.\n         * @exports ITimestamp\n         * @interface ITimestamp\n         * @property {number|null} [seconds] Timestamp seconds\n         * @property {number|null} [nanos] Timestamp nanos\n         */\n    \n        /**\n         * Constructs a new Timestamp.\n         * @exports Timestamp\n         * @classdesc Represents a Timestamp.\n         * @implements ITimestamp\n         * @constructor\n         * @param {ITimestamp=} [properties] Properties to set\n         */\n        function Timestamp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Timestamp seconds.\n         * @member {number} seconds\n         * @memberof Timestamp\n         * @instance\n         */\n        Timestamp.prototype.seconds = 0;\n    \n        /**\n         * Timestamp nanos.\n         * @member {number} nanos\n         * @memberof Timestamp\n         * @instance\n         */\n        Timestamp.prototype.nanos = 0;\n    \n        /**\n         * Creates a new Timestamp instance using the specified properties.\n         * @function create\n         * @memberof Timestamp\n         * @static\n         * @param {ITimestamp=} [properties] Properties to set\n         * @returns {Timestamp} Timestamp instance\n         */\n        Timestamp.create = function create(properties) {\n            return new Timestamp(properties);\n        };\n    \n        /**\n         * Encodes the specified Timestamp message. Does not implicitly {@link Timestamp.verify|verify} messages.\n         * @function encode\n         * @memberof Timestamp\n         * @static\n         * @param {ITimestamp} message Timestamp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Timestamp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.seconds != null && Object.hasOwnProperty.call(message, \"seconds\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seconds);\n            if (message.nanos != null && Object.hasOwnProperty.call(message, \"nanos\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link Timestamp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Timestamp\n         * @static\n         * @param {ITimestamp} message Timestamp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Timestamp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Timestamp message from the specified reader or buffer.\n         * @function decode\n         * @memberof Timestamp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Timestamp} Timestamp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Timestamp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Timestamp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.seconds = reader.int32();\n                    break;\n                case 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Timestamp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Timestamp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Timestamp} Timestamp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Timestamp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Timestamp message.\n         * @function verify\n         * @memberof Timestamp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Timestamp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                if (!$util.isInteger(message.seconds))\n                    return \"seconds: integer expected\";\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                if (!$util.isInteger(message.nanos))\n                    return \"nanos: integer expected\";\n            return null;\n        };\n    \n        /**\n         * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Timestamp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Timestamp} Timestamp\n         */\n        Timestamp.fromObject = function fromObject(object) {\n            if (object instanceof $root.Timestamp)\n                return object;\n            var message = new $root.Timestamp();\n            if (object.seconds != null)\n                message.seconds = object.seconds | 0;\n            if (object.nanos != null)\n                message.nanos = object.nanos | 0;\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Timestamp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Timestamp\n         * @static\n         * @param {Timestamp} message Timestamp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Timestamp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.seconds = 0;\n                object.nanos = 0;\n            }\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                object.seconds = message.seconds;\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                object.nanos = message.nanos;\n            return object;\n        };\n    \n        /**\n         * Converts this Timestamp to JSON.\n         * @function toJSON\n         * @memberof Timestamp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Timestamp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return Timestamp;\n    })();\n    \n    $root.Duration = (function() {\n    \n        /**\n         * Properties of a Duration.\n         * @exports IDuration\n         * @interface IDuration\n         * @property {number|null} [seconds] Duration seconds\n         * @property {number|null} [nanos] Duration nanos\n         */\n    \n        /**\n         * Constructs a new Duration.\n         * @exports Duration\n         * @classdesc Represents a Duration.\n         * @implements IDuration\n         * @constructor\n         * @param {IDuration=} [properties] Properties to set\n         */\n        function Duration(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Duration seconds.\n         * @member {number} seconds\n         * @memberof Duration\n         * @instance\n         */\n        Duration.prototype.seconds = 0;\n    \n        /**\n         * Duration nanos.\n         * @member {number} nanos\n         * @memberof Duration\n         * @instance\n         */\n        Duration.prototype.nanos = 0;\n    \n        /**\n         * Creates a new Duration instance using the specified properties.\n         * @function create\n         * @memberof Duration\n         * @static\n         * @param {IDuration=} [properties] Properties to set\n         * @returns {Duration} Duration instance\n         */\n        Duration.create = function create(properties) {\n            return new Duration(properties);\n        };\n    \n        /**\n         * Encodes the specified Duration message. Does not implicitly {@link Duration.verify|verify} messages.\n         * @function encode\n         * @memberof Duration\n         * @static\n         * @param {IDuration} message Duration message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Duration.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.seconds != null && Object.hasOwnProperty.call(message, \"seconds\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seconds);\n            if (message.nanos != null && Object.hasOwnProperty.call(message, \"nanos\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Duration message, length delimited. Does not implicitly {@link Duration.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Duration\n         * @static\n         * @param {IDuration} message Duration message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Duration.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Duration message from the specified reader or buffer.\n         * @function decode\n         * @memberof Duration\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Duration} Duration\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Duration.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Duration();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.seconds = reader.int32();\n                    break;\n                case 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Duration message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Duration\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Duration} Duration\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Duration.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Duration message.\n         * @function verify\n         * @memberof Duration\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Duration.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                if (!$util.isInteger(message.seconds))\n                    return \"seconds: integer expected\";\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                if (!$util.isInteger(message.nanos))\n                    return \"nanos: integer expected\";\n            return null;\n        };\n    \n        /**\n         * Creates a Duration message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Duration\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Duration} Duration\n         */\n        Duration.fromObject = function fromObject(object) {\n            if (object instanceof $root.Duration)\n                return object;\n            var message = new $root.Duration();\n            if (object.seconds != null)\n                message.seconds = object.seconds | 0;\n            if (object.nanos != null)\n                message.nanos = object.nanos | 0;\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Duration message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Duration\n         * @static\n         * @param {Duration} message Duration\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Duration.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.seconds = 0;\n                object.nanos = 0;\n            }\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                object.seconds = message.seconds;\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                object.nanos = message.nanos;\n            return object;\n        };\n    \n        /**\n         * Converts this Duration to JSON.\n         * @function toJSON\n         * @memberof Duration\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Duration.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return Duration;\n    })();\n    \n    $root.Scrap = (function() {\n    \n        /**\n         * Properties of a Scrap.\n         * @exports IScrap\n         * @interface IScrap\n         * @property {string|null} [id] Scrap id\n         * @property {number|null} [intendedDurationSec] Scrap intendedDurationSec\n         * @property {string|null} [synopsis] Scrap synopsis\n         * @property {string|null} [prose] Scrap prose\n         * @property {Array.<string>|null} [childScraps] Scrap childScraps\n         */\n    \n        /**\n         * Constructs a new Scrap.\n         * @exports Scrap\n         * @classdesc Represents a Scrap.\n         * @implements IScrap\n         * @constructor\n         * @param {IScrap=} [properties] Properties to set\n         */\n        function Scrap(properties) {\n            this.childScraps = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Scrap id.\n         * @member {string} id\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.id = \"\";\n    \n        /**\n         * Scrap intendedDurationSec.\n         * @member {number} intendedDurationSec\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.intendedDurationSec = 0;\n    \n        /**\n         * Scrap synopsis.\n         * @member {string} synopsis\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.synopsis = \"\";\n    \n        /**\n         * Scrap prose.\n         * @member {string} prose\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.prose = \"\";\n    \n        /**\n         * Scrap childScraps.\n         * @member {Array.<string>} childScraps\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.childScraps = $util.emptyArray;\n    \n        /**\n         * Creates a new Scrap instance using the specified properties.\n         * @function create\n         * @memberof Scrap\n         * @static\n         * @param {IScrap=} [properties] Properties to set\n         * @returns {Scrap} Scrap instance\n         */\n        Scrap.create = function create(properties) {\n            return new Scrap(properties);\n        };\n    \n        /**\n         * Encodes the specified Scrap message. Does not implicitly {@link Scrap.verify|verify} messages.\n         * @function encode\n         * @memberof Scrap\n         * @static\n         * @param {IScrap} message Scrap message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Scrap.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n            if (message.intendedDurationSec != null && Object.hasOwnProperty.call(message, \"intendedDurationSec\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.intendedDurationSec);\n            if (message.synopsis != null && Object.hasOwnProperty.call(message, \"synopsis\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.synopsis);\n            if (message.prose != null && Object.hasOwnProperty.call(message, \"prose\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.prose);\n            if (message.childScraps != null && message.childScraps.length)\n                for (var i = 0; i < message.childScraps.length; ++i)\n                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.childScraps[i]);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Scrap message, length delimited. Does not implicitly {@link Scrap.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Scrap\n         * @static\n         * @param {IScrap} message Scrap message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Scrap.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Scrap message from the specified reader or buffer.\n         * @function decode\n         * @memberof Scrap\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Scrap} Scrap\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Scrap.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Scrap();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.intendedDurationSec = reader.uint32();\n                    break;\n                case 3:\n                    message.synopsis = reader.string();\n                    break;\n                case 4:\n                    message.prose = reader.string();\n                    break;\n                case 9:\n                    if (!(message.childScraps && message.childScraps.length))\n                        message.childScraps = [];\n                    message.childScraps.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Scrap message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Scrap\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Scrap} Scrap\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Scrap.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Scrap message.\n         * @function verify\n         * @memberof Scrap\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Scrap.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                if (!$util.isString(message.id))\n                    return \"id: string expected\";\n            if (message.intendedDurationSec != null && message.hasOwnProperty(\"intendedDurationSec\"))\n                if (!$util.isInteger(message.intendedDurationSec))\n                    return \"intendedDurationSec: integer expected\";\n            if (message.synopsis != null && message.hasOwnProperty(\"synopsis\"))\n                if (!$util.isString(message.synopsis))\n                    return \"synopsis: string expected\";\n            if (message.prose != null && message.hasOwnProperty(\"prose\"))\n                if (!$util.isString(message.prose))\n                    return \"prose: string expected\";\n            if (message.childScraps != null && message.hasOwnProperty(\"childScraps\")) {\n                if (!Array.isArray(message.childScraps))\n                    return \"childScraps: array expected\";\n                for (var i = 0; i < message.childScraps.length; ++i)\n                    if (!$util.isString(message.childScraps[i]))\n                        return \"childScraps: string[] expected\";\n            }\n            return null;\n        };\n    \n        /**\n         * Creates a Scrap message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Scrap\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Scrap} Scrap\n         */\n        Scrap.fromObject = function fromObject(object) {\n            if (object instanceof $root.Scrap)\n                return object;\n            var message = new $root.Scrap();\n            if (object.id != null)\n                message.id = String(object.id);\n            if (object.intendedDurationSec != null)\n                message.intendedDurationSec = object.intendedDurationSec >>> 0;\n            if (object.synopsis != null)\n                message.synopsis = String(object.synopsis);\n            if (object.prose != null)\n                message.prose = String(object.prose);\n            if (object.childScraps) {\n                if (!Array.isArray(object.childScraps))\n                    throw TypeError(\".Scrap.childScraps: array expected\");\n                message.childScraps = [];\n                for (var i = 0; i < object.childScraps.length; ++i)\n                    message.childScraps[i] = String(object.childScraps[i]);\n            }\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Scrap message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Scrap\n         * @static\n         * @param {Scrap} message Scrap\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Scrap.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.childScraps = [];\n            if (options.defaults) {\n                object.id = \"\";\n                object.intendedDurationSec = 0;\n                object.synopsis = \"\";\n                object.prose = \"\";\n            }\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                object.id = message.id;\n            if (message.intendedDurationSec != null && message.hasOwnProperty(\"intendedDurationSec\"))\n                object.intendedDurationSec = message.intendedDurationSec;\n            if (message.synopsis != null && message.hasOwnProperty(\"synopsis\"))\n                object.synopsis = message.synopsis;\n            if (message.prose != null && message.hasOwnProperty(\"prose\"))\n                object.prose = message.prose;\n            if (message.childScraps && message.childScraps.length) {\n                object.childScraps = [];\n                for (var j = 0; j < message.childScraps.length; ++j)\n                    object.childScraps[j] = message.childScraps[j];\n            }\n            return object;\n        };\n    \n        /**\n         * Converts this Scrap to JSON.\n         * @function toJSON\n         * @memberof Scrap\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Scrap.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return Scrap;\n    })();\n    \n    $root.WritingWorkspace = (function() {\n    \n        /**\n         * Properties of a WritingWorkspace.\n         * @exports IWritingWorkspace\n         * @interface IWritingWorkspace\n         * @property {Array.<IScrap>|null} [scraps] WritingWorkspace scraps\n         */\n    \n        /**\n         * Constructs a new WritingWorkspace.\n         * @exports WritingWorkspace\n         * @classdesc Represents a WritingWorkspace.\n         * @implements IWritingWorkspace\n         * @constructor\n         * @param {IWritingWorkspace=} [properties] Properties to set\n         */\n        function WritingWorkspace(properties) {\n            this.scraps = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * WritingWorkspace scraps.\n         * @member {Array.<IScrap>} scraps\n         * @memberof WritingWorkspace\n         * @instance\n         */\n        WritingWorkspace.prototype.scraps = $util.emptyArray;\n    \n        /**\n         * Creates a new WritingWorkspace instance using the specified properties.\n         * @function create\n         * @memberof WritingWorkspace\n         * @static\n         * @param {IWritingWorkspace=} [properties] Properties to set\n         * @returns {WritingWorkspace} WritingWorkspace instance\n         */\n        WritingWorkspace.create = function create(properties) {\n            return new WritingWorkspace(properties);\n        };\n    \n        /**\n         * Encodes the specified WritingWorkspace message. Does not implicitly {@link WritingWorkspace.verify|verify} messages.\n         * @function encode\n         * @memberof WritingWorkspace\n         * @static\n         * @param {IWritingWorkspace} message WritingWorkspace message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        WritingWorkspace.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.scraps != null && message.scraps.length)\n                for (var i = 0; i < message.scraps.length; ++i)\n                    $root.Scrap.encode(message.scraps[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified WritingWorkspace message, length delimited. Does not implicitly {@link WritingWorkspace.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof WritingWorkspace\n         * @static\n         * @param {IWritingWorkspace} message WritingWorkspace message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        WritingWorkspace.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a WritingWorkspace message from the specified reader or buffer.\n         * @function decode\n         * @memberof WritingWorkspace\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {WritingWorkspace} WritingWorkspace\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        WritingWorkspace.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WritingWorkspace();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 2:\n                    if (!(message.scraps && message.scraps.length))\n                        message.scraps = [];\n                    message.scraps.push($root.Scrap.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a WritingWorkspace message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof WritingWorkspace\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {WritingWorkspace} WritingWorkspace\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        WritingWorkspace.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a WritingWorkspace message.\n         * @function verify\n         * @memberof WritingWorkspace\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        WritingWorkspace.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.scraps != null && message.hasOwnProperty(\"scraps\")) {\n                if (!Array.isArray(message.scraps))\n                    return \"scraps: array expected\";\n                for (var i = 0; i < message.scraps.length; ++i) {\n                    var error = $root.Scrap.verify(message.scraps[i]);\n                    if (error)\n                        return \"scraps.\" + error;\n                }\n            }\n            return null;\n        };\n    \n        /**\n         * Creates a WritingWorkspace message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof WritingWorkspace\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {WritingWorkspace} WritingWorkspace\n         */\n        WritingWorkspace.fromObject = function fromObject(object) {\n            if (object instanceof $root.WritingWorkspace)\n                return object;\n            var message = new $root.WritingWorkspace();\n            if (object.scraps) {\n                if (!Array.isArray(object.scraps))\n                    throw TypeError(\".WritingWorkspace.scraps: array expected\");\n                message.scraps = [];\n                for (var i = 0; i < object.scraps.length; ++i) {\n                    if (typeof object.scraps[i] !== \"object\")\n                        throw TypeError(\".WritingWorkspace.scraps: object expected\");\n                    message.scraps[i] = $root.Scrap.fromObject(object.scraps[i]);\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a WritingWorkspace message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof WritingWorkspace\n         * @static\n         * @param {WritingWorkspace} message WritingWorkspace\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        WritingWorkspace.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.scraps = [];\n            if (message.scraps && message.scraps.length) {\n                object.scraps = [];\n                for (var j = 0; j < message.scraps.length; ++j)\n                    object.scraps[j] = $root.Scrap.toObject(message.scraps[j], options);\n            }\n            return object;\n        };\n    \n        /**\n         * Converts this WritingWorkspace to JSON.\n         * @function toJSON\n         * @memberof WritingWorkspace\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        WritingWorkspace.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return WritingWorkspace;\n    })();\n\n    return $root;\n});\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit';\nimport {RootState} from '../../app/store';\nimport {CharacterAppearance} from '../utils/fetchCharacters';\nimport {TraitAppearance} from '../utils/fetchTraits';\n\nexport interface HeaderOptions {\n  currentScrapId: string;\n  showEditLink: boolean;\n  showReadLink: boolean;\n  characterFilters: CharacterAppearance[];\n  currentCharacterFilter?: string;\n  currentCompletionFilter?: string;\n  traitFilters: TraitAppearance[];\n  currentTraitFilter?: string;\n  isCurrentlyInSession: boolean; // In a timed writing session\n  currentWritingSessionStartEpoch: number;\n  lastCheckedWritingSessionEpoch: number;\n}\n\ninterface headerOptionsInState {\n  headerOptions: {\n    options: HeaderOptions\n  }\n}\n\nconst initialState = {\n  options: {\n    currentScrapId: '',\n    showEditLink: false,\n    showReadLink: false,\n    characterFilters: [],\n    currentCharacterFilter: '',\n    currentCompletionFilter: '',\n    traitFilters: [],\n    currentTraitFilter: '',\n    isCurrentlyInSession: false,\n    currentWritingSessionStartEpoch: 0,\n    lastCheckedWritingSessionEpoch: 0,\n  } as HeaderOptions\n};\n\n\nconst actionPrefix = 'headerOptions';\n\nconst headerOptionsSlice = createSlice({\n  name: actionPrefix,\n  initialState,\n  reducers: {\n    updateHeaderOptions(state, action: PayloadAction<object>) {\n      state.options = {\n        ...state.options,\n        ...action.payload\n      } as HeaderOptions;\n    },\n  }\n});\n\nexport const readHeaderOptions = (state: headerOptionsInState|RootState): HeaderOptions => {\n  return state.headerOptions.options;\n}\n\nexport const { updateHeaderOptions } = headerOptionsSlice.actions;\nexport default headerOptionsSlice.reducer;\n","\n\nexport function durationSecondsToString(durationSeconds: number): string {\n  let durationStr = '';\n\n  const hours = Math.floor(durationSeconds / 3600);\n  durationSeconds -= 3600 * hours;\n  durationStr += hours.toString().padStart(2, '0') + ':';\n\n  const minutes = Math.floor(durationSeconds / 60);\n  durationSeconds -= 60 * minutes;\n  durationStr += minutes.toString().padStart(2, '0') + ':';\n\n  durationStr += Math.round(durationSeconds).toString().padStart(2, '0');\n\n  return durationStr;\n}\n\nexport function durationStringToSeconds(durationString: string): number {\n  const expectedRegex = new RegExp('^[0-9:]+$');\n  if (!expectedRegex.test(durationString)) {\n    throw Error('Invalid duration string');\n  }\n\n  const splitDurationStr = durationString.split(':').filter(Boolean);\n\n  if (splitDurationStr.length > 3) {\n    throw Error('Invalid duration string');\n  }\n\n  let durationSec = 0;\n  for (let i = 0; i < splitDurationStr.length; i++) {\n    durationSec = (60 * durationSec) + parseInt(splitDurationStr[i], 10);\n  }\n\n  return durationSec;\n}\n","import React from 'react';\nimport {\n  Link\n} from 'react-router-dom';\nimport {Button, Dropdown, DropdownItemProps, Icon, Menu} from 'semantic-ui-react';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {readHeaderOptions, updateHeaderOptions} from './headerOptionsSlice';\nimport {durationSecondsToString} from '../utils/durationUtils';\n\nexport default function RevisionHeader() {\n  const dispatch = useAppDispatch();\n  const options = useAppSelector(readHeaderOptions);\n\n  const dispatchPartialOptionsUpdate = (partialUpdate: object) => {\n    dispatch(updateHeaderOptions(partialUpdate));\n  }\n\n  let characterFilters;\n  if (options.characterFilters.length) {\n    const characterOptions = options.characterFilters.map((characterFilter) => {\n      return {\n        key: characterFilter.character,\n        text: `${characterFilter.character} (${Math.round(characterFilter.percentDurationSec * 1000) / 10}%)`,\n        value: characterFilter.character,\n      } as DropdownItemProps;\n    });\n\n    characterOptions.unshift({\n      key: 'none',\n      value: 'No Character Filter',\n      text: 'No Character Filter'\n    });\n\n    characterFilters = <Dropdown\n        text={options.currentCharacterFilter || 'Filter by character'}\n        floating\n        labeled\n        scrolling\n        item\n        className='icon'\n        value={options.currentCharacterFilter}\n        options={characterOptions}\n        onChange={(e, data) => {\n          dispatchPartialOptionsUpdate({\n            currentCharacterFilter: data.value as string,\n            currentCompletionFilter: '',\n            currentTraitFilter: '',\n          });\n        }}\n    />\n  }\n\n  let completionFilters;\n  if (options.showEditLink) {\n    // Only show on the read page\n    completionFilters = <Dropdown\n        text={options.currentCompletionFilter || 'Filter by completion'}\n        floating\n        labeled\n        scrolling\n        item\n        className='icon'\n        value={options.currentCompletionFilter}\n        options={[\n          {\n            key: 'none',\n            value: '',\n            text: 'No Completion Filter'\n          },\n          {\n            key: 'pending',\n            value: 'Pending Completion',\n            text: 'Pending Completion'\n          }\n        ]}\n        onChange={(e, data) => {\n          dispatchPartialOptionsUpdate({\n            currentCharacterFilter: '',\n            currentTraitFilter: '',\n            currentCompletionFilter: data.value as string,\n          });\n        }}\n    />\n  }\n\n  let traitFilters;\n  if (options.traitFilters.length) {\n    const traitOptions = options.traitFilters.map((traitFilter) => {\n      return {\n        key: traitFilter.trait,\n        text: `${traitFilter.trait} (${traitFilter.numberOfAppearances})`,\n        value: traitFilter.trait,\n      } as DropdownItemProps;\n    });\n\n    traitOptions.unshift({\n      key: 'none',\n      value: 'No Trait Filter',\n      text: 'No Trait Filter'\n    });\n\n    traitFilters = <Dropdown\n        text={options.currentTraitFilter || 'Filter by trait'}\n        floating\n        labeled\n        scrolling\n        item\n        className='icon'\n        value={options.currentTraitFilter}\n        options={traitOptions}\n        onChange={(e, data) => {\n          dispatchPartialOptionsUpdate({\n            currentCharacterFilter: '',\n            currentTraitFilter: data.value as string,\n            currentCompletionFilter: '',\n          });\n        }}\n    />\n  }\n\n  let editEntry;\n  if (options.showEditLink) {\n    editEntry = <Link to={'/scrap/' + options.currentScrapId}>\n      <Menu.Item>\n        <Icon name=\"edit\" />\n      </Menu.Item>\n    </Link>\n  }\n\n  let readEntry;\n  if (options.showReadLink) {\n    readEntry = <Link to={'/read/' + options.currentScrapId}>\n      <Menu.Item>\n        <Icon name=\"film\" />\n      </Menu.Item>\n    </Link>\n  }\n\n  let timerEntry;\n  if (options.isCurrentlyInSession) {\n    timerEntry = <Menu.Item>\n      {durationSecondsToString((Date.now() - options.currentWritingSessionStartEpoch) / 1000)} spent writing\n    </Menu.Item>\n  } else {\n    timerEntry = <Menu.Item><Button\n      onClick={() => {\n        dispatchPartialOptionsUpdate({\n          isCurrentlyInSession: true,\n          currentWritingSessionStartEpoch: Date.now(),\n          lastCheckedWritingSessionEpoch: Date.now(),\n        });\n\n        // Update header state every second, to get the timer to visibly update\n        setInterval(() => {\n          dispatchPartialOptionsUpdate({\n            lastCheckedWritingSessionEpoch: Date.now(),\n          });\n        }, 1000);\n      }}\n    >Start writing session</Button></Menu.Item>\n  }\n\n  return (\n      <Menu>\n        <Link to={'/'}>\n          <Menu.Item header>Revision</Menu.Item>\n        </Link>\n        <Link to={'/data'}>\n          <Menu.Item>\n            <Icon name=\"save\" />\n          </Menu.Item>\n        </Link>\n        {timerEntry}\n        <Menu.Menu position='right'>\n          {completionFilters}\n          {traitFilters}\n          {characterFilters}\n          {editEntry}\n          {readEntry}\n        </Menu.Menu>\n      </Menu>\n  );\n}\n","import {IScrap, Scrap} from '../../protos_v2';\nimport {ScrapMapInState} from './scrapListSlice';\n\nconst allScrapIdsKey = 'scrap-ids';\n\nfunction scrapKey(id: string): string {\n  return `scrap-${id}`;\n}\n\nexport function readAllScrapsFromStorage(): Scrap[] {\n  return readScrapIds().map((id) => {\n    return readScrap(id);\n  });\n}\n\nfunction readScrapIds(): string[] {\n  let storyIdString = localStorage.getItem(allScrapIdsKey) || '[]';\n  return JSON.parse(storyIdString) as string[];\n}\n\nfunction writeScrapIds(scrapIds: string[]): void {\n  localStorage.setItem(allScrapIdsKey, JSON.stringify(scrapIds));\n}\n\nfunction readScrap(id: string): Scrap {\n  let scrapString = localStorage.getItem(scrapKey(id));\n  if (!scrapString) {\n    throw Error(`Unable to read scrap ${id} from local storage`);\n  }\n\n  return Scrap.create(JSON.parse(scrapString));\n}\n\nexport function writeScrap(scrap: IScrap) {\n  localStorage.setItem(scrapKey(scrap.id as string), JSON.stringify(scrap));\n}\n\nexport function addScrapToStorage(scrap: IScrap): void {\n  writeScrap(scrap);\n\n  const allScrapIds = readScrapIds();\n  allScrapIds.push(scrap.id as string);\n  writeScrapIds(allScrapIds);\n}\n\n\nexport function clearScrapFromStorage(idToRemove: string): void {\n  let allScrapIds = readScrapIds();\n\n  writeScrapIds(allScrapIds.filter((id) => {\n    return id !== idToRemove;\n  }));\n\n  localStorage.removeItem(scrapKey(idToRemove));\n}\n\nexport function fetchInitialStateFromStorage() {\n  const initialState = {\n    scrapMap: {} as ScrapMapInState\n  };\n  readAllScrapsFromStorage().forEach((scrap) => {\n    initialState.scrapMap[scrap.id] = scrap.toJSON();\n  });\n\n  return initialState;\n}\n","import {createSlice, Middleware, PayloadAction} from '@reduxjs/toolkit';\nimport {RootState} from '../../app/store';\nimport {IScrap, Scrap} from '../../protos_v2';\nimport {addScrapToStorage, clearScrapFromStorage, fetchInitialStateFromStorage, writeScrap} from './scrapListPersistence';\n\nexport interface ScrapMap {\n  [key: string]: Scrap;\n}\n\nexport interface ScrapMapInState {\n  [key: string]: IScrap\n}\n\ninterface ScrapListInState {\n  scrapList: {\n    scrapMap: ScrapMapInState\n  }\n}\n\nconst initialState = fetchInitialStateFromStorage();\n\nconst actionPrefix = 'scrapList';\n\nconst ScrapListSlice = createSlice({\n  name: actionPrefix,\n  initialState,\n  reducers: {\n    createScrap(state, action: PayloadAction<IScrap>) {\n      state.scrapMap[action.payload.id as string] = action.payload;\n    },\n    updateScrap(state, action: PayloadAction<IScrap>) {\n      state.scrapMap[action.payload.id as string] = action.payload;\n    },\n    removeScrap(state, action: PayloadAction<string>) {\n      delete state.scrapMap[action.payload];\n    }\n  }\n});\n\nexport const scrapListPersistenceMiddleware: Middleware<{}, ScrapListInState>\n    = storeAPI => next => action => {\n  let result = next(action);\n\n  if (action.type.startsWith(actionPrefix + '/')) {\n    handleScrapListPersistence(action);\n  }\n\n  return result;\n}\n\nexport const handleScrapListPersistence = (action: PayloadAction<string|IScrap>) => {\n  switch (action.type) {\n    case `${actionPrefix}/createScrap`:\n      addScrapToStorage(action.payload as IScrap);\n      break;\n    case `${actionPrefix}/updateScrap`:\n      writeScrap(action.payload as IScrap);\n      break;\n    case `${actionPrefix}/removeScrap`:\n      clearScrapFromStorage(action.payload as string);\n      break;\n  }\n}\n\n// Selector for fetching full map of stories\nexport const selectScrapMap = (state: ScrapListInState|RootState): ScrapMap => {\n  const compiledScrapMap: ScrapMap = {};\n\n  for (const [key, value] of Object.entries(state.scrapList.scrapMap)) {\n    compiledScrapMap[key] = Scrap.fromObject(value);\n  }\n\n  return compiledScrapMap;\n}\n\n// Creates selector for particular Scrap\nexport const selectSpecificScrap = (id: string) => (state: ScrapListInState|RootState): Scrap|null => {\n  const fetchedScrap = state.scrapList.scrapMap[id];\n\n  if (!fetchedScrap) {\n    return null;\n  }\n\n  return Scrap.create(fetchedScrap);\n}\n\nexport const { createScrap, updateScrap, removeScrap } = ScrapListSlice.actions;\nexport default ScrapListSlice.reducer;\n","import {Button, Header, Card, Icon, Segment} from 'semantic-ui-react';\nimport { useHistory } from 'react-router-dom';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {IScrap, Scrap} from '../../protos_v2';\nimport { v4 as uuid } from 'uuid';\nimport {\n  Link\n} from 'react-router-dom';\nimport {createScrap, selectScrapMap, ScrapMap} from '../../features/scrapList/scrapListSlice';\nimport {durationSecondsToString} from '../../features/utils/durationUtils';\n\nfunction createNewScrap(): IScrap {\n  return Scrap.create({\n    id: uuid(),\n    synopsis: 'Story Content',\n    prose: 'Here is where you can summarize the story, and start to structure / brainstorm\\n'\n      + 'Feel free to create new scraps for alternative starting points, or new supporting docs '\n      + 'for this story.'\n  }).toJSON();\n}\n\nfunction getScrapSection(scrapMap: ScrapMap): JSX.Element {\n  const scrapList = Object.values(scrapMap);\n\n  const hasParentMap: {[key: string]: boolean} = {};\n  scrapList.forEach((scrap) => {\n    scrap.childScraps.forEach((childId) => {\n      hasParentMap[childId] = true;\n    });\n  });\n\n  if (!scrapList.length) {\n    return (\n        <Segment>Whoops, no scraps yet</Segment>\n    );\n  }\n\n  const preparedScrapList = scrapList.filter((scrap) => {\n    return !hasParentMap[scrap.id];\n  }).sort((a, b) => {\n    return b.intendedDurationSec - a.intendedDurationSec;\n  });\n\n  return <Segment style={{display: 'flex', flexWrap: 'wrap'}}>\n    {preparedScrapList.map((scrap, idx) => {\n      return (\n          <Link to={'/read/' + scrap.id} key={idx}>\n            <Card style={{margin: '8px'}}>\n              <Card.Content header={scrap.synopsis} />\n              <Card.Content>\n                <p>{durationSecondsToString(scrap.intendedDurationSec)}</p>\n              </Card.Content>\n            </Card>\n          </Link>\n      );\n    })}\n  </Segment>\n}\n\nexport default function Homepage() {\n  const dispatch = useAppDispatch();\n  const history = useHistory();\n  const scrapMap = useAppSelector(selectScrapMap);\n\n  return (\n      <div style={{margin: '24px'}}>\n        <Segment.Group >\n          <Segment style={{display: 'flex'}}>\n            <Header size='medium'>Scrap List\n              <Header.Subheader>\n                All your top-level scraps (no parents)\n              </Header.Subheader>\n            </Header>\n            <div style={{flex: 1, textAlign: 'right'}}>\n              <Button icon color='green'\n                onClick={() => {\n                  const newScrap = createNewScrap();\n                  dispatch(createScrap(newScrap));\n\n                  history.push(`/scrap/${newScrap.id}`);\n                }}\n              >\n                <Icon name='add' />\n              </Button>\n            </div>\n          </Segment>\n          {getScrapSection(scrapMap)}\n        </Segment.Group>\n      </div>\n  );\n}\n","import {useAppSelector} from '../../app/hooks';\nimport {Button, Header, Segment} from 'semantic-ui-react';\n\nimport fileDownload from 'js-file-download';\nimport {WritingWorkspace} from '../../protos_v2';\nimport {addScrapToStorage, readAllScrapsFromStorage} from '../../features/scrapList/scrapListPersistence';\nimport {selectScrapMap} from '../../features/scrapList/scrapListSlice';\n\nfunction clearWorkspace() {\n  localStorage.clear();\n  window.location.reload();\n}\n\nfunction downloadWorkspace() {\n  const filename = 'writing_workspace_' + Date.now() + '.write';\n\n  fileDownload(loadDataFromStorage(), filename);\n}\n\nasync function uploadWorkspace(files: FileList|null) {\n  if (!files) {\n    return;\n  }\n\n  const fileData = await files[0].arrayBuffer();\n  const parsedData = new Uint8Array(fileData);\n  loadDataToStorage(parsedData);\n\n  window.location.reload();\n}\n\nexport function loadDataFromStorage(): Uint8Array {\n  const workspace = WritingWorkspace.create({\n    scraps: readAllScrapsFromStorage(),\n  });\n\n  return WritingWorkspace.encode(workspace).finish();\n}\n\nexport function loadDataToStorage(data: Uint8Array): void {\n  const workspace = WritingWorkspace.decode(data);\n\n  localStorage.clear();\n\n  workspace.scraps.forEach((scrap) => {\n    addScrapToStorage(scrap);\n  });\n}\n\n\nexport default function DataManagementPage() {\n  const scrapMap = useAppSelector(selectScrapMap);\n\n  return (\n      <div style={{margin: '24px'}}>\n        <Segment.Group >\n          <Segment style={{display: 'flex'}}>\n            <Header size='medium'>Data Management\n              <Header.Subheader>\n                Load, Save, or Clear your Workspace\n              </Header.Subheader>\n            </Header>\n          </Segment>\n          <Segment>\n            {Object.keys(scrapMap).length} Scraps\n          </Segment>\n          <Segment>\n            <Button color='green'\n                    onClick={() => {downloadWorkspace()}}>\n              Download Workspace\n            </Button>\n            <Button color='red'\n                    onClick={() => {clearWorkspace()}}>\n              Clear Workspace\n            </Button>\n          </Segment>\n          <Segment>\n            <Header size='small'>Upload Workspace</Header>\n            <input type=\"file\" accept=\".write\" onChange={(event) => uploadWorkspace(event.target.files)} />\n          </Segment>\n        </Segment.Group>\n      </div>\n  );\n}\n","import React from 'react';\n\nexport const LINES_PER_PAGE = 55;\nexport const ONE_LINE_DURATION_SEC = 1.0909; // (1 / LINES_PER_PAGE * 60);\nexport const PAGE_WIDTH_EM = '37em';\n\n/** Fields on the data for a block of parsed text */\nexport const scrapIdField = 'scrapId'; // Indicates which scrap defines this block of prose\nexport const ancestorField = 'ancestorField'; // Array of ancestor scrap IDs, excluding the current one\n\nexport const pendingDurationSecContribution = 'pendingDurationSecContribution'; // Seconds (perhaps partial) which will be contributed, when this is actually written\nexport const durationSecContribution = 'durationSecContribution'; // Seconds (perhaps partial) contributed to the script duration\n\nexport const isScrapTrait = 'isScrapTrait';\nexport const scrapTraitText = 'scrapTraitText';\nexport const isScrapPlaceholder = 'isScrapPlaceholder';\nexport const scrapPlaceholderText = 'scrapPlaceholderText';\nexport const scrapPlaceholderDurationSecField = 'scrapPlaceholderDurationSecField';\nexport const isScrapEmbedding = 'isScrapEmbedding';\nexport const scrapLink = 'scrapLink';\nexport const isFountainHeader = 'isFountainHeader';\nexport const isFountainCentered = 'isFountainCentered';\nexport const isFountainTransition = 'isFountainTransition';\nexport const isBlank = 'isBlank';\nexport const isComment = 'isComment';\nexport const isCommentStart = 'isCommentStart';\nexport const isCommentEnd = 'isCommentEnd';\nexport const isFountainCharacter = 'isFountainCharacter';\nexport const character = 'character';\nexport const isFountainDialogue = 'isFountainDialogue';\nexport const isFountainParenthetical = 'isFountainParenthetical';\nexport const isFountainAction = 'isFountainAction';\n\nexport const FOUNTAIN_EDITOR_STYLE: React.CSSProperties = {\n  border: '1px solid',\n  padding: '6em',\n  margin: 'auto',\n  width: '49em', // PAGE_WIDTH_EM + padding\n  overflowY: 'scroll',\n  fontSize: '16px',\n  fontFamily: 'CourierPrime, Courier, monospace',\n  flex: '1'\n}\n\nexport function mergeDataObject(dataObject: { [index: string]: boolean|string|number}, newData: { [index: string]: boolean|string|number}): { [index: string]: boolean|string|number} {\n  return {\n    ...dataObject,\n    ...newData\n  };\n}\n","// Props are:\n// https://github.com/facebook/draft-js/blob/main/src/model/decorators/DraftDecorator.js#L54-L71\nimport {ContentBlock, ContentState} from 'draft-js';\nimport React, {Component} from 'react';\nimport {useAppSelector} from '../../app/hooks';\nimport {ScrapMap, selectScrapMap} from '../scrapList/scrapListSlice';\nimport {Scrap} from '../../protos_v2';\nimport {\n  useHistory, useLocation\n} from 'react-router-dom';\nimport {durationSecondsToString} from '../utils/durationUtils';\nimport {Button, Icon} from 'semantic-ui-react';\nimport {isComment, isScrapEmbedding, scrapLink} from './usefulConstants';\n\n\nexport function createChildScrap(parentScrapId: string, scrapMap: ScrapMap, scrapId: string): Scrap {\n  return Scrap.create({\n    id: scrapId,\n    synopsis: 'New Scrap created in editor',\n    prose: 'this has placeholder content for now',\n  });\n}\n\nexport function scrapEmbeddingStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isScrapEmbedding)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsScrapEmbed(blockText: string): boolean {\n  if (!blockText.startsWith('{{') || !blockText.endsWith('}}')) {\n    return false;\n  }\n\n  return !(blockText.includes('|') || blockText.includes('@') || blockText.includes('#'));\n}\n\nexport function scrapEmbedData(blockText: string): { [index: string]: boolean|string} {\n  const scrapId = blockText.replace('{{', '').replace('}}', '').trim();\n\n  return {\n    [scrapLink]: scrapId,\n    [isScrapEmbedding]: true,\n  }\n}\n\n/**\n * Embedded component to show a scrap in a DraftJS editor.\n *\n * Assumes that `scrapLink` on the block's data contains the ID\n * */\nexport const ScrapEmbedComponent = (props: any) => {\n  const contentState = props.contentState as ContentState;\n  const data = contentState.getBlockMap().get(props.blockKey).getData();\n  const scrapId = data.get(scrapLink);\n  const inComment = data.get(isComment);\n\n  const scrapMap = useAppSelector(selectScrapMap);\n  const history = useHistory();\n  const currentLocation = useLocation();\n\n  const parentScrapId = getScrapIdFromUrl(currentLocation.pathname);\n\n  const backgroundColor = inComment ? '#cfead9' : '#555';\n\n  return (\n      <div\n          style={{\n            background: backgroundColor,\n            fontWeight: 'bold',\n            display: 'flex',\n            padding: '8px'\n          }}\n      >\n        <div style={{\n          margin: '0',\n          fontSize: '1px',\n          height: '2px',\n          width: '2px',\n          overflow: 'hidden',\n          color: backgroundColor\n        }} >{props.children}</div>\n        <div style={{flex: '1', cursor: 'pointer', padding: '8px', border: '1px solid', background: 'white', fontWeight: 'normal'}}>\n          <ScrapEmbedSummary\n            parentScrapId={parentScrapId}\n            scrapId={scrapId}\n            scrapMap={scrapMap}\n            onGotoScrap={() => { history.push(`/scrap/${scrapId}`) }}\n          />\n        </div>\n      </div>\n  );\n}\n\nfunction getScrapIdFromUrl(url: string): string {\n  return url.replace('/scrap/', '');\n}\n\n\ninterface ScrapEmbedSummaryProps {\n  parentScrapId: string;\n  scrapId: string;\n  scrapMap: ScrapMap;\n  onGotoScrap: () => void;\n}\n\nexport class ScrapEmbedSummary extends Component<ScrapEmbedSummaryProps> {\n  render() {\n    const scrap = this.props.scrapMap[this.props.scrapId];\n\n    if (!scrap) {\n      return (<div>\n        Scrap \"{this.props.scrapId}\" does not exist.\n      </div>)\n    }\n\n    if (this.props.scrapId === this.props.parentScrapId) {\n      return (<div style={{color: 'red'}}>\n        Scraps shouldn't include themselves\n      </div>);\n    }\n\n    return (<div style={{display: 'flex'}}>\n      <Button icon color='blue'\n              onClick={() => {this.props.onGotoScrap();}}\n      >\n        <Icon name='angle right' />\n      </Button>\n      <div style={{marginLeft: '24px', flex: '1'}}>\n        <div>{scrap.synopsis}</div>\n        <div>{durationSecondsToString(scrap.intendedDurationSec)}</div>\n      </div>\n    </div>);\n  }\n}\n","import {ContentState} from 'draft-js';\nimport {PAGE_WIDTH_EM, scrapIdField} from './usefulConstants';\nimport React, {Component, ReactElement} from 'react';\nimport {Link} from 'react-router-dom';\nimport {Button} from 'semantic-ui-react';\n\ninterface FountainReadOnlyState {\n  isHover: boolean;\n  scrapId: string;\n}\n\nconst parseScrapIdFromProps = (props: any) => {\n  const contentState = props.contentState as ContentState;\n  const data = contentState.getBlockMap().get(props.blockKey).getData();\n  return data.get(scrapIdField);\n}\n\nexport class BaseReadOnlyComponent extends Component<any, FountainReadOnlyState> {\n\n  constructor(props: any) {\n    super(props);\n\n    this.state = {\n      isHover: false,\n      scrapId: parseScrapIdFromProps(props)\n    }\n  }\n\n  buildScrapLinkButton(): ReactElement|null {\n    if (!this.state.isHover) {\n      return null;\n    }\n\n    const scrapLink = `/scrap/${this.state.scrapId}`;\n\n    return <Link to={scrapLink}>\n      <Button style={{cursor: 'pointer', position: 'absolute', top: '-12px', right: '-20px'}} circular color='blue' icon='edit outline' />\n    </Link>;\n  }\n\n  onMouseEnter(): void {\n    this.setState({\n      isHover: true\n    });\n  }\n\n  onMouseLeave(): void {\n    this.setState({\n      isHover: false\n    });\n  }\n\n  getParentStyle(): any {\n    const style: React.CSSProperties = {\n      position: 'relative',\n      paddingRight: '20px',\n      width: PAGE_WIDTH_EM,\n      margin: 0,\n    };\n\n    if (this.props.isFilterSelected) {\n      style.backgroundColor = '#f6f6c6';\n    }\n\n    if (this.state.isHover) {\n      style.backgroundColor = '#c6e1f6';\n    }\n\n    return style;\n  }\n\n  renderSpecific() {\n    return <span>{this.props.children}</span>\n  }\n\n  render() {\n    return (\n        <div style={this.getParentStyle()}\n             onMouseEnter={() => {this.onMouseEnter();}}\n             onMouseLeave={() => {this.onMouseLeave();}}>\n          {this.renderSpecific()}\n          {this.buildScrapLinkButton()}\n        </div>\n    );\n  }\n}\n","import React from 'react';\nimport {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isFountainHeader, ONE_LINE_DURATION_SEC, PAGE_WIDTH_EM} from './usefulConstants';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\nexport function fountainHeaderStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainHeader)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsSceneHeader(blankBefore: boolean, blankAfter: boolean, blockText: string): boolean {\n  return blankBefore && blankAfter && ((/^(int|ext|est|i\\/e)[\\s.]/i).test(blockText) || (blockText.startsWith('.') && !blockText.startsWith('..')));\n}\n\nexport function sceneHeaderDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC; // Assume one line per scene heading\n}\n\nexport function sceneHeaderData(blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainHeader]: true,\n    [durationSecContribution]: sceneHeaderDurationSec(blockText),\n  }\n}\n\n/**\n * Component to show a Fountain scene header in DraftJS.\n *\n */\nexport const FountainHeaderComponent = (props: any) => {\n  return (\n      <div style={{fontWeight: 'bold', width: PAGE_WIDTH_EM}} >{props.children}</div>\n  );\n}\n\nexport class FountainHeaderReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainHeaderComponent(this.props);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isFountainTransition, ONE_LINE_DURATION_SEC, PAGE_WIDTH_EM} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\n\nexport function fountainTransitionStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainTransition)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsSceneTransition(blankBefore: boolean, blankAfter: boolean, blockText: string): boolean {\n  return blankBefore && blankAfter && ((blockText.startsWith('>') && !blockText.endsWith('<')) || (blockText.toUpperCase() === blockText && blockText.endsWith('TO:')));\n}\n\nexport function sceneTransitionDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC; // Assume one line per scene heading\n}\n\nexport function sceneTransitionData(blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainTransition]: true,\n    [durationSecContribution]: sceneTransitionDurationSec(blockText)\n  }\n}\n\n/**\n * Component to show a Fountain transition in DraftJS.\n *\n */\nexport const FountainTransitionComponent = (props: any) => {\n  return (\n      <div style={{fontWeight: 'bold', textAlign: 'right', width: PAGE_WIDTH_EM}} >{props.children}</div>\n  );\n}\n\n\nexport class FountainTransitionReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainTransitionComponent(this.props);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isFountainCentered, ONE_LINE_DURATION_SEC, PAGE_WIDTH_EM} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\n\nexport function fountainCenteredStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainCentered)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsCentered(blockText: string): boolean {\n  return blockText.startsWith('>') && blockText.endsWith('<');\n}\n\nexport function sceneCenteredDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC; // Assume one line per scene heading\n}\n\n\nexport function sceneCenteredData(blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainCentered]: true,\n    [durationSecContribution]: sceneCenteredDurationSec(blockText),\n  }\n}\n\n/**\n * Component to show a Fountain \"centered\" element in DraftJS.\n *\n */\nexport const FountainCenteredComponent = (props: any) => {\n  return (\n      <div style={{fontWeight: 'bold', textAlign: 'center', width: PAGE_WIDTH_EM}} >{props.children}</div>\n  );\n}\n\nexport class FountainCenteredReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainCenteredComponent(this.props);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {character, durationSecContribution, isFountainCharacter, ONE_LINE_DURATION_SEC} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\nimport {useAppSelector} from '../../app/hooks';\nimport {readHeaderOptions} from '../revision-header/headerOptionsSlice';\n\nexport function fountainCharacterStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainCharacter)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsCharacter(blankBefore: boolean, blankAfter: boolean, blockText: string): boolean {\n  return blankBefore && !blankAfter && (blockText.toUpperCase() === blockText || blockText.startsWith('@'));\n}\n\nexport function characterDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC * Math.ceil(blockText.length / 28); // About 28 characters per line\n}\n\nexport function characterData(blockText: string): { [index: string]: boolean|string|number} {\n  const parsedCharacter = blockText\n      .replace(/\\(V\\.O\\.\\)/i, '')\n      .replace(/\\(O\\.S\\.\\)/i, '')\n      .replace(/\\(CONT'D\\)/i, '')\n      .replace(/\\(CONT’D\\)/i, '')\n      .replace(/\\(PRE-LAP\\)/i, '')\n      .trim();\n\n  return {\n    [isFountainCharacter]: true,\n    [character]: parsedCharacter,\n    [durationSecContribution]: characterDurationSec(blockText)\n  }\n}\n\n/**\n * Component to show a Fountain character in DraftJS.\n *\n */\nexport const FountainCharacterComponent = (props: any) => {\n  return (\n      <div style={{fontWeight: 'bold', marginLeft: '12em', width: '17em'}} >{props.children}</div>\n  );\n}\n\n\nclass FountainCharacterReadOnlyClassComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainCharacterComponent(this.props);\n  }\n}\n\nexport const FountainCharacterReadOnlyComponent = (props: any) => {\n  let isFilterSelected = false;\n  let characterFilter = useAppSelector(readHeaderOptions).currentCharacterFilter;\n\n  const contentState = props.contentState as ContentState;\n  const data = contentState.getBlockMap().get(props.blockKey).getData();\n  if (characterFilter === data.get(character)) {\n    isFilterSelected = true;\n  }\n\n  return (\n      <FountainCharacterReadOnlyClassComponent\n          blockKey={props.blockKey}\n          contentState={props.contentState}\n          isFilterSelected={isFilterSelected}\n          key={props.key}\n          children={props.children} />\n  );\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {character, durationSecContribution, isFountainDialogue, ONE_LINE_DURATION_SEC} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\nimport {useAppSelector} from '../../app/hooks';\nimport {readHeaderOptions} from '../revision-header/headerOptionsSlice';\n\nexport function fountainDialogueStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainDialogue)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsDialogue(characterBefore: string, blockText: string): boolean {\n  return !!characterBefore && (!blockText.startsWith('(') || !blockText.endsWith(')'));\n}\n\nexport function dialogueDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC * Math.ceil(blockText.length / 36); // About 36 characters per line of dialogue fit\n}\n\nexport function dialogueData(characterBefore: string, blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainDialogue]: true,\n    [character]: characterBefore,\n    [durationSecContribution]: dialogueDurationSec(blockText)\n  }\n}\n\n/**\n * Component to show Fountain dialogue in DraftJS.\n *\n */\nexport const FountainDialogueComponent = (props: any) => {\n  return (\n      <div style={{marginLeft: '6em', width: '23.5em'}} >{props.children}</div>\n  );\n}\n\nclass FountainDialogueReadOnlyClassComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainDialogueComponent(this.props);\n  }\n}\n\nexport const FountainDialogueReadOnlyComponent = (props: any) => {\n  let isFilterSelected = false;\n  let characterFilter = useAppSelector(readHeaderOptions).currentCharacterFilter;\n\n  const contentState = props.contentState as ContentState;\n  const data = contentState.getBlockMap().get(props.blockKey).getData();\n  if (characterFilter === data.get(character)) {\n    isFilterSelected = true;\n  }\n\n  return (\n      <FountainDialogueReadOnlyClassComponent\n          blockKey={props.blockKey}\n          contentState={props.contentState}\n          isFilterSelected={isFilterSelected}\n          key={props.key}\n          children={props.children} />\n  );\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {character, durationSecContribution, isFountainParenthetical, ONE_LINE_DURATION_SEC} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\nimport {useAppSelector} from '../../app/hooks';\nimport {readHeaderOptions} from '../revision-header/headerOptionsSlice';\n\nexport function fountainParentheticalStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainParenthetical)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsParenthetical(characterBefore: string, blockText: string): boolean {\n  return !!characterBefore && blockText.startsWith('(') && blockText.endsWith(')');\n}\n\nexport function parentheticalDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC * Math.ceil(blockText.length / 30); // About 30 characters per line\n}\n\nexport function parentheticalData(characterBefore: string, blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainParenthetical]: true,\n    [character]: characterBefore,\n    [durationSecContribution]: parentheticalDurationSec(blockText)\n  }\n}\n\n/**\n * Component to show Fountain parenthetical in DraftJS.\n *\n */\nexport const FountainParentheticalComponent = (props: any) => {\n  return (\n      <div style={{marginLeft: '8.5em', width: '19.5em'}} >{props.children}</div>\n  );\n}\n\nclass FountainParentheticalReadOnlyClassComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainParentheticalComponent(this.props);\n  }\n}\n\nexport const FountainParentheticalReadOnlyComponent = (props: any) => {\n  let isFilterSelected = false;\n  let characterFilter = useAppSelector(readHeaderOptions).currentCharacterFilter;\n\n  const contentState = props.contentState as ContentState;\n  const data = contentState.getBlockMap().get(props.blockKey).getData();\n  if (characterFilter === data.get(character)) {\n    isFilterSelected = true;\n  }\n\n  return (\n      <FountainParentheticalReadOnlyClassComponent\n          blockKey={props.blockKey}\n          contentState={props.contentState}\n          isFilterSelected={isFilterSelected}\n          key={props.key}\n          children={props.children} />\n  );\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isFountainAction, ONE_LINE_DURATION_SEC, PAGE_WIDTH_EM} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\nexport function fountainActionStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainAction)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function actionDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC * Math.ceil(blockText.length / 56); // About 56 characters per line of action\n}\n\nexport function actionData(blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainAction]: true,\n    [durationSecContribution]: actionDurationSec(blockText),\n  }\n}\n\n/**\n * Component to show a Fountain action line in DraftJS.\n *\n */\nexport const FountainActionComponent = (props: any) => {\n  return (\n      <div style={{width: PAGE_WIDTH_EM}} >{props.children}</div>\n  );\n}\n\nexport class FountainActionReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainActionComponent(this.props);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isScrapPlaceholder, ONE_LINE_DURATION_SEC, pendingDurationSecContribution, scrapPlaceholderDurationSecField, scrapPlaceholderText} from './usefulConstants';\nimport {durationSecondsToString, durationStringToSeconds} from '../utils/durationUtils';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\nexport function scrapPlaceholderStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isScrapPlaceholder)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsScrapPlaceholder(blockText: string): boolean {\n  if (!blockText.startsWith('{{') || !blockText.endsWith('}}')) {\n    return false;\n  }\n\n  let splitText = blockText.split('|');\n  return splitText.length === 2;\n}\n\nexport function scrapPlaceholderData(blockText: string): { [index: string]: boolean|string|number} {\n  const content = blockText.replace('{{', '').replace('}}', '').trim().split('|');\n\n  const placeholderText = content[0].trim();\n  let durationSec = 0;\n  try {\n    durationSec = durationStringToSeconds(content[1].trim());\n  } catch {}\n\n  return {\n    [scrapPlaceholderText]: placeholderText,\n    [scrapPlaceholderDurationSecField]: durationSec,\n    [isScrapPlaceholder]: true,\n    [durationSecContribution]: scrapPlaceholderDurationSec(blockText),\n    [pendingDurationSecContribution]: scrapPlaceholderDurationSec(blockText),\n  }\n}\n\nexport function scrapPlaceholderDurationSec(blockText: string): number {\n  const content = blockText.replace('{{', '').replace('}}', '').trim();\n\n  try {\n    let durationStr = content.split('|')[1].trim();\n    return durationStringToSeconds(durationStr);\n  } catch {\n    // Invalid duration string\n  }\n\n  return 0;\n}\n\nexport const ScrapPlaceholderComponent = (props: any) => {\n  return <div\n      style={{\n        background: '#050',\n        color: 'white',\n        display: 'flex',\n        padding: '8px'\n      }}\n  >\n    <div style={{flex: 1}}>{props.children}</div>\n  </div>\n}\n\n\nexport class ScrapPlaceholderReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    const contentState = this.props.contentState as ContentState;\n    const data = contentState.getBlockMap().get(this.props.blockKey).getData();\n    const placeholderText = data.get(scrapPlaceholderText);\n    const durationSec = data.get(scrapPlaceholderDurationSecField);\n\n    const displayText = `${placeholderText}: ${durationSecondsToString(durationSec)}`;\n    const linesOfText = Math.ceil(displayText.length / 60) + 4; // 40px margin top/bottom\n    const numberOfLines = Math.ceil(durationSec / ONE_LINE_DURATION_SEC);\n    const heightStyle = `${20 * numberOfLines}px`;\n    // line = 20px\n\n    const numberOfInstances = Math.ceil(0.01 + numberOfLines / linesOfText);\n\n    return <div style={{\n      height: heightStyle,\n      background: '#afa',\n      overflow: 'hidden',\n      position: 'relative'\n    }}\n      >{Array(numberOfInstances).fill(0).map(() => {\n          return <div style={{display: 'block', padding: '40px 0'}}>{displayText}</div>\n        })}\n      <div style={{\n        position: 'absolute',\n        bottom: 0,\n        width: '100%',\n        height: '40px',\n        background: 'linear-gradient(180deg, transparent 0%, #afa 100%)',\n        zIndex: 1,\n      }}>\n        &nbsp;\n      </div>\n    </div>\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {isScrapTrait, scrapTraitText} from './usefulConstants';\nimport React from 'react';\n\nexport function scrapTraitStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isScrapTrait)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsScrapTrait(blockText: string): boolean {\n  if (!blockText.startsWith('{{') || !blockText.endsWith('}}')) {\n    return false;\n  }\n\n  return blockText.includes('#');\n}\n\nexport function scrapTraitData(blockText: string): { [index: string]: boolean|string|number} {\n  const content = blockText.replace('{{', '').replace('}}', '').trim();\n\n  return {\n    [scrapTraitText]: content,\n    [isScrapTrait]: true,\n  }\n}\n\nexport const ScrapTraitComponent = (props: any) => {\n  return <div\n      style={{\n        background: '#c00',\n        color: 'white',\n        display: 'flex',\n        padding: '8px'\n      }}\n  >\n    <div style={{flex: 1}}>{props.children}</div>\n  </div>\n}\n\nexport const ScrapTraitReadonlyComponent = (props: any) => {\n  return null; // Hide\n}\n","import {CharacterMetadata, ContentBlock, ContentState} from 'draft-js';\nimport Immutable from 'immutable';\nimport {ScrapMap} from '../scrapList/scrapListSlice';\nimport {Scrap} from '../../protos_v2';\nimport {character, durationSecContribution, isBlank, isComment, isCommentEnd, isCommentStart, mergeDataObject, ONE_LINE_DURATION_SEC, scrapLink} from './usefulConstants';\nimport {checkIsSceneHeader, sceneHeaderData, sceneHeaderDurationSec} from './FountainHeaderComponent';\nimport {checkIsScrapEmbed, scrapEmbedData} from './ScrapEmbedComponent';\nimport {checkIsSceneTransition, sceneTransitionData, sceneTransitionDurationSec} from './FountainTransitionComponent';\nimport {checkIsCentered, sceneCenteredData, sceneCenteredDurationSec} from './FountainCenteredComponent';\nimport {checkIsCommentEnd, checkIsCommentStart} from './CommentComponent';\nimport {characterData, characterDurationSec, checkIsCharacter} from './FountainCharacterComponent';\nimport {checkIsDialogue, dialogueData, dialogueDurationSec} from './FountainDialogueComponent';\nimport {checkIsParenthetical, parentheticalData, parentheticalDurationSec} from './FountainParentheticalComponent';\nimport {actionData, actionDurationSec} from './FountainActionComponent';\nimport {checkIsScrapPlaceholder, scrapPlaceholderData, scrapPlaceholderDurationSec} from './ScrapPlaceholderComponent';\nimport {checkIsScrapTrait, scrapTraitData} from './ScrapTraitComponent';\n\nexport interface ProcessProgress {\n  processStartEpoch: number;\n  currentDurationSec: number;\n  childScraps: Immutable.OrderedSet<string>;\n}\n\ninterface ProcessUpdate {\n  processProgress: ProcessProgress;\n  contentBlock: ContentBlock;\n}\n\n\nfunction applyStyles(character: CharacterMetadata, styles: Immutable.OrderedSet<string>): CharacterMetadata {\n  return (character as any).set('style', styles) as CharacterMetadata;\n}\n\nexport function isArrayEqualToImmutableSet(set: Immutable.OrderedSet<string>, array: string[]): boolean {\n  if (set.size !== array.length) {\n    return false;\n  }\n\n  for (let i = 0; i < array.length; i++) {\n    if (!set.includes(array[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Process each content block, resetting the blockData and conditionally setting a flag for if the block\n// is blank or not. This function needs to be able to operate on each contentBlock independent of all the rest\nexport function preProcessProseBlock(contentBlock: ContentBlock): ContentBlock {\n  if (!contentBlock) {\n    return contentBlock;\n  }\n\n  let blockData: { [index: string]: boolean|string} = {};\n  let blockText = contentBlock.getText().trim();\n\n  if (!blockText.length) {\n    blockData[isBlank] = true;\n  } else {\n    if (checkIsCommentStart(blockText)) {\n      blockData[isCommentStart] = true;\n    }\n    if (checkIsCommentEnd(blockText)) {\n      blockData[isCommentEnd] = true;\n    }\n  }\n\n  return contentBlock.set('data', Immutable.fromJS(blockData)) as ContentBlock;\n}\n\nexport function processProseBlock(contentBlock: ContentBlock, blockBefore: null|ContentBlock, blockAfter: null|ContentBlock, processProgress: ProcessProgress, scrapMap: ScrapMap): ProcessUpdate {\n  if (!contentBlock) {\n    return {\n      processProgress: processProgress,\n      contentBlock: contentBlock\n    };\n  }\n\n  let blockData: { [index: string]: boolean|string|number} = contentBlock.getData().toJS();\n  let applyCharacterStyles = true;\n\n  let blockText = contentBlock.getText().trim();\n\n  const blankBefore: boolean = !!blockBefore ? blockBefore.getData().get(isBlank) : true;\n  const blankAfter: boolean = !!blockAfter ? blockAfter.getData().get(isBlank) : true;\n  const characterBefore: string = !!blockBefore ? (blockBefore.getData().get(character) || '') : '';\n\n  if (blockData[isBlank]) {\n    if (!blankBefore && !blockData[isComment]) { // We only want to count 1 contiguous block of \"blank\", since we remove redundant whitespace\n      processProgress.currentDurationSec += ONE_LINE_DURATION_SEC; // Assume one line of whitespace\n      blockData = mergeDataObject(blockData, {\n        [durationSecContribution]: ONE_LINE_DURATION_SEC\n      });\n    }\n  } else {\n    if (!blockData[isComment]) {\n      if (checkIsSceneHeader(blankBefore, blankAfter, blockText)) {\n        /** Scene header */\n        blockData = mergeDataObject(blockData, sceneHeaderData(blockText));\n\n        processProgress.currentDurationSec += sceneHeaderDurationSec(blockText);\n      } else if (checkIsSceneTransition(blankBefore, blankAfter, blockText)) {\n        /** Scene transition */\n        blockData = mergeDataObject(blockData, sceneTransitionData(blockText));\n\n        processProgress.currentDurationSec += sceneTransitionDurationSec(blockText);\n      } else if (checkIsCentered(blockText)) {\n        /** Centered action */\n        blockData = mergeDataObject(blockData, sceneCenteredData(blockText));\n\n        processProgress.currentDurationSec += sceneCenteredDurationSec(blockText);\n      } else if (checkIsCharacter(blankBefore, blankAfter, blockText)) {\n        /** Character */\n        blockData = mergeDataObject(blockData, characterData(blockText));\n\n        processProgress.currentDurationSec += characterDurationSec(blockText);\n      } else if (checkIsDialogue(characterBefore, blockText)) {\n        /** Dialogue */\n        blockData = mergeDataObject(blockData, dialogueData(characterBefore, blockText));\n\n        processProgress.currentDurationSec += dialogueDurationSec(blockText);\n      }\n      else if (checkIsParenthetical(characterBefore, blockText)) {\n        /** Parenthetical */\n        blockData = mergeDataObject(blockData, parentheticalData(characterBefore, blockText));\n\n        processProgress.currentDurationSec += parentheticalDurationSec(blockText);\n      } else if (checkIsScrapPlaceholder(blockText)) {\n        /** Scrap placeholder (for scrap that doesn't exist yet, for structure planning) */\n        blockData = mergeDataObject(blockData, scrapPlaceholderData(blockText));\n\n        processProgress.currentDurationSec += scrapPlaceholderDurationSec(blockText);\n      } else if (checkIsScrapTrait(blockText)) {\n      /** Scrap trait (for adding binary labels on scraps, for tracking / reporting) */\n      blockData = mergeDataObject(blockData, scrapTraitData(blockText));\n    } else if (!checkIsScrapEmbed(blockText)) {\n        /** Action */\n        blockData = mergeDataObject(blockData, actionData(blockText));\n\n        processProgress.currentDurationSec += actionDurationSec(blockText);\n      }\n    }\n\n    if (checkIsScrapEmbed(blockText)) {\n      /** Scrap link embedded in prose */\n      blockData = mergeDataObject(blockData, scrapEmbedData(blockText));\n\n      const scrapId = blockData[scrapLink] as string;\n\n      if (!!scrapMap[scrapId]) {\n        processProgress.childScraps = processProgress.childScraps.add(scrapId);\n\n        const childScrap = scrapMap[scrapId] as Scrap;\n\n        if (!blockData[isComment]) {\n          processProgress.currentDurationSec += childScrap.intendedDurationSec;\n        }\n      }\n    }\n  }\n\n  const updatedBlock = contentBlock.set('data', Immutable.fromJS(blockData)) as ContentBlock;\n\n  applyCharacterStyles = false;\n\n  const updatedCharacterList = updatedBlock.getCharacterList().map((c, idx) => {\n    if (!c || !applyCharacterStyles) { return c; }\n\n\n    // @ts-ignore\n    if (idx < 5) {\n      return applyStyles(c, Immutable.OrderedSet.of('BOLD', 'GREEN'));\n    } else {\n      return applyStyles(c, Immutable.OrderedSet());\n    }\n  });\n\n  const finalBlockUpdate = updatedBlock.set('characterList', updatedCharacterList) as ContentBlock;\n\n  return {\n    contentBlock: finalBlockUpdate,\n    processProgress: processProgress,\n  }\n}\n\ninterface ParsedProseResult {\n  contentState: ContentState;\n  totalDurationSec: number;\n  childScraps: Immutable.OrderedSet<string>;\n  showTimeoutWarning: boolean;\n}\n\nexport function parseAllProse(contentState: ContentState, scrapMap: ScrapMap, warnParsingThreshold: number, errorParsingThreshold: number): ParsedProseResult {\n\n  let newParseErrorState = false;\n\n  let processProgress = {\n    processStartEpoch: Date.now(),\n    currentDurationSec: 0,\n    childScraps: Immutable.OrderedSet<string>()\n  } as ProcessProgress;\n\n  let currentBlockMap = contentState.getBlockMap();\n  // @ts-ignore\n  const blockKeys = [ ...currentBlockMap.keys()];\n\n  for (let i = 0; i < blockKeys.length; i++) {\n    const nextKey = blockKeys[i];\n    currentBlockMap = currentBlockMap.set(nextKey, preProcessProseBlock(currentBlockMap.get(nextKey)));\n\n    const timeSoFar = Date.now() - processProgress.processStartEpoch;\n    if (timeSoFar > warnParsingThreshold) {\n      newParseErrorState = true;\n    }\n    if (timeSoFar > errorParsingThreshold) {\n      break;\n    }\n  }\n\n  // Mark all comment blocks as such\n  let currentlyInComment = false;\n  for (let i = 0; i < blockKeys.length; i++) {\n    const nextKey = blockKeys[i];\n    const blockData = currentBlockMap.get(nextKey).getData().toJS();\n    if (blockData[isCommentStart]) {\n      currentlyInComment = true;\n    }\n\n    if (currentlyInComment) {\n      const currentBlock = currentBlockMap.get(nextKey);\n\n      blockData[isComment] = true;\n      const updatedData = Immutable.fromJS(blockData);\n\n      const updatedBlock = currentBlock.set('data', updatedData) as ContentBlock;\n      currentBlockMap = currentBlockMap.set(nextKey, updatedBlock);\n    }\n\n    if (blockData[isCommentEnd]) {\n      currentlyInComment = false;\n    }\n    const timeSoFar = Date.now() - processProgress.processStartEpoch;\n    if (timeSoFar > warnParsingThreshold) {\n      newParseErrorState = true;\n    }\n    if (timeSoFar > errorParsingThreshold) {\n      break;\n    }\n  }\n\n  for (let i = 0; i < blockKeys.length; i++) {\n    const blockBefore = i > 0 ? currentBlockMap.get(blockKeys[i - 1]) : null;\n    const nextKey = blockKeys[i];\n    const blockAfter = i + 1 < blockKeys.length ? currentBlockMap.get(blockKeys[i + 1]) : null;\n\n    const update = processProseBlock(currentBlockMap.get(nextKey), blockBefore, blockAfter, processProgress, scrapMap);\n\n    processProgress = update.processProgress;\n\n    currentBlockMap = currentBlockMap.set(nextKey, update.contentBlock);\n    const timeSoFar = Date.now() - processProgress.processStartEpoch;\n    if (timeSoFar > warnParsingThreshold) {\n      newParseErrorState = true;\n    }\n    if (timeSoFar > errorParsingThreshold) {\n      break;\n    }\n  }\n\n  const newContent = contentState.set('blockMap', currentBlockMap) as ContentState;\n\n  const durationMs = Date.now() - processProgress.processStartEpoch;\n  console.log('Update took: ' + durationMs);\n\n  return {\n    contentState: newContent,\n    totalDurationSec: processProgress.currentDurationSec,\n    childScraps: processProgress.childScraps,\n    showTimeoutWarning: newParseErrorState\n  };\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {isComment, isScrapEmbedding, PAGE_WIDTH_EM} from './usefulConstants';\nimport React from 'react';\n\n\nexport function commentStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isComment) && !contentBlock.getData().get(isScrapEmbedding)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsCommentStart(blockText: string): boolean {\n  return blockText.startsWith('/*');\n}\n\n\nexport function checkIsCommentEnd(blockText: string): boolean {\n  return blockText.endsWith('*/');\n}\n\n/**\n * Component to show a block component element in DraftJS.\n *\n */\nexport const CommentComponent = (props: any) => {\n  return (\n      <div style={{fontStyle: 'italic', background: '#cfead9', width: PAGE_WIDTH_EM}}>{props.children}</div>\n  );\n}\n","import {CompositeDecorator} from 'draft-js';\nimport {ScrapEmbedComponent, scrapEmbeddingStrategy} from './ScrapEmbedComponent';\nimport {FountainHeaderComponent, FountainHeaderReadOnlyComponent, fountainHeaderStrategy} from './FountainHeaderComponent';\nimport {FountainTransitionComponent, FountainTransitionReadOnlyComponent, fountainTransitionStrategy} from './FountainTransitionComponent';\nimport {FountainCenteredComponent, FountainCenteredReadOnlyComponent, fountainCenteredStrategy} from './FountainCenteredComponent';\nimport {FountainCharacterComponent, FountainCharacterReadOnlyComponent, fountainCharacterStrategy} from './FountainCharacterComponent';\nimport {FountainDialogueComponent, FountainDialogueReadOnlyComponent, fountainDialogueStrategy} from './FountainDialogueComponent';\nimport {FountainParentheticalComponent, FountainParentheticalReadOnlyComponent, fountainParentheticalStrategy} from './FountainParentheticalComponent';\nimport {CommentComponent, commentStrategy} from './CommentComponent';\nimport {FountainActionComponent, FountainActionReadOnlyComponent, fountainActionStrategy} from './FountainActionComponent';\nimport {ScrapPlaceholderComponent, ScrapPlaceholderReadOnlyComponent, scrapPlaceholderStrategy} from './ScrapPlaceholderComponent';\nimport {ScrapTraitComponent, ScrapTraitReadonlyComponent, scrapTraitStrategy} from './ScrapTraitComponent';\n\n/** Decorator for the script editor */\nexport const editorDecorator = new CompositeDecorator([\n  {\n    strategy: scrapPlaceholderStrategy,\n    component: ScrapPlaceholderComponent,\n  },\n  {\n    strategy: scrapTraitStrategy,\n    component: ScrapTraitComponent,\n  },\n  {\n    strategy: scrapEmbeddingStrategy,\n    component: ScrapEmbedComponent,\n  },\n  {\n    strategy: fountainHeaderStrategy,\n    component: FountainHeaderComponent,\n  },\n  {\n    strategy: fountainTransitionStrategy,\n    component: FountainTransitionComponent,\n  },\n  {\n    strategy: fountainCenteredStrategy,\n    component: FountainCenteredComponent,\n  },\n  {\n    strategy: fountainCharacterStrategy,\n    component: FountainCharacterComponent,\n  },\n  {\n    strategy: fountainDialogueStrategy,\n    component: FountainDialogueComponent,\n  },\n  {\n    strategy: fountainParentheticalStrategy,\n    component: FountainParentheticalComponent,\n  },\n  {\n    strategy: commentStrategy,\n    component: CommentComponent,\n  },\n  {\n    strategy: fountainActionStrategy,\n    component: FountainActionComponent,\n  },\n]);\n\n/** Decorator for the script viewer (read-only) */\nexport const viewerDecorator = new CompositeDecorator([\n  {\n    strategy: scrapPlaceholderStrategy,\n    component: ScrapPlaceholderReadOnlyComponent,\n  },\n  {\n    strategy: scrapTraitStrategy,\n    component: ScrapTraitReadonlyComponent,\n  },\n  {\n    strategy: fountainHeaderStrategy,\n    component: FountainHeaderReadOnlyComponent,\n  },\n  {\n    strategy: fountainTransitionStrategy,\n    component: FountainTransitionReadOnlyComponent,\n  },\n  {\n    strategy: fountainCenteredStrategy,\n    component: FountainCenteredReadOnlyComponent,\n  },\n  {\n    strategy: fountainCharacterStrategy,\n    component: FountainCharacterReadOnlyComponent,\n  },\n  {\n    strategy: fountainDialogueStrategy,\n    component: FountainDialogueReadOnlyComponent,\n  },\n  {\n    strategy: fountainParentheticalStrategy,\n    component: FountainParentheticalReadOnlyComponent,\n  },\n  {\n    strategy: fountainActionStrategy,\n    component: FountainActionReadOnlyComponent,\n  },\n]);\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport React, {Component, ReactElement} from 'react';\nimport * as clipboard from \"clipboard-polyfill/text\";\nimport {Editor, EditorState, ContentState, Modifier} from 'draft-js';\n// @ts-ignore\nimport getFragmentFromSelection from 'draft-js/lib/getFragmentFromSelection';\nimport 'draft-js/dist/Draft.css';\nimport {Scrap} from '../../protos_v2';\nimport {Breadcrumb, BreadcrumbDivider, BreadcrumbSection, Button, Form, Segment} from 'semantic-ui-react';\nimport {\n  Link\n} from 'react-router-dom';\nimport { v4 as uuid } from 'uuid';\nimport debounce from 'debounce';\nimport {createChildScrap} from './ScrapEmbedComponent';\nimport {durationSecondsToString, durationStringToSeconds} from '../utils/durationUtils';\nimport {isArrayEqualToImmutableSet, parseAllProse} from './parseProse';\nimport {editorDecorator} from './foutainDecorators';\nimport {FOUNTAIN_EDITOR_STYLE} from './usefulConstants';\nimport {HeaderOptions} from '../revision-header/headerOptionsSlice';\n\ninterface ScrapDetailsProps {\n  scrapId: string;\n  scrapMap: ScrapMap;\n  onScrapCreate: (scrap: Scrap) => void;\n  onScrapUpdate: (scrap: Scrap) => void;\n  headerOptions: HeaderOptions;\n  onUpdateHeaderOptions: (headerOptions: HeaderOptions) => void;\n}\n\ninterface ScrapDetailsState {\n  editorState: EditorState;\n  lastEmittedStr: string;\n  scrapId: string;\n  durationErrorString: string|null;\n  parseErrorState: boolean;\n  actualDurationSec: number;\n  parentScrapIds: string[];\n  durationInputKey: string;\n  focusMode: boolean;\n}\n\nconst styleMap = {\n  'GREEN': {\n    color: 'green'\n  },\n}\n\nexport default class ScrapDetails extends Component<ScrapDetailsProps, ScrapDetailsState> {\n  domEditor: any;\n\n  constructor(props: ScrapDetailsProps) {\n    super(props);\n\n    this.state = this.initializeState(props);\n    this.remapEditorContent();\n  }\n\n  initializeState(props: ScrapDetailsProps): ScrapDetailsState {\n    return {\n      editorState: this.buildInitialEditorState(props),\n      lastEmittedStr: '',\n      scrapId: props.scrapId,\n      durationErrorString: null,\n      actualDurationSec: 0,\n      parentScrapIds: this.buildParentScrapIds(props),\n      parseErrorState: false,\n      durationInputKey: 'duration-key-' + Date.now(),\n      focusMode: false,\n    };\n  }\n\n  setHeaderOptions(): void {\n    this.props.onUpdateHeaderOptions({\n      ...this.props.headerOptions,\n      currentScrapId: this.props.scrapId,\n      showReadLink: true,\n      showEditLink: false,\n      characterFilters: [],\n      currentCharacterFilter: '',\n      currentCompletionFilter: '',\n      traitFilters: [],\n      currentTraitFilter: '',\n    });\n  }\n\n  buildInitialEditorState(props: ScrapDetailsProps): EditorState {\n    let thisScrap = props.scrapMap[props.scrapId];\n\n    if (!thisScrap) {\n      return EditorState.createEmpty();\n    }\n\n    return EditorState.createWithContent(ContentState.createFromText(thisScrap.prose), editorDecorator)\n  }\n\n  componentDidMount() {\n    this.setHeaderOptions();\n  }\n\n  componentDidUpdate(prevProps: Readonly<ScrapDetailsProps>, prevState: Readonly<ScrapDetailsState>, snapshot?: any) {\n    if (this.state.scrapId === this.props.scrapId) {\n      return;\n    }\n\n    // Need to update\n    this.setHeaderOptions();\n    this.setState(this.initializeState(this.props));\n    this.remapEditorContent();\n  }\n\n  buildParentScrapIds(props: ScrapDetailsProps): string[] {\n    const thisScrap = props.scrapMap[this.props.scrapId];\n    const parentScraps = [];\n    for (let key in props.scrapMap) {\n      const scrap = props.scrapMap[key] as Scrap;\n      if (scrap.childScraps.includes(thisScrap.id)) {\n        parentScraps.push(scrap.id);\n      }\n    }\n\n    return parentScraps;\n  }\n\n  getBreadcrumbs(): ReactElement {\n    const parentScraps = this.state.parentScrapIds.map((scrapId) => {\n        return this.props.scrapMap[scrapId];\n      }).filter(Boolean);\n\n    const parentScrapLinks = parentScraps.map<React.ReactNode>(((parentScrap: Scrap) => {\n      return (<BreadcrumbSection link>\n        <Link to={'/scrap/' + parentScrap.id}>{parentScrap.synopsis}</Link>\n      </BreadcrumbSection>)\n    }));\n\n    let scrapContribution;\n    if (parentScraps.length) {\n      scrapContribution = (<div>Scraps:\n        <Breadcrumb>\n          {\n            parentScrapLinks.reduce((prev, curr) => [prev, <BreadcrumbDivider icon='right chevron' />, curr])\n          }\n        </Breadcrumb>\n      </div>);\n    } else {\n      scrapContribution = (<div>No parent scraps</div>);\n    }\n\n    return (<div>\n      {scrapContribution}\n    </div>);\n  }\n\n  onSynopsisChange(newSynopsis: string) {\n    const scrap = this.props.scrapMap[this.props.scrapId] as Scrap;\n\n    scrap.synopsis = newSynopsis;\n    this.props.onScrapUpdate(scrap);\n  }\n\n  getPrimaryForm(thisScrap: Scrap): ReactElement {\n    return <Segment>\n      <Form>\n        <div style={{display: 'flex'}}>\n          <div style={{flex: 1, margin: '16px 0'}}>\n            <Form.Input\n                label='Synopsis'\n                defaultValue={thisScrap.synopsis}\n                onChange={(e) => this.onSynopsisChange(e.target.value)}\n            />\n          </div>\n          <div style={{flex: 1, margin: '16px'}}>\n            <Form.Input\n                key={this.state.durationInputKey}\n                style={{flex: 1}}\n                label='Intended Duration (HH:MM:SS)'\n                defaultValue={durationSecondsToString(thisScrap.intendedDurationSec)}\n                error={this.state.durationErrorString}\n                onChange={(e) => this.onDurationChange(e.target.value)}\n            />\n          </div>\n          <div style={{flex: 1, margin: 'auto'}}>\n            <Form.Field>\n              <label>\n                Current Actual Duration: {durationSecondsToString(this.state.actualDurationSec)}\n              </label>\n              <Button\n                  onClick={() => this.updateExpectedDurationSec()}\n                  disabled={this.state.actualDurationSec === thisScrap.intendedDurationSec}\n              >\n                Update expected duration\n              </Button>\n            </Form.Field>\n          </div>\n\n        </div>\n      </Form>\n    </Segment>\n  }\n\n  onDurationChange(newDuration: string) {\n    let durationSec;\n    try {\n      durationSec = durationStringToSeconds(newDuration);\n    } catch {\n      return this.setDurationErrorString(true);\n    }\n\n    const scrap = this.props.scrapMap[this.props.scrapId] as Scrap;\n\n    scrap.intendedDurationSec = durationSec;\n    this.props.onScrapUpdate(scrap);\n    this.setDurationErrorString(false);\n  }\n\n  setDurationErrorString(hasError: boolean) {\n    this.setState({\n      durationErrorString: hasError ? 'Please enter a duration of format HH:MM:SS' : null\n    });\n  }\n\n  updateExpectedDurationSec(): void {\n    const scrap = this.props.scrapMap[this.props.scrapId] as Scrap;\n\n    scrap.intendedDurationSec = this.state.actualDurationSec;\n    this.props.onScrapUpdate(scrap);\n    this.setState({\n      durationInputKey: 'duration-key-' + Date.now()\n    });\n    this.setDurationErrorString(false);\n  }\n\n  getProseEditorToolbar(): ReactElement {\n    const parseWarning = this.state.parseErrorState ?\n        (<div style={{color: 'red'}}>Parsing took too long, please break into smaller chunks</div>) : null;\n\n    const focusLabel = this.state.focusMode ? 'Focus Off' : 'Focus On';\n\n    const actualDurationSec = this.state.actualDurationSec;\n    const intendedDurationSec = this.props.scrapMap[this.props.scrapId].intendedDurationSec;\n    let durationPercentLabel = `${Math.ceil(1000 * actualDurationSec / intendedDurationSec) / 10}% Complete`;\n\n    return <div>\n      <div style={{display: 'flex'}}>\n        <button onClick={() => this.addChildScrap()}>Add child scrap</button>\n        <button onClick={() => this.replacePlaceholderScraps()}>Replace placeholder scraps</button>\n        <span style={{flex: 1}}>&nbsp;</span>\n        <span style={{margin: 'auto 24px'}}>{durationPercentLabel}</span>\n        <button onClick={() => { this.toggleFocusMode() }}>{focusLabel}</button>\n      </div>\n      {parseWarning}\n    </div>;\n  }\n\n  setDomEditorRef(ref: any) {\n    this.domEditor = ref;\n  }\n\n  focus(): void {\n    this.domEditor.focus();\n  }\n\n  onProseChange(newState: EditorState): void {\n    this.setState({editorState: newState});\n\n    this.remapEditorContent(); // Restyle, but only after things settle down a bit\n  }\n\n  getSelectedText(): string {\n    const editorState = this.state.editorState;\n    const selected = getFragmentFromSelection(editorState);\n    return (selected ? selected.map((x: { getText: () => any; }) => x.getText()).join('\\n') : '') as string;\n  }\n\n  onCut(editor: Editor, e: any, removeWhenDone: boolean): void {\n    e.preventDefault();\n\n    const editorState = this.state.editorState;\n    const selectedText = this.getSelectedText();\n    clipboard.writeText(selectedText).then(() => {\n      if (!removeWhenDone) {\n        return;\n      }\n\n      const newContentState = Modifier.replaceText(\n          editorState.getCurrentContent(),\n          editorState.getSelection(),\n          ''\n      );\n\n      this.setState({editorState: EditorState.set(editorState, {currentContent: newContentState})});\n    });\n  }\n\n  persistProse(newProseStr: string): void {\n    const scrap = this.props.scrapMap[this.props.scrapId] as Scrap;\n\n    scrap.prose = newProseStr;\n    this.props.onScrapUpdate(scrap);\n  }\n\n  remapEditorContent = debounce(() => {\n    const newStrToEmit = this.state.editorState.getCurrentContent().getPlainText();\n\n    if (newStrToEmit === this.state.lastEmittedStr) {\n      return; // No need to update\n    }\n\n    this.persistProse(newStrToEmit);\n\n    const parseResult = parseAllProse(this.state.editorState.getCurrentContent(), this.props.scrapMap,50, 500);\n\n    // Check to see if we need to update the scrap b/c the references to child scraps changed\n    const thisScrap = this.props.scrapMap[this.props.scrapId];\n\n    if (!isArrayEqualToImmutableSet(parseResult.childScraps, thisScrap.childScraps)) {\n      const newScrap = Scrap.create({\n        ...thisScrap,\n        childScraps: [ ...(parseResult.childScraps.toArray()) ]\n      });\n\n      this.props.onScrapUpdate(newScrap);\n    }\n\n    this.setState({\n      editorState: EditorState.set(this.state.editorState, {currentContent: parseResult.contentState}),\n      lastEmittedStr: newStrToEmit,\n      actualDurationSec: Math.round(parseResult.totalDurationSec),\n      parseErrorState: parseResult.showTimeoutWarning,\n    });\n  }, 200);\n\n  addChildScrap(): void {\n    const editorState = this.state.editorState;\n    const currentSelection = editorState.getSelection();\n\n    const currentlySelectedText = this.getSelectedText();\n\n    const newScrapId = uuid();\n\n    const newScrap = createChildScrap(this.props.scrapId, this.props.scrapMap, newScrapId);\n    if (!!currentlySelectedText.trim().length) {\n      newScrap.prose = currentlySelectedText;\n    }\n\n    this.props.onScrapCreate(newScrap);\n\n    const thingToInsert = '\\n{{' + newScrapId + '}}\\n';\n\n    const newContentState = currentSelection.isCollapsed() ?\n        Modifier.insertText(\n            editorState.getCurrentContent(),\n            currentSelection,\n            thingToInsert\n        ) : Modifier.replaceText(\n        editorState.getCurrentContent(),\n            currentSelection,\n        thingToInsert\n    );\n\n    this.setState({\n      editorState: EditorState.createWithContent(ContentState.createFromText(newContentState.getPlainText()), editorDecorator)\n    }, () => {\n      this.remapEditorContent();\n    });\n\n  }\n\n  replacePlaceholderScraps(): void {\n    const editorState = this.state.editorState;\n    const currentSelection = editorState.getSelection();\n\n    const currentlySelectedText = this.getSelectedText();\n    let textToSwap = currentlySelectedText;\n\n    let re = new RegExp('{{([^}]+)}}', 'g');\n    let match;\n    while (match = re.exec(currentlySelectedText)) {\n      const textToReplace = match[0];\n      const splitText = match[1].split('|');\n\n      if (splitText.length != 2) {\n        continue;\n      }\n\n      let intendedDurationSec = 0;\n      try {\n        intendedDurationSec = durationStringToSeconds(splitText[1].trim());\n      } catch {}\n\n      const newScrapId = uuid();\n\n      const newScrap = Scrap.create({\n        id: newScrapId,\n        synopsis: splitText[0].trim(),\n        prose: textToReplace,\n        intendedDurationSec: intendedDurationSec\n      });\n\n\n      this.props.onScrapCreate(newScrap);\n\n      textToSwap = textToSwap.replace(\n          textToReplace,\n          '\\n{{' + newScrapId + '}}\\n'\n      );\n    }\n\n    const newContentState = Modifier.replaceText(\n        editorState.getCurrentContent(),\n        currentSelection,\n        textToSwap\n    );\n\n    this.setState({\n      editorState: EditorState.createWithContent(ContentState.createFromText(newContentState.getPlainText()), editorDecorator)\n    }, () => {\n      this.remapEditorContent();\n    });\n  }\n\n  toggleFocusMode(): void {\n    this.setState({\n      focusMode: !this.state.focusMode\n    });\n  }\n\n\n  render() {\n    let thisScrap = this.props.scrapMap[this.props.scrapId];\n\n    if (!thisScrap) {\n      return (\n          <div>Whoops, could not find scrap</div>\n      );\n    }\n\n    let noFocusSection = null;\n    if (!this.state.focusMode) {\n      noFocusSection = <div>\n        {this.getBreadcrumbs()}\n        {this.getPrimaryForm(thisScrap)}\n      </div>\n    }\n\n    return (\n        <div style={{height: '100%', display: 'flex', flexDirection: 'column'}} key={'scrap-details-' + this.props.scrapId}>\n          {noFocusSection}\n          {this.getProseEditorToolbar()}\n          <div\n              onClick={() => {this.focus()}}\n              style={FOUNTAIN_EDITOR_STYLE}>\n            <Editor\n                customStyleMap={styleMap}\n                stripPastedStyles={true}\n                onCut={(editor, e) => {this.onCut(editor, e, true);}}\n                onCopy={(editor, e) => {this.onCut(editor, e, false);}}\n                editorState={this.state.editorState}\n                ref={(ref) => {this.setDomEditorRef(ref);}}\n                onChange={(newState) => {this.onProseChange(newState); }}/>\n          </div>\n        </div>\n    );\n  }\n\n}\n","import { RouteComponentProps } from 'react-router';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {createScrap, selectScrapMap, updateScrap} from '../../features/scrapList/scrapListSlice';\nimport ScrapDetails from '../../features/scrapDetails/ScrapDetails';\nimport {readHeaderOptions, updateHeaderOptions} from '../../features/revision-header/headerOptionsSlice';\n\ninterface MatchParams {\n  id: string\n}\n\ninterface ScrapDetailsProps extends RouteComponentProps<MatchParams> {}\n\nexport default function ScrapDetailsPage (props: ScrapDetailsProps) {\n  const scrapMap = useAppSelector(selectScrapMap);\n  const headerOptions = useAppSelector(readHeaderOptions);\n  const dispatch = useAppDispatch();\n\n  return (\n      <ScrapDetails\n          scrapId={props.match.params.id}\n          scrapMap={scrapMap}\n          onScrapCreate={(scrap) => dispatch(createScrap(scrap.toJSON()))}\n          onScrapUpdate={(scrap) => dispatch(updateScrap(scrap.toJSON()))}\n          headerOptions={headerOptions}\n          onUpdateHeaderOptions={(headerOptions) => dispatch(updateHeaderOptions(headerOptions))}\n      />\n  )\n}\n","import React, {Component, ReactElement} from 'react';\n\ntype Candidate = {\n  label: string;\n  description: string;\n  currentScore: number;\n  wins: number;\n  losses: number;\n}\n\ntype MyState = {\n  showListInput: boolean;\n  showCurrentScores: boolean;\n  nextCandidateLabel: string;\n  nextCandidateDesc: string;\n\n  candidates: Candidate[];\n  winMatrix: number[][];\n  candidateIndexA: number;\n  candidateIndexB: number;\n}\n\nexport default class DecisionPage extends Component<any, MyState> {\n\n\n  state: MyState = {\n    showListInput: true,\n    showCurrentScores: false,\n    nextCandidateLabel: '',\n    nextCandidateDesc: '',\n    candidates: [],\n    winMatrix: [],\n    candidateIndexA: -1,\n    candidateIndexB: -1,\n  };\n\n  addCandidate(): void {\n    let newCandidates = [...this.state.candidates, {\n      label: this.state.nextCandidateLabel,\n      description: this.state.nextCandidateDesc,\n      currentScore: 1,\n      wins: 0,\n      losses: 0,\n    } as Candidate];\n\n    let defaultValue = 1 / (10 * newCandidates.length);\n    let winMatrix = [...Array(newCandidates.length)].map(e => Array(newCandidates.length).fill(defaultValue)) as number[][];\n\n    for (let i = 0; i < winMatrix.length; i++) {\n      winMatrix[i][i] = 0;\n    }\n\n    this.setState({\n      ...this.state,\n      candidates: newCandidates,\n      winMatrix: winMatrix,\n      nextCandidateLabel: '',\n      nextCandidateDesc: '',\n    });\n  }\n\n  setupNewComparison(): void {\n    let indexAWeights = this.state.candidates.map((ignore, idx) => {\n      return 1 / this.getTotalComparisons(idx);\n    });\n\n    let indexA = this.randomSelectWeighted(indexAWeights);\n\n    let indexBWeights = indexAWeights.map((ignore, idx) => {\n      if (idx === indexA) {\n        return 0;\n      }\n\n      return 1 / (this.state.winMatrix[idx][indexA] + this.state.winMatrix[indexA][idx]);\n    });\n\n    let indexB = this.randomSelectWeighted(indexBWeights);\n\n    this.setState({\n      ...this.state,\n      showListInput: false,\n      candidateIndexA: indexA,\n      candidateIndexB: indexB,\n    })\n  }\n\n  randomSelectWeighted(weights: number[]): number {\n    let sumWeight = weights.reduce(((previousValue, currentValue) => previousValue + currentValue));\n\n    let randomCutoff = Math.random() * sumWeight;\n    let sum = 0;\n    for (let i = 0; i < weights.length; i++) {\n      sum += weights[i];\n      if (sum >= randomCutoff) {\n        return i;\n      }\n    }\n\n    throw Error('should not get here');\n  }\n\n  getTotalComparisons(index: number): number {\n    let totalComparisons = 0;\n    for (let i = 0; i < this.state.winMatrix.length; i++) {\n      totalComparisons += this.state.winMatrix[index][i] + this.state.winMatrix[i][index];\n    }\n\n    return totalComparisons;\n  }\n\n  renderComparison(): ReactElement {\n    if (this.state.candidateIndexA < 0 || this.state.candidateIndexB < 0) {\n      return (<div>no comparison yet</div>);\n    }\n\n    let candidateA = this.state.candidates[this.state.candidateIndexA];\n    let candidateB = this.state.candidates[this.state.candidateIndexB];\n\n    return (<div style={{marginTop: '100px', marginBottom: '100px'}}>\n      <h2>Comparison</h2>\n      <div style={{display: 'flex'}}>\n        <div style={{flex: 1}}>\n          <h3>{candidateA.label}\n            <button onClick={() => this.updateWin(this.state.candidateIndexA, this.state.candidateIndexB)}>Select</button>\n          </h3>\n          {candidateA.description.split('\\n').map(line => (<p>{line}</p>))}\n        </div>\n        <div style={{flex: 1}}>\n          <h3>{candidateB.label}\n            <button onClick={() => this.updateWin(this.state.candidateIndexB, this.state.candidateIndexA)}>Select</button>\n          </h3>\n          {candidateB.description.split('\\n').map(line => (<p>{line}</p>))}\n        </div>\n      </div>\n    </div>)\n  }\n\n  updateWin(winIndex: number, loseIndex: number): void {\n    let winMatrix = this.state.winMatrix;\n    winMatrix[winIndex][loseIndex] += 1;\n\n    let candidates = this.state.candidates;\n    candidates[winIndex].wins += 1;\n    candidates[loseIndex].losses += 1;\n\n    // Update all the scores\n    // Based on sloppy implementation of https://stats.stackexchange.com/questions/83005/how-to-calculate-ratings-rankings-from-paired-comparison-pairwise-comparison-o\n    for (let iteration = 0; iteration < 1000; iteration++) {\n      // Naive iteration for now\n\n      for (let i = 0; i < candidates.length; i++) {\n\n        let W_i = 0;\n        for (let j = 0; j < candidates.length; j++) {\n          W_i += winMatrix[i][j];\n        }\n\n        let denominator = 0;\n        for (let j = 0; j < candidates.length; j++) {\n          if (i !== j) {\n            let N_ij = winMatrix[i][j] + winMatrix[j][i];\n            denominator += (N_ij) / (candidates[i].currentScore + candidates[j].currentScore);\n          }\n        }\n\n        candidates[i].currentScore = W_i / denominator;\n      }\n\n      // Re-normalize\n      let averageValue = 0;\n      for (let i = 0; i < candidates.length; i++) {\n        averageValue += candidates[i].currentScore;\n      }\n      averageValue /= candidates.length;\n      for (let i = 0; i < candidates.length; i++) {\n        candidates[i].currentScore /= averageValue;\n      }\n    }\n\n\n\n    this.setState({\n      ...this.state,\n      candidates: candidates,\n      winMatrix: winMatrix\n    }, () => {\n      this.setupNewComparison();\n    });\n  }\n\n  renderWinMatrix(): ReactElement {\n    if (!this.state.showCurrentScores) {\n      return (<div></div>);\n    }\n\n    return (<div><h2>Current Win Matrix</h2><pre>\n      {this.state.winMatrix.map(line => {\n        return line.join(',\\t') + '\\n';\n      })}\n    </pre></div>)\n  }\n\n  renderCandidates(): ReactElement {\n    if (!this.state.showCurrentScores && !this.state.showListInput) {\n      return (<div></div>);\n    }\n\n    let sortedCandidates = this.state.candidates\n        .map((candidate) => candidate) // Cheap sort\n        .sort((a, b) => b.currentScore - a.currentScore);\n\n    return (<div>\n      <h2>{sortedCandidates.length} Candidates</h2>\n      {sortedCandidates.map((candidate, idx) => {\n        return (<div>\n          <h3>{candidate.label} ({candidate.currentScore}, {candidate.wins} wins, {candidate.losses} losses)</h3>\n        </div>);\n      })}\n    </div>);\n  }\n\n  toggleShowCurrentScores(): void {\n    this.setState(\n        {...this.state, showCurrentScores: !this.state.showCurrentScores}\n    );\n  }\n\n  updateNextCandidateLabel(newValue: string): void {\n    this.setState({\n      ...this.state,\n      nextCandidateLabel: newValue\n    });\n  }\n\n  updateNextCandidateDesc(newValue: string): void {\n    this.setState({\n      ...this.state,\n      nextCandidateDesc: newValue\n    });\n  }\n\n  render() {\n    let mainContent;\n    if (this.state.showListInput) {\n      mainContent = (\n        <div>\n          <h2>Declare Candidates</h2>\n          <p>\n            Let's create some candidates\n          </p>\n          <div>\n            <input\n                type='text'\n                value={this.state.nextCandidateLabel}\n                onChange={(e) => this.updateNextCandidateLabel(e.target.value)} />\n            <textarea\n                value={this.state.nextCandidateDesc}\n                onChange={(e) => this.updateNextCandidateDesc(e.target.value)}></textarea>\n          </div>\n\n          <button style={{display: 'block'}} onClick={() => this.addCandidate()}>Add Candidate</button>\n          <button style={{display: 'block'}} onClick={() => this.setupNewComparison()}>Parse and begin</button>\n          {this.renderCandidates()}\n        </div>\n      );\n    } else {\n      mainContent = (<div>\n        {this.renderComparison()}\n\n        <button style={{display: 'block'}} onClick={() => this.toggleShowCurrentScores()}>Toggle results</button>\n\n        {this.renderWinMatrix()}\n        {this.renderCandidates()}\n      </div>);\n    }\n\n    return (\n        <div style={{margin: '24px'}}>\n          <h1>Decisions</h1>\n          <p>\n            Let's make some decisions based on pairwise comparisons. You know that FaceMash scene in Social Network?\n            It's just like that, except hopefully you're using it for better decisions.\n          </p>\n          {mainContent}\n        </div>\n    );\n  }\n}\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport {ContentBlock, ContentState} from 'draft-js';\nimport {parseAllProse} from '../scrapDetails/parseProse';\nimport {ancestorField, isComment, isScrapEmbedding, scrapIdField, scrapLink} from '../scrapDetails/usefulConstants';\n\nexport function fetchParsedContentBlocksForScrap(scrapId: string, scrapAncestors: string[], scrapMap: ScrapMap): Array<ContentBlock> {\n  let prose = scrapMap[scrapId]?.prose || '';\n\n  let newAncestors = [...scrapAncestors, scrapId];\n\n  const initialContentState = ContentState.createFromText(prose);\n\n  const parseResult = parseAllProse(initialContentState, scrapMap, 500, 5000);\n\n  const allNewContentBlocks: Array<ContentBlock> = [];\n\n  parseResult.contentState.getBlocksAsArray().forEach((block) => {\n    const blockData = block.getData();\n\n    if (blockData.get(isComment)) {\n      // Skip\n      return;\n    }\n\n    if (!blockData.get(isScrapEmbedding)) {\n      // Simple addition, just append the ID of the scrap, and the ancestors at this point\n      let updatedBlock = block.set('data', blockData.set(scrapIdField, scrapId).set(ancestorField, scrapAncestors));\n\n      allNewContentBlocks.push(updatedBlock as ContentBlock);\n      return;\n    }\n\n    const embeddedScrapId = blockData.get(scrapLink);\n\n    if (!scrapMap[embeddedScrapId]) {\n      // Scrap doesn't exist, skip\n      return;\n    }\n\n    if (newAncestors.includes(embeddedScrapId)) {\n      throw Error(`Replacing scrap ${embeddedScrapId} would cause infinite recursion`);\n    }\n\n    const subBlocks = fetchParsedContentBlocksForScrap(embeddedScrapId, newAncestors, scrapMap);\n\n    allNewContentBlocks.push(...subBlocks);\n  });\n\n  return allNewContentBlocks;\n}\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport {TimelineBlock, TimelineRow} from './Timeline';\nimport {ancestorField, character, durationSecContribution, isScrapPlaceholder, pendingDurationSecContribution, scrapIdField, scrapTraitText} from '../scrapDetails/usefulConstants';\nimport {ContentBlock} from 'draft-js';\n\ninterface ParsedTimeline {\n  totalDurationSec: number;\n  percentComplete: number;\n  rows: TimelineRow[];\n}\n\nexport function parseTimeline(parsedBlocks: ContentBlock[], scrapMap: ScrapMap): ParsedTimeline {\n  let rows: TimelineRow[] = [];\n\n  let totalDurationSec = 0;\n  let totalPendingSec = 0;\n  for (let i = 0; i < parsedBlocks.length; i++) {\n\n    const durationContribution = parsedBlocks[i].getData().get(durationSecContribution) || 0;\n    const incompleteContribution = parsedBlocks[i].getData().get(pendingDurationSecContribution) || 0;\n    if (!durationContribution) {\n      //continue;\n    }\n\n    const characterContribution = parsedBlocks[i].getData().get(character) || null;\n    const pendingCompletion = !!parsedBlocks[i].getData().get(isScrapPlaceholder);\n\n    const traitString = (parsedBlocks[i].getData().get(scrapTraitText) || '') as string;\n    const parsedTraits = traitString.split('#').filter(Boolean).map((untrimmed) => { return untrimmed.trim(); });\n\n    const ancestors = [\n        ...(parsedBlocks[i].getData().get(ancestorField) || []),\n        parsedBlocks[i].getData().get(scrapIdField) || ''\n    ];\n\n    for (let j = 0; j < ancestors.length; j++) {\n      if (rows.length <= j) {\n        // Need to add a new row\n        rows.push(new TimelineRow());\n      }\n\n      // Check to see what the last block's ID is\n      const lastBlockId = rows[j].lastBlockId();\n\n      if (ancestors[j] === lastBlockId) {\n        // Extend existing block\n        rows[j].blocks[rows[j].blocks.length - 1].durationSec += durationContribution;\n      } else {\n        rows[j].blocks.push(new TimelineBlock(\n            getScrapSynopsis(ancestors[j], scrapMap),\n            ancestors[j],\n            totalDurationSec,\n            durationContribution\n        ));\n      }\n\n      if (pendingCompletion) {\n        rows[j].blocks[rows[j].blocks.length - 1].pendingCompletion = true;\n      }\n      if (!!characterContribution) {\n        rows[j].blocks[rows[j].blocks.length - 1].characters.add(characterContribution);\n      }\n      parsedTraits.forEach((trait) => {\n        rows[j].blocks[rows[j].blocks.length - 1].traits.add(trait);\n      });\n    }\n\n    totalDurationSec += durationContribution;\n    totalPendingSec += incompleteContribution;\n  }\n\n  return {\n    totalDurationSec: totalDurationSec,\n    percentComplete: Math.ceil(1000 * (1 - (totalPendingSec / totalDurationSec))) / 10,\n    rows: rows,\n  }\n}\n\nfunction getScrapSynopsis(scrapId: string, scrapMap: ScrapMap): string {\n  return scrapMap[scrapId]?.synopsis || '';\n}\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport React, {Component} from 'react';\nimport {Button, Icon, Popup} from 'semantic-ui-react';\nimport {durationSecondsToString} from '../utils/durationUtils';\nimport {parseTimeline} from './timelineParsing';\nimport {\n  Link\n} from 'react-router-dom';\nimport {ContentBlock} from 'draft-js';\n\nfunction formatPercentString(percent: number): string {\n  return `${percent}%`;\n}\n\nexport class TimelineBlock {\n  headerText: string;\n  id: string;\n  startSec: number;\n  durationSec: number;\n  characters: Set<string>;\n  pendingCompletion: boolean;\n  traits: Set<string>\n\n  constructor(headerText: string, id: string, startSec: number, durationSec: number) {\n    this.headerText = headerText;\n    this.id = id;\n    this.startSec = startSec;\n    this.durationSec = durationSec;\n    this.characters = new Set<string>();\n    this.pendingCompletion = false;\n    this.traits = new Set<string>();\n  }\n\n  render(totalDurationSec: number, currentCharacterFilter: string, highlightPendingCompletion: boolean, currentTraitFilter: string) {\n    let background = 'grey';\n\n    if (\n        this.characters.has(currentCharacterFilter) ||\n        (this.pendingCompletion && highlightPendingCompletion) ||\n        (this.traits.has(currentTraitFilter))\n    ) {\n      background = 'red';\n    }\n\n    return <Popup\n        key={'key-' + this.id}\n        content={durationSecondsToString(this.durationSec)}\n        header={this.headerText}\n        mouseEnterDelay={50}\n        mouseLeaveDelay={50}\n        trigger={\n          <Link\n              to={'/scrap/' + this.id}\n              style={{\n                cursor: 'pointer',\n                display: 'inline-block',\n                height: '100%',\n                boxShadow: 'inset 0px 0px 0px 1px #555',\n                position: 'absolute',\n                width: formatPercentString(100 * this.durationSec / totalDurationSec),\n                left: formatPercentString(100 * this.startSec / totalDurationSec),\n                background: background,\n                zIndex: 2,\n              }}\n          >\n          <div\n        >\n          &nbsp;\n          </div></Link>}\n    />\n  }\n}\n\nexport class TimelineRow {\n  blocks: TimelineBlock[] = [];\n\n  lastBlockId(): string {\n    if (!this.blocks.length) {\n      return '';\n    }\n\n    return this.blocks[this.blocks.length - 1].id;\n  }\n\n  render(totalDurationSec: number, zoomLevel: number, currentCharacterFilter: string, highlightPendingCompletion: boolean, currentTraitFilter: string) {\n    return <div style={{\n      position: 'relative',\n      width: formatPercentString(zoomLevel),\n      height: '40px',\n      borderBottom: '1px solid'\n    }}>\n      {this.blocks.map((block) => block.render(totalDurationSec, currentCharacterFilter, highlightPendingCompletion, currentTraitFilter))}\n    </div>\n  }\n}\n\nexport class Timeline {\n  isValid: boolean = false;\n  durationSec: number = 0;\n  percentComplete: number = 0;\n  rows: TimelineRow[] = [];\n\n  constructor(scrapId: string, scrapMap: ScrapMap, parsedContentBlocks: ContentBlock[]) {\n    if (!scrapMap[scrapId]) {\n      return;\n    }\n    const parseResult = parseTimeline(parsedContentBlocks, scrapMap);\n\n    this.durationSec = parseResult.totalDurationSec;\n    this.percentComplete = parseResult.percentComplete;\n    if (!this.durationSec) {\n      return;\n    }\n\n    this.isValid = true;\n\n    this.rows = parseResult.rows;\n  }\n\n  getSecondMarkers(zoomLevel: number): number[] {\n    const numLevels = Math.round(4 * (zoomLevel / 100)) + 1;\n    const stepLevel = (this.durationSec / (numLevels - 1));\n\n    let startingPoint = 0;\n    let steps = []\n    for (let i = 0; i < numLevels; i++) {\n      const nextContribution = Math.round(startingPoint);\n      steps.push(nextContribution);\n      startingPoint += stepLevel;\n    }\n\n    return steps;\n  }\n\n  render(zoomLevel: number, currentCharacterFilter: string, highlightPendingCompletion: boolean, currentTraitFilter: string) {\n    let secondMarkers = this.getSecondMarkers(zoomLevel);\n    let markerTopPadding = 41 * this.rows.length;\n\n    return <div style={{width: '100%', overflowX: 'scroll', background: 'lightgrey'}}>\n      {this.rows.map((row) => row.render(this.durationSec, zoomLevel, currentCharacterFilter, highlightPendingCompletion, currentTraitFilter))}\n      <div style={{height: '24px', position: 'relative', width: formatPercentString(zoomLevel), background: 'white'}}>\n        {secondMarkers.map((value, idx) => {\n\n          const markerStyle: React.CSSProperties = {\n            display: 'inline-block',\n            position: 'absolute',\n            fontSize: '16px',\n            fontFamily: 'CourierPrime, Courier, monospace',\n            paddingTop: `${markerTopPadding}px`,\n            top: `-${markerTopPadding}px`\n          };\n\n          if (idx + 1 === secondMarkers.length) {\n            markerStyle.paddingRight = '8px';\n            markerStyle.textAlign = 'right';\n            markerStyle.borderRight = '2px solid';\n            markerStyle.right = formatPercentString(100 - (100 * value / this.durationSec));\n          } else {\n            markerStyle.paddingLeft = '8px';\n            markerStyle.textAlign = 'left';\n            markerStyle.borderLeft = '2px solid';\n            markerStyle.left = formatPercentString(100 * value / this.durationSec);\n          }\n\n          return <div\n              style={markerStyle}>{durationSecondsToString(value)}</div>\n        })}\n      </div>\n    </div>\n  }\n}\n\ninterface TimelineProps {\n  scrapId: string;\n  scrapMap: ScrapMap;\n  parsedContentBlocks: ContentBlock[];\n  currentCharacterFilter: string;\n  currentCompletionFilter: string;\n  currentTraitFilter: string;\n}\n\ninterface TimelineState {\n  scrapId: string;\n  timeline: Timeline;\n  zoomLevel: number;\n  minimized: boolean;\n}\n\nexport class TimelineViewer extends Component<TimelineProps, TimelineState> {\n\n  constructor(props: TimelineProps) {\n    super(props);\n\n    this.state = this.initializeState(props);\n  }\n\n  initializeState(props: TimelineProps): TimelineState {\n    return {\n      scrapId: props.scrapId,\n      timeline: new Timeline(props.scrapId, props.scrapMap, props.parsedContentBlocks),\n      zoomLevel: 100,\n      minimized: false,\n    }\n  }\n\n  zoomIn() {\n    this.setState({\n      zoomLevel: this.state.zoomLevel * 2\n    });\n  }\n\n  zoomOut() {\n    this.setState({\n      zoomLevel: Math.max(100, this.state.zoomLevel / 2)\n    });\n  }\n\n  flipMinimization() {\n    this.setState({\n      minimized: !this.state.minimized\n    });\n  }\n\n  render() {\n    if (!this.state.timeline.isValid) {\n      return <div>... loading timeline... </div>\n    }\n\n    const zoomOptions = this.state.minimized ? null : (<div style={{display: 'inline-block'}}>\n      <Button onClick={() => this.zoomOut()} disabled={this.state.zoomLevel === 100} icon>\n        <Icon name='zoom-out' />\n      </Button>\n      <Button onClick={() => this.zoomIn()} icon>\n        <Icon name='zoom-in' />\n      </Button>\n    </div>);\n\n    return (<div>\n      <div style={{marginBottom: '12px', display: 'flex'}}>\n        {zoomOptions}\n        <span style={{flex: '1'}}>&nbsp;</span>\n        <span style={{margin: 'auto 24px'}}>Percent complete: {this.state.timeline.percentComplete}</span>\n        <Button onClick={() => this.flipMinimization()} icon>\n          <Icon name={this.state.minimized ? 'window maximize outline' : 'window minimize outline'}/>\n        </Button>\n      </div>\n      {this.state.minimized ? null : this.state.timeline.render(\n          this.state.zoomLevel,\n          this.props.currentCharacterFilter,\n          !!this.props.currentCompletionFilter,\n          this.props.currentTraitFilter\n      )}\n    </div>)\n  }\n}\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport {Editor, ContentState, ContentBlock, EditorState} from 'draft-js';\nimport {Component, ReactElement} from 'react';\nimport {viewerDecorator} from './foutainDecorators';\nimport {FOUNTAIN_EDITOR_STYLE} from './usefulConstants';\n\ninterface ReadOnlyViewerProps {\n  scrapId: string;\n  scrapMap: ScrapMap;\n  parsedContentBlocks: ContentBlock[];\n}\n\ninterface ReadOnlyViewerState {\n  scrapId: string;\n  editorState: EditorState;\n}\n\nexport class ReadOnlyViewer extends Component<ReadOnlyViewerProps, ReadOnlyViewerState> {\n\n  constructor(props: ReadOnlyViewerProps) {\n    super(props);\n\n    this.state = this.initializeState(props);\n  }\n\n  initializeState(props: ReadOnlyViewerProps): ReadOnlyViewerState {\n    return {\n      scrapId: props.scrapId,\n      editorState: this.buildInitialEditorState(props)\n    };\n  }\n\n  componentDidUpdate(prevProps: Readonly<ReadOnlyViewerProps>, prevState: Readonly<ReadOnlyViewerState>, snapshot?: any) {\n    if (this.state.scrapId === this.props.scrapId) {\n      return;\n    }\n\n    // Need to update\n    this.setState(this.initializeState(this.props));\n  }\n\n  buildInitialEditorState(props: ReadOnlyViewerProps): EditorState {\n    let thisScrap = props.scrapMap[props.scrapId];\n\n    if (!thisScrap) {\n      return EditorState.createEmpty();\n    }\n\n    return EditorState.createWithContent(\n        ContentState.createFromBlockArray(\n            this.props.parsedContentBlocks),\n        viewerDecorator);\n  }\n\n  normalizeProse(prose: string): string {\n    return prose; // TODO: actually normalize things, remove comments, normalize whitespace\n  }\n\n  render(): ReactElement {\n    return <div\n        style={FOUNTAIN_EDITOR_STYLE}>\n      <Editor\n        readOnly\n        onChange={() => {}}\n        editorState={this.state.editorState}\n      />\n    </div>\n  }\n\n}\n","import { RouteComponentProps } from 'react-router';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {ScrapMap, selectScrapMap} from '../../features/scrapList/scrapListSlice';\nimport React, {Component} from 'react';\nimport {ContentBlock} from 'draft-js';\nimport {fetchParsedContentBlocksForScrap} from '../../features/utils/fetchParsedContentBlocksForScrap';\nimport {TimelineViewer} from '../../features/timeline/Timeline';\nimport {ReadOnlyViewer} from '../../features/scrapDetails/ReadOnlyViewer';\nimport {HeaderOptions, readHeaderOptions, updateHeaderOptions} from '../../features/revision-header/headerOptionsSlice';\nimport {fetchCharacters} from '../../features/utils/fetchCharacters';\nimport {fetchTraits} from '../../features/utils/fetchTraits';\n\ninterface MatchParams {\n  id: string\n}\n\ninterface ReadScrapProps extends RouteComponentProps<MatchParams> {}\n\nexport default function ReadScrapPage (props: ReadScrapProps) {\n  const scrapMap = useAppSelector(selectScrapMap);\n  const dispatch = useAppDispatch();\n  const headerOptions = useAppSelector(readHeaderOptions);\n\n  return (\n      <ReadScrap\n          scrapId={props.match.params.id}\n          scrapMap={scrapMap}\n          onUpdateHeaderOptions={(newHeaderOptions) => dispatch(updateHeaderOptions(\n              {\n                ...headerOptions,\n                ...newHeaderOptions,\n              }))}\n          headerOptions={headerOptions}\n      />\n  )\n}\n\ninterface ReadPageProps {\n  scrapId: string;\n  scrapMap: ScrapMap;\n  onUpdateHeaderOptions: (headerOptions: HeaderOptions) => void;\n  headerOptions: HeaderOptions;\n}\n\ninterface ReadPageState {\n  scrapId: string;\n  hasLoaded: boolean;\n  parsedContentBlocks: ContentBlock[];\n}\n\nexport class ReadScrap extends Component<ReadPageProps, ReadPageState> {\n\n  constructor(props: ReadPageProps) {\n    super(props);\n\n    this.state = {\n      scrapId: props.scrapId,\n      hasLoaded: false,\n      parsedContentBlocks: [],\n    };\n  }\n\n  componentDidMount() {\n    const parsedBlocks = fetchParsedContentBlocksForScrap(this.props.scrapId, [], this.props.scrapMap);\n\n    const characters = fetchCharacters(parsedBlocks);\n    const traits = fetchTraits(parsedBlocks);\n\n    this.setState({\n      hasLoaded: true,\n      parsedContentBlocks: parsedBlocks,\n    });\n\n    this.props.onUpdateHeaderOptions({\n      ...this.props.headerOptions,\n      currentScrapId: this.state.scrapId,\n      showReadLink: false,\n      showEditLink: true,\n      characterFilters: characters,\n      traitFilters: traits,\n    });\n  }\n\n  render() {\n    if (!this.state.hasLoaded) {\n      return <div> ... loading ...</div>\n    }\n\n    return <div style={{height: '100%', display: 'flex', flexDirection: 'column'}}>\n      <TimelineViewer\n          scrapId={this.state.scrapId}\n          scrapMap={this.props.scrapMap}\n          parsedContentBlocks={this.state.parsedContentBlocks}\n          currentCharacterFilter={this.props.headerOptions.currentCharacterFilter || ''}\n          currentCompletionFilter={this.props.headerOptions.currentCompletionFilter || ''}\n          currentTraitFilter={this.props.headerOptions.currentTraitFilter || ''}\n      />\n      <ReadOnlyViewer\n          scrapId={this.state.scrapId}\n          scrapMap={this.props.scrapMap}\n          parsedContentBlocks={this.state.parsedContentBlocks}/>\n    </div>\n  }\n}\n","import {ContentBlock} from 'draft-js';\nimport {character, durationSecContribution} from '../scrapDetails/usefulConstants';\n\nexport interface CharacterAppearance {\n  character: string;\n  totalDurationSec: number;\n  percentDurationSec: number;\n}\n\nexport function fetchCharacters(parsedBlocks: ContentBlock[]): CharacterAppearance[] {\n  const characterMap: {[key: string]: CharacterAppearance} = {};\n\n  let totalDurationSec = 0;\n  parsedBlocks.forEach((block) => {\n    const blockData = block.getData();\n\n    const thisCharacter = blockData.get(character) as string;\n    const thisDurationSecContribution = (blockData.get(durationSecContribution) || 0) as number;\n\n    totalDurationSec += thisDurationSecContribution;\n\n    if (!!thisCharacter) {\n      if (!characterMap[thisCharacter]) {\n        characterMap[thisCharacter] = {\n          character: thisCharacter,\n          totalDurationSec: 0,\n          percentDurationSec: 0,\n        };\n      }\n      characterMap[thisCharacter].totalDurationSec += thisDurationSecContribution;\n    }\n  });\n\n  return Object.values(characterMap).sort((b, a) => {\n    return a.totalDurationSec - b.totalDurationSec;\n  }).map((characterEntry) => {\n    characterEntry.percentDurationSec = characterEntry.totalDurationSec / totalDurationSec;\n    return characterEntry;\n  });\n}\n","import {ContentBlock} from 'draft-js';\nimport {scrapTraitText} from '../scrapDetails/usefulConstants';\n\nexport interface TraitAppearance {\n  trait: string;\n  numberOfAppearances: number;\n}\n\nexport function fetchTraits(parsedBlocks: ContentBlock[]): TraitAppearance[] {\n  const traitMap: {[key: string]: TraitAppearance} = {};\n\n  parsedBlocks.forEach((block) => {\n    const blockData = block.getData();\n\n    const traitText = (blockData.get(scrapTraitText) || '') as string;\n    traitText.split('#').filter(Boolean).forEach((untrimmedTrait) => {\n      const trait = untrimmedTrait.trim();\n\n      if (!traitMap[trait]) {\n        traitMap[trait] = {\n          trait: trait,\n          numberOfAppearances: 0\n        };\n      }\n\n      traitMap[trait].numberOfAppearances += 1;\n    });\n  });\n\n  return Object.values(traitMap).sort((a, b) => {\n    return b.numberOfAppearances - a.numberOfAppearances;\n  });\n}\n","import React from 'react';\nimport './App.css';\nimport RevisionHeader from './features/revision-header/RevisionHeader';\nimport {\n  HashRouter as Router,\n  Switch,\n  Route\n} from 'react-router-dom';\n\nimport Homepage from './pages/homepage/Homepage';\nimport DataManagementPage from './pages/import-export/DataManagementPage';\nimport ScrapDetailsPage from './pages/scrap-details/ScrapDetailsPage';\nimport DecisionPage from './pages/decisions/DecisionPage';\nimport ReadScrapPage from './pages/read-scrap/ReadScrapPage';\n\nfunction App() {\n  return (\n      <div style={{padding: 0, margin: 0, height: '100vh'}}>\n    <Router >\n      <RevisionHeader />\n      <div style={{\n        height: 'calc(100% - 68px)',\n      }}>\n        <Switch>\n          <Route path=\"/decisions\" component={DecisionPage} />\n          <Route path=\"/data\" component={DataManagementPage} />\n          <Route path=\"/scrap/:id\" component={ScrapDetailsPage} />\n          <Route path=\"/read/:id\" component={ReadScrapPage} />\n          <Route path=\"/\" component={Homepage} />\n        </Switch>\n      </div>\n    </Router>\n      </div>\n  );\n}\n\nexport default App;\n","import {configureStore, ThunkAction, Action} from '@reduxjs/toolkit';\nimport scrapListReducer, {scrapListPersistenceMiddleware} from '../features/scrapList/scrapListSlice';\nimport headerOptionsReducer from '../features/revision-header/headerOptionsSlice';\n\nexport const store = configureStore({\n  reducer: {\n    scrapList: scrapListReducer,\n    headerOptions: headerOptionsReducer,\n  },\n  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat([\n    scrapListPersistenceMiddleware,\n  ])\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\nimport 'semantic-ui-css/semantic.min.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}