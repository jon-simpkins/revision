{"version":3,"sources":["protos_v2.js","app/hooks.ts","features/revision-header/headerOptionsSlice.ts","features/utils/durationUtils.ts","features/scrapDetails/SearchModal.tsx","features/scrapList/scrapListPersistence.ts","features/scrapDetails/usefulConstants.ts","features/scrapDetails/BaseReadOnlyComponent.tsx","features/scrapDetails/FountainHeaderComponent.tsx","features/scrapDetails/ScrapEmbedComponent.tsx","features/scrapDetails/FountainTransitionComponent.tsx","features/scrapDetails/FountainCenteredComponent.tsx","features/scrapDetails/FountainCharacterComponent.tsx","features/scrapDetails/FountainDialogueComponent.tsx","features/scrapDetails/FountainParentheticalComponent.tsx","features/scrapDetails/FountainActionComponent.tsx","features/scrapDetails/ScrapPlaceholderComponent.tsx","features/scrapDetails/ScrapTraitComponent.tsx","features/scrapDetails/parseProse.ts","features/scrapDetails/CommentComponent.tsx","features/utils/fetchParsedContentBlocksForScrap.ts","features/utils/timeUtils.ts","features/timeline/Timeline.tsx","features/timeline/timelineParsing.ts","features/scrapList/scrapListSlice.ts","features/revision-header/RevisionHeader.tsx","pages/print-scrap/contactInfoPersistence.ts","pages/print-scrap/contactInfoSlice.ts","pages/homepage/Homepage.tsx","pages/import-export/DataManagementPage.tsx","features/scrapDetails/foutainDecorators.ts","features/scrapDetails/editorInteractionUtils.ts","features/scrapDetails/ScrapDetailsHelperComponents.tsx","features/scrapDetails/ScrapDetails.tsx","pages/scrap-details/ScrapDetailsPage.tsx","pages/decisions/DecisionPage.tsx","features/scrapDetails/ReadOnlyViewer.tsx","pages/read-scrap/ReadScrapPage.tsx","features/utils/fetchCharacters.ts","features/utils/fetchTraits.ts","courierPrime/CourierPrime-Regular.ttf","courierPrime/CourierPrime-Bold.ttf","courierPrime/CourierPrime-Italic.ttf","courierPrime/CourierPrime-Bold-Italic.ttf","pages/print-scrap/savePDF.tsx","pages/print-scrap/PrintScrapPage.tsx","App.tsx","app/store.ts","serviceWorker.ts","index.tsx"],"names":["define","$protobuf","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","Timestamp","properties","keys","Object","i","length","this","prototype","seconds","nanos","create","encode","message","writer","hasOwnProperty","call","uint32","int32","encodeDelimited","ldelim","decode","reader","end","undefined","len","pos","tag","skipType","decodeDelimited","verify","isInteger","fromObject","object","toObject","options","defaults","toJSON","constructor","toJSONOptions","Duration","Scrap","childScraps","writingHistory","id","intendedDurationSec","synopsis","prose","emptyArray","completeness","string","WritingHistory","fork","push","isString","Array","isArray","error","String","TypeError","arrays","enums","j","Completeness","valuesById","values","minutesSinceEpoch","actualDurationSec","WritingWorkspace","scraps","author","contactInfo","useAppDispatch","useDispatch","useAppSelector","useSelector","headerOptionsSlice","createSlice","name","initialState","currentScrapId","showEditLink","showReadLink","showPrintLink","characterFilters","currentCharacterFilter","currentCompletionFilter","traitFilters","currentTraitFilter","isCurrentlyInSession","currentWritingSessionStartEpoch","lastCheckedWritingSessionEpoch","searchModalOpen","currentSearchQuery","currentSearchResults","includeTitlePage","reducers","updateHeaderOptions","state","action","payload","readHeaderOptions","headerOptions","actions","durationSecondsToString","durationSeconds","durationStr","hours","Math","floor","toString","padStart","minutes","round","durationStringToSeconds","durationString","RegExp","test","Error","splitDurationStr","split","filter","Boolean","durationSec","parseInt","formatSearchResults","onSelect","style","minHeight","MAX_SEARCH_RESULTS","map","result","marginBottom","height","display","flexDirection","to","scrap","fontSize","onClick","background","flex","overflowY","preview","getSearchModal","isOpen","scrapMap","onSearchQueryChange","onClose","Modal","open","closeOnDimmerClick","closeOnEscape","Header","Content","Input","placeholder","onChange","e","results","query","toLowerCase","includes","firstIndex","indexOf","max","score","substring","sort","a","b","slice","computeSearchResults","target","value","allScrapIdsKey","scrapKey","readAllScrapsFromStorage","readScrapIds","scrapString","localStorage","getItem","JSON","parse","readScrap","storyIdString","writeScrapIds","scrapIds","setItem","stringify","writeScrap","addScrapToStorage","allScrapIds","ONE_LINE_DURATION_SEC","PAGE_WIDTH_EM","scrapIdField","ancestorField","pendingDurationSecContribution","durationSecContribution","isScrapTrait","scrapTraitText","isScrapPlaceholder","scrapPlaceholderText","scrapPlaceholderDurationSecField","isScrapEmbedding","scrapLink","isFountainHeader","isFountainCentered","isFountainTransition","isBlank","isComment","isFountainCharacter","character","isFountainDialogue","isFountainParenthetical","isFountainAction","FOUNTAIN_EDITOR_STYLE","border","padding","margin","width","fontFamily","mergeDataObject","dataObject","newData","parseScrapIdFromProps","props","contentState","getBlockMap","get","blockKey","getData","BaseReadOnlyComponent","isHover","scrapId","Button","cursor","position","top","right","circular","color","icon","setState","paddingRight","isFilterSelected","backgroundColor","children","getParentStyle","onMouseEnter","onMouseLeave","renderSpecific","buildScrapLinkButton","Component","fountainHeaderStrategy","contentBlock","callback","getText","sceneHeaderDurationSec","blockText","FountainHeaderComponent","fontWeight","FountainHeaderReadOnlyComponent","checkIsScrapEmbed","startsWith","endsWith","ScrapEmbedSummary","parentScrapId","onGotoScrap","Icon","marginLeft","fountainTransitionStrategy","sceneTransitionDurationSec","FountainTransitionComponent","textAlign","FountainTransitionReadOnlyComponent","fountainCenteredStrategy","sceneCenteredDurationSec","FountainCenteredComponent","FountainCenteredReadOnlyComponent","fountainCharacterStrategy","characterDurationSec","ceil","FountainCharacterComponent","FountainCharacterReadOnlyClassComponent","fountainDialogueStrategy","dialogueDurationSec","FountainDialogueComponent","FountainDialogueReadOnlyClassComponent","fountainParentheticalStrategy","parentheticalDurationSec","FountainParentheticalComponent","FountainParentheticalReadOnlyClassComponent","fountainActionStrategy","actionDurationSec","FountainActionComponent","FountainActionReadOnlyComponent","scrapPlaceholderStrategy","scrapPlaceholderDurationSec","content","replace","trim","ScrapPlaceholderReadOnlyComponent","data","placeholderText","displayText","linesOfText","numberOfLines","heightStyle","numberOfInstances","overflow","fill","bottom","zIndex","scrapTraitStrategy","preProcessProseBlock","blockData","checkIsCommentStart","checkIsCommentEnd","set","Immutable","fromJS","processProseBlock","blockBefore","blockAfter","processProgress","toJS","blankBefore","blankAfter","characterBefore","currentDurationSec","checkIsSceneHeader","toUpperCase","checkIsSceneTransition","checkIsCentered","checkIsCharacter","checkIsDialogue","checkIsParenthetical","checkIsScrapPlaceholder","checkIsScrapTrait","actionData","scrapTraitData","scrapPlaceholderData","parentheticalData","dialogueData","parsedCharacter","characterData","sceneCenteredData","sceneTransitionData","sceneHeaderData","scrapEmbedData","add","childScrap","updatedBlock","updatedCharacterList","getCharacterList","c","idx","parseAllProse","warnParsingThreshold","errorParsingThreshold","newParseErrorState","processStartEpoch","Date","now","OrderedSet","currentBlockMap","blockKeys","nextKey","timeSoFar","currentlyInComment","currentBlock","updatedData","update","newContent","durationMs","console","log","totalDurationSec","showTimeoutWarning","fetchParsedContentBlocksForScrap","scrapAncestors","newAncestors","parseResult","ContentState","createFromText","allNewContentBlocks","getBlocksAsArray","forEach","block","embeddedScrapId","subBlocks","dateFromMinSinceEpoch","minSinceEpoch","toLocaleDateString","formatPercentString","percent","Chart","register","registerables","TimelineBlock","headerText","startSec","characters","traits","Set","highlightPendingCompletion","completenessText","has","FINAL","POLISHED","INITIAL_DRAFT","BRAINSTORM","popupText","Popup","header","mouseEnterDelay","mouseLeaveDelay","trigger","boxShadow","left","TimelineRow","blocks","zoomLevel","borderBottom","render","Timeline","parsedContentBlocks","isValid","percentComplete","rows","parseTimeline","numLevels","stepLevel","startingPoint","steps","nextContribution","secondMarkers","getSecondMarkers","markerTopPadding","overflowX","row","markerStyle","paddingTop","borderRight","paddingLeft","borderLeft","TimelineViewer","initializeState","timeline","chartMinimized","timelineMinimized","minMinEpoch","maxMinEpoch","dateMap","minEpoch","labels","dateStr","datasets","responsive","plugins","title","text","legend","scales","y","type","maintainAspectRatio","zoomOptions","zoomOut","disabled","zoomIn","flipChartMinimization","flipTimelineMinimization","getProgressChart","parsedBlocks","totalPendingSec","durationContribution","incompleteContribution","characterContribution","parsedTraits","untrimmed","ancestors","lastBlockId","getScrapSynopsis","getScrapCompleteness","trait","totalCompletedSec","NOT_STARTED","fetchInitialStateFromStorage","actionPrefix","ScrapListSlice","createScrap","updateScrap","updatedScrap","lastUpdatedMinutesEpoch","newMinutesSinceEpoch","parsedTimeline","newHistoryEntry","removeScrap","scrapListPersistenceMiddleware","storeAPI","next","handleScrapListPersistence","idToRemove","removeItem","selectScrapMap","compiledScrapMap","entries","scrapList","key","RevisionHeader","completionFilters","editEntry","readEntry","printEntry","timerEntry","titlePageEntry","dispatch","dispatchPartialOptionsUpdate","partialUpdate","characterOptions","characterFilter","percentDurationSec","unshift","Dropdown","floating","labeled","scrolling","item","className","traitOptions","traitFilter","numberOfAppearances","Menu","Item","setInterval","Checkbox","checked","label","searchModal","newQuery","newResults","AUTHOR_KEY","CONTACT_INFO_KEY","readContactInfoFromStorage","setAuthor","newValue","setContactInfo","ContactInfoSlice","updateAuthor","updateContactInfo","contactInfoPersistenceMiddleware","handleContactInfoPersistence","selectContactInfo","workspaceContactInfo","getScrapSection","hasParentMap","childId","Segment","preparedScrapList","flexWrap","Card","Homepage","history","useHistory","Group","size","Subheader","Form","defaultValue","TextArea","newScrap","uuid","downloadWorkspace","filename","fileDownload","workspace","finish","loadDataFromStorage","files","arrayBuffer","fileData","loadDataToStorage","Uint8Array","window","location","reload","clear","DataManagementPage","accept","event","uploadWorkspace","editorDecorator","CompositeDecorator","strategy","component","inComment","currentLocation","useLocation","pathname","fontStyle","viewerDecorator","getSelectedText","editorState","selected","getFragmentFromSelection","x","join","onCut","editor","removeWhenDone","preventDefault","selectedText","clipboard","then","newContentState","Modifier","replaceText","getCurrentContent","getSelection","EditorState","currentContent","buildInitialEditorState","lastEmittedStr","durationErrorString","parentScrapIds","buildParentScrapIds","parseErrorState","durationInputKey","focusMode","thisScrap","createWithContent","createEmpty","parentScraps","getBreadcrumbs","scrapContribution","parentScrapLinks","parentScrap","BreadcrumbSection","link","Breadcrumb","reduce","prev","curr","BreadcrumbDivider","getProseEditorToolbar","remapEditorContent","parseWarning","focusLabel","durationPercentLabel","onScrapCreate","currentSelection","currentlySelectedText","newScrapId","thingToInsert","isCollapsed","insertText","getPlainText","addChildScrap","newState","match","textToSwap","re","exec","textToReplace","splitText","replacePlaceholderScraps","thisScrapId","onScrapDelete","absorbedIds","idToAbsorb","scrapToAbsorb","childOfMoreThanThisMap","childScrapId","absorbedId","fullyAbsorbedId","absorbPlaceholderScraps","getPrimaryForm","onScrapUpdate","newDuration","setDurationErrorString","onDurationChange","Field","selection","updateExpectedDurationSec","hasError","styleMap","ScrapDetails","domEditor","debounce","newStrToEmit","persistProse","array","isArrayEqualToImmutableSet","toArray","onUpdateHeaderOptions","setHeaderOptions","prevProps","prevState","snapshot","ref","focus","newProseStr","noFocusSection","customStyleMap","spellCheck","stripPastedStyles","onCopy","setDomEditorRef","onProseChange","ScrapDetailsPage","params","DecisionPage","showListInput","showCurrentScores","nextCandidateLabel","nextCandidateDesc","candidates","winMatrix","candidateIndexA","candidateIndexB","newCandidates","description","currentScore","wins","losses","indexAWeights","ignore","getTotalComparisons","indexA","randomSelectWeighted","indexBWeights","indexB","weights","sumWeight","previousValue","currentValue","randomCutoff","random","sum","index","totalComparisons","candidateA","candidateB","marginTop","updateWin","line","winIndex","loseIndex","iteration","W_i","denominator","averageValue","setupNewComparison","sortedCandidates","candidate","mainContent","updateNextCandidateLabel","updateNextCandidateDesc","addCandidate","renderCandidates","renderComparison","toggleShowCurrentScores","renderWinMatrix","ReadOnlyViewer","createFromBlockArray","readOnly","ReadScrapPage","newHeaderOptions","ReadScrap","hasLoaded","characterMap","thisCharacter","thisDurationSecContribution","characterEntry","fetchCharacters","traitMap","untrimmedTrait","fetchTraits","Font","family","format","src","CourierPrime","CourierPrimeBold","CourierPrimeItalic","CourierPrimeBoldItalic","registerHyphenationCallback","word","ElementType","ONE_LINE_PADDING","styles","StyleSheet","textDecoration","dateInfo","page","paddingBottom","characterLine","dialogueLine","parentheticalLine","transitionLine","centeredLine","sceneHeaderLine","bold","italic","boldItalic","underline","pageNumber","parsePDFBlocks","mostRecentCharacter","pdfBlocks","nextPDFBlock","elements","ACTION","CHARACTER","DIALOGUE","PARENTHETICAL","TRANSITION","CENTERED","SCENE_HEADING","nextElement","lastElementType","nextElementType","shouldCreateNewBlock","underlineRegex","boldItalicRegex","boldRegex","italicRegex","applyRegexSplit","regex","parentStyle","thisStyle","splitResult","returnBlocks","segment","segmentStyle","parseTextEmphasis","underlineResult","boldItalicResult","boldResult","italicResult","getTitlePage","metadataSection","year","month","day","Fragment","contactLine","titleLine","renderDocument","parsedPDFBlocks","showTitlePage","pageNumberElement","effectivePageNumber","fixed","creator","producer","wrap","pdfBlock","element","emphasisBlock","renderExamplePDF","printPageProps","PrintScrapPage","PrintScrap","alreadyWarned","durationPages","App","path","store","configureStore","reducer","scrapListReducer","headerOptionsReducer","contactInfoReducer","middleware","getDefaultMiddleware","concat","hostname","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch"],"mappings":"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","file":"static/js/main.442c0a4f.chunk.js","sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n(function(global, factory) { /* global define, require, module */\n\n    /* AMD */ if (typeof define === 'function' && define.amd)\n        define([\"protobufjs/minimal\"], factory);\n\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)\n        module.exports = factory(require(\"protobufjs/minimal\"));\n\n})(this, function($protobuf) {\n    \"use strict\";\n\n    // Common aliases\n    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n    \n    // Exported root namespace\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    \n    $root.Timestamp = (function() {\n    \n        /**\n         * Properties of a Timestamp.\n         * @exports ITimestamp\n         * @interface ITimestamp\n         * @property {number|null} [seconds] Timestamp seconds\n         * @property {number|null} [nanos] Timestamp nanos\n         */\n    \n        /**\n         * Constructs a new Timestamp.\n         * @exports Timestamp\n         * @classdesc Represents a Timestamp.\n         * @implements ITimestamp\n         * @constructor\n         * @param {ITimestamp=} [properties] Properties to set\n         */\n        function Timestamp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Timestamp seconds.\n         * @member {number} seconds\n         * @memberof Timestamp\n         * @instance\n         */\n        Timestamp.prototype.seconds = 0;\n    \n        /**\n         * Timestamp nanos.\n         * @member {number} nanos\n         * @memberof Timestamp\n         * @instance\n         */\n        Timestamp.prototype.nanos = 0;\n    \n        /**\n         * Creates a new Timestamp instance using the specified properties.\n         * @function create\n         * @memberof Timestamp\n         * @static\n         * @param {ITimestamp=} [properties] Properties to set\n         * @returns {Timestamp} Timestamp instance\n         */\n        Timestamp.create = function create(properties) {\n            return new Timestamp(properties);\n        };\n    \n        /**\n         * Encodes the specified Timestamp message. Does not implicitly {@link Timestamp.verify|verify} messages.\n         * @function encode\n         * @memberof Timestamp\n         * @static\n         * @param {ITimestamp} message Timestamp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Timestamp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.seconds != null && Object.hasOwnProperty.call(message, \"seconds\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seconds);\n            if (message.nanos != null && Object.hasOwnProperty.call(message, \"nanos\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link Timestamp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Timestamp\n         * @static\n         * @param {ITimestamp} message Timestamp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Timestamp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Timestamp message from the specified reader or buffer.\n         * @function decode\n         * @memberof Timestamp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Timestamp} Timestamp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Timestamp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Timestamp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.seconds = reader.int32();\n                    break;\n                case 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Timestamp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Timestamp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Timestamp} Timestamp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Timestamp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Timestamp message.\n         * @function verify\n         * @memberof Timestamp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Timestamp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                if (!$util.isInteger(message.seconds))\n                    return \"seconds: integer expected\";\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                if (!$util.isInteger(message.nanos))\n                    return \"nanos: integer expected\";\n            return null;\n        };\n    \n        /**\n         * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Timestamp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Timestamp} Timestamp\n         */\n        Timestamp.fromObject = function fromObject(object) {\n            if (object instanceof $root.Timestamp)\n                return object;\n            var message = new $root.Timestamp();\n            if (object.seconds != null)\n                message.seconds = object.seconds | 0;\n            if (object.nanos != null)\n                message.nanos = object.nanos | 0;\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Timestamp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Timestamp\n         * @static\n         * @param {Timestamp} message Timestamp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Timestamp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.seconds = 0;\n                object.nanos = 0;\n            }\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                object.seconds = message.seconds;\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                object.nanos = message.nanos;\n            return object;\n        };\n    \n        /**\n         * Converts this Timestamp to JSON.\n         * @function toJSON\n         * @memberof Timestamp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Timestamp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return Timestamp;\n    })();\n    \n    $root.Duration = (function() {\n    \n        /**\n         * Properties of a Duration.\n         * @exports IDuration\n         * @interface IDuration\n         * @property {number|null} [seconds] Duration seconds\n         * @property {number|null} [nanos] Duration nanos\n         */\n    \n        /**\n         * Constructs a new Duration.\n         * @exports Duration\n         * @classdesc Represents a Duration.\n         * @implements IDuration\n         * @constructor\n         * @param {IDuration=} [properties] Properties to set\n         */\n        function Duration(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Duration seconds.\n         * @member {number} seconds\n         * @memberof Duration\n         * @instance\n         */\n        Duration.prototype.seconds = 0;\n    \n        /**\n         * Duration nanos.\n         * @member {number} nanos\n         * @memberof Duration\n         * @instance\n         */\n        Duration.prototype.nanos = 0;\n    \n        /**\n         * Creates a new Duration instance using the specified properties.\n         * @function create\n         * @memberof Duration\n         * @static\n         * @param {IDuration=} [properties] Properties to set\n         * @returns {Duration} Duration instance\n         */\n        Duration.create = function create(properties) {\n            return new Duration(properties);\n        };\n    \n        /**\n         * Encodes the specified Duration message. Does not implicitly {@link Duration.verify|verify} messages.\n         * @function encode\n         * @memberof Duration\n         * @static\n         * @param {IDuration} message Duration message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Duration.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.seconds != null && Object.hasOwnProperty.call(message, \"seconds\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seconds);\n            if (message.nanos != null && Object.hasOwnProperty.call(message, \"nanos\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Duration message, length delimited. Does not implicitly {@link Duration.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Duration\n         * @static\n         * @param {IDuration} message Duration message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Duration.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Duration message from the specified reader or buffer.\n         * @function decode\n         * @memberof Duration\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Duration} Duration\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Duration.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Duration();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.seconds = reader.int32();\n                    break;\n                case 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Duration message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Duration\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Duration} Duration\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Duration.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Duration message.\n         * @function verify\n         * @memberof Duration\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Duration.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                if (!$util.isInteger(message.seconds))\n                    return \"seconds: integer expected\";\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                if (!$util.isInteger(message.nanos))\n                    return \"nanos: integer expected\";\n            return null;\n        };\n    \n        /**\n         * Creates a Duration message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Duration\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Duration} Duration\n         */\n        Duration.fromObject = function fromObject(object) {\n            if (object instanceof $root.Duration)\n                return object;\n            var message = new $root.Duration();\n            if (object.seconds != null)\n                message.seconds = object.seconds | 0;\n            if (object.nanos != null)\n                message.nanos = object.nanos | 0;\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Duration message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Duration\n         * @static\n         * @param {Duration} message Duration\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Duration.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.seconds = 0;\n                object.nanos = 0;\n            }\n            if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                object.seconds = message.seconds;\n            if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                object.nanos = message.nanos;\n            return object;\n        };\n    \n        /**\n         * Converts this Duration to JSON.\n         * @function toJSON\n         * @memberof Duration\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Duration.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return Duration;\n    })();\n    \n    $root.Scrap = (function() {\n    \n        /**\n         * Properties of a Scrap.\n         * @exports IScrap\n         * @interface IScrap\n         * @property {string|null} [id] Scrap id\n         * @property {number|null} [intendedDurationSec] Scrap intendedDurationSec\n         * @property {string|null} [synopsis] Scrap synopsis\n         * @property {string|null} [prose] Scrap prose\n         * @property {Array.<string>|null} [childScraps] Scrap childScraps\n         * @property {Scrap.Completeness|null} [completeness] Scrap completeness\n         * @property {Array.<Scrap.IWritingHistory>|null} [writingHistory] Scrap writingHistory\n         */\n    \n        /**\n         * Constructs a new Scrap.\n         * @exports Scrap\n         * @classdesc Represents a Scrap.\n         * @implements IScrap\n         * @constructor\n         * @param {IScrap=} [properties] Properties to set\n         */\n        function Scrap(properties) {\n            this.childScraps = [];\n            this.writingHistory = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * Scrap id.\n         * @member {string} id\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.id = \"\";\n    \n        /**\n         * Scrap intendedDurationSec.\n         * @member {number} intendedDurationSec\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.intendedDurationSec = 0;\n    \n        /**\n         * Scrap synopsis.\n         * @member {string} synopsis\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.synopsis = \"\";\n    \n        /**\n         * Scrap prose.\n         * @member {string} prose\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.prose = \"\";\n    \n        /**\n         * Scrap childScraps.\n         * @member {Array.<string>} childScraps\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.childScraps = $util.emptyArray;\n    \n        /**\n         * Scrap completeness.\n         * @member {Scrap.Completeness} completeness\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.completeness = 0;\n    \n        /**\n         * Scrap writingHistory.\n         * @member {Array.<Scrap.IWritingHistory>} writingHistory\n         * @memberof Scrap\n         * @instance\n         */\n        Scrap.prototype.writingHistory = $util.emptyArray;\n    \n        /**\n         * Creates a new Scrap instance using the specified properties.\n         * @function create\n         * @memberof Scrap\n         * @static\n         * @param {IScrap=} [properties] Properties to set\n         * @returns {Scrap} Scrap instance\n         */\n        Scrap.create = function create(properties) {\n            return new Scrap(properties);\n        };\n    \n        /**\n         * Encodes the specified Scrap message. Does not implicitly {@link Scrap.verify|verify} messages.\n         * @function encode\n         * @memberof Scrap\n         * @static\n         * @param {IScrap} message Scrap message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Scrap.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n            if (message.intendedDurationSec != null && Object.hasOwnProperty.call(message, \"intendedDurationSec\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.intendedDurationSec);\n            if (message.synopsis != null && Object.hasOwnProperty.call(message, \"synopsis\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.synopsis);\n            if (message.prose != null && Object.hasOwnProperty.call(message, \"prose\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.prose);\n            if (message.childScraps != null && message.childScraps.length)\n                for (var i = 0; i < message.childScraps.length; ++i)\n                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.childScraps[i]);\n            if (message.completeness != null && Object.hasOwnProperty.call(message, \"completeness\"))\n                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.completeness);\n            if (message.writingHistory != null && message.writingHistory.length)\n                for (var i = 0; i < message.writingHistory.length; ++i)\n                    $root.Scrap.WritingHistory.encode(message.writingHistory[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified Scrap message, length delimited. Does not implicitly {@link Scrap.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Scrap\n         * @static\n         * @param {IScrap} message Scrap message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Scrap.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a Scrap message from the specified reader or buffer.\n         * @function decode\n         * @memberof Scrap\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Scrap} Scrap\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Scrap.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Scrap();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.intendedDurationSec = reader.uint32();\n                    break;\n                case 3:\n                    message.synopsis = reader.string();\n                    break;\n                case 4:\n                    message.prose = reader.string();\n                    break;\n                case 9:\n                    if (!(message.childScraps && message.childScraps.length))\n                        message.childScraps = [];\n                    message.childScraps.push(reader.string());\n                    break;\n                case 10:\n                    message.completeness = reader.int32();\n                    break;\n                case 11:\n                    if (!(message.writingHistory && message.writingHistory.length))\n                        message.writingHistory = [];\n                    message.writingHistory.push($root.Scrap.WritingHistory.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a Scrap message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Scrap\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Scrap} Scrap\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Scrap.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a Scrap message.\n         * @function verify\n         * @memberof Scrap\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Scrap.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                if (!$util.isString(message.id))\n                    return \"id: string expected\";\n            if (message.intendedDurationSec != null && message.hasOwnProperty(\"intendedDurationSec\"))\n                if (!$util.isInteger(message.intendedDurationSec))\n                    return \"intendedDurationSec: integer expected\";\n            if (message.synopsis != null && message.hasOwnProperty(\"synopsis\"))\n                if (!$util.isString(message.synopsis))\n                    return \"synopsis: string expected\";\n            if (message.prose != null && message.hasOwnProperty(\"prose\"))\n                if (!$util.isString(message.prose))\n                    return \"prose: string expected\";\n            if (message.childScraps != null && message.hasOwnProperty(\"childScraps\")) {\n                if (!Array.isArray(message.childScraps))\n                    return \"childScraps: array expected\";\n                for (var i = 0; i < message.childScraps.length; ++i)\n                    if (!$util.isString(message.childScraps[i]))\n                        return \"childScraps: string[] expected\";\n            }\n            if (message.completeness != null && message.hasOwnProperty(\"completeness\"))\n                switch (message.completeness) {\n                default:\n                    return \"completeness: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                    break;\n                }\n            if (message.writingHistory != null && message.hasOwnProperty(\"writingHistory\")) {\n                if (!Array.isArray(message.writingHistory))\n                    return \"writingHistory: array expected\";\n                for (var i = 0; i < message.writingHistory.length; ++i) {\n                    var error = $root.Scrap.WritingHistory.verify(message.writingHistory[i]);\n                    if (error)\n                        return \"writingHistory.\" + error;\n                }\n            }\n            return null;\n        };\n    \n        /**\n         * Creates a Scrap message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Scrap\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Scrap} Scrap\n         */\n        Scrap.fromObject = function fromObject(object) {\n            if (object instanceof $root.Scrap)\n                return object;\n            var message = new $root.Scrap();\n            if (object.id != null)\n                message.id = String(object.id);\n            if (object.intendedDurationSec != null)\n                message.intendedDurationSec = object.intendedDurationSec >>> 0;\n            if (object.synopsis != null)\n                message.synopsis = String(object.synopsis);\n            if (object.prose != null)\n                message.prose = String(object.prose);\n            if (object.childScraps) {\n                if (!Array.isArray(object.childScraps))\n                    throw TypeError(\".Scrap.childScraps: array expected\");\n                message.childScraps = [];\n                for (var i = 0; i < object.childScraps.length; ++i)\n                    message.childScraps[i] = String(object.childScraps[i]);\n            }\n            switch (object.completeness) {\n            case \"NOT_STARTED\":\n            case 0:\n                message.completeness = 0;\n                break;\n            case \"BRAINSTORM\":\n            case 1:\n                message.completeness = 1;\n                break;\n            case \"INITIAL_DRAFT\":\n            case 2:\n                message.completeness = 2;\n                break;\n            case \"POLISHED\":\n            case 3:\n                message.completeness = 3;\n                break;\n            case \"FINAL\":\n            case 4:\n                message.completeness = 4;\n                break;\n            }\n            if (object.writingHistory) {\n                if (!Array.isArray(object.writingHistory))\n                    throw TypeError(\".Scrap.writingHistory: array expected\");\n                message.writingHistory = [];\n                for (var i = 0; i < object.writingHistory.length; ++i) {\n                    if (typeof object.writingHistory[i] !== \"object\")\n                        throw TypeError(\".Scrap.writingHistory: object expected\");\n                    message.writingHistory[i] = $root.Scrap.WritingHistory.fromObject(object.writingHistory[i]);\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a Scrap message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Scrap\n         * @static\n         * @param {Scrap} message Scrap\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Scrap.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.childScraps = [];\n                object.writingHistory = [];\n            }\n            if (options.defaults) {\n                object.id = \"\";\n                object.intendedDurationSec = 0;\n                object.synopsis = \"\";\n                object.prose = \"\";\n                object.completeness = options.enums === String ? \"NOT_STARTED\" : 0;\n            }\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                object.id = message.id;\n            if (message.intendedDurationSec != null && message.hasOwnProperty(\"intendedDurationSec\"))\n                object.intendedDurationSec = message.intendedDurationSec;\n            if (message.synopsis != null && message.hasOwnProperty(\"synopsis\"))\n                object.synopsis = message.synopsis;\n            if (message.prose != null && message.hasOwnProperty(\"prose\"))\n                object.prose = message.prose;\n            if (message.childScraps && message.childScraps.length) {\n                object.childScraps = [];\n                for (var j = 0; j < message.childScraps.length; ++j)\n                    object.childScraps[j] = message.childScraps[j];\n            }\n            if (message.completeness != null && message.hasOwnProperty(\"completeness\"))\n                object.completeness = options.enums === String ? $root.Scrap.Completeness[message.completeness] : message.completeness;\n            if (message.writingHistory && message.writingHistory.length) {\n                object.writingHistory = [];\n                for (var j = 0; j < message.writingHistory.length; ++j)\n                    object.writingHistory[j] = $root.Scrap.WritingHistory.toObject(message.writingHistory[j], options);\n            }\n            return object;\n        };\n    \n        /**\n         * Converts this Scrap to JSON.\n         * @function toJSON\n         * @memberof Scrap\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Scrap.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        /**\n         * Completeness enum.\n         * @name Scrap.Completeness\n         * @enum {number}\n         * @property {number} NOT_STARTED=0 NOT_STARTED value\n         * @property {number} BRAINSTORM=1 BRAINSTORM value\n         * @property {number} INITIAL_DRAFT=2 INITIAL_DRAFT value\n         * @property {number} POLISHED=3 POLISHED value\n         * @property {number} FINAL=4 FINAL value\n         */\n        Scrap.Completeness = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"NOT_STARTED\"] = 0;\n            values[valuesById[1] = \"BRAINSTORM\"] = 1;\n            values[valuesById[2] = \"INITIAL_DRAFT\"] = 2;\n            values[valuesById[3] = \"POLISHED\"] = 3;\n            values[valuesById[4] = \"FINAL\"] = 4;\n            return values;\n        })();\n    \n        Scrap.WritingHistory = (function() {\n    \n            /**\n             * Properties of a WritingHistory.\n             * @memberof Scrap\n             * @interface IWritingHistory\n             * @property {number|null} [minutesSinceEpoch] WritingHistory minutesSinceEpoch\n             * @property {number|null} [actualDurationSec] WritingHistory actualDurationSec\n             */\n    \n            /**\n             * Constructs a new WritingHistory.\n             * @memberof Scrap\n             * @classdesc Represents a WritingHistory.\n             * @implements IWritingHistory\n             * @constructor\n             * @param {Scrap.IWritingHistory=} [properties] Properties to set\n             */\n            function WritingHistory(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * WritingHistory minutesSinceEpoch.\n             * @member {number} minutesSinceEpoch\n             * @memberof Scrap.WritingHistory\n             * @instance\n             */\n            WritingHistory.prototype.minutesSinceEpoch = 0;\n    \n            /**\n             * WritingHistory actualDurationSec.\n             * @member {number} actualDurationSec\n             * @memberof Scrap.WritingHistory\n             * @instance\n             */\n            WritingHistory.prototype.actualDurationSec = 0;\n    \n            /**\n             * Creates a new WritingHistory instance using the specified properties.\n             * @function create\n             * @memberof Scrap.WritingHistory\n             * @static\n             * @param {Scrap.IWritingHistory=} [properties] Properties to set\n             * @returns {Scrap.WritingHistory} WritingHistory instance\n             */\n            WritingHistory.create = function create(properties) {\n                return new WritingHistory(properties);\n            };\n    \n            /**\n             * Encodes the specified WritingHistory message. Does not implicitly {@link Scrap.WritingHistory.verify|verify} messages.\n             * @function encode\n             * @memberof Scrap.WritingHistory\n             * @static\n             * @param {Scrap.IWritingHistory} message WritingHistory message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            WritingHistory.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.minutesSinceEpoch != null && Object.hasOwnProperty.call(message, \"minutesSinceEpoch\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.minutesSinceEpoch);\n                if (message.actualDurationSec != null && Object.hasOwnProperty.call(message, \"actualDurationSec\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.actualDurationSec);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified WritingHistory message, length delimited. Does not implicitly {@link Scrap.WritingHistory.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Scrap.WritingHistory\n             * @static\n             * @param {Scrap.IWritingHistory} message WritingHistory message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            WritingHistory.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a WritingHistory message from the specified reader or buffer.\n             * @function decode\n             * @memberof Scrap.WritingHistory\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Scrap.WritingHistory} WritingHistory\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            WritingHistory.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Scrap.WritingHistory();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.minutesSinceEpoch = reader.int32();\n                        break;\n                    case 2:\n                        message.actualDurationSec = reader.int32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a WritingHistory message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Scrap.WritingHistory\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Scrap.WritingHistory} WritingHistory\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            WritingHistory.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a WritingHistory message.\n             * @function verify\n             * @memberof Scrap.WritingHistory\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            WritingHistory.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.minutesSinceEpoch != null && message.hasOwnProperty(\"minutesSinceEpoch\"))\n                    if (!$util.isInteger(message.minutesSinceEpoch))\n                        return \"minutesSinceEpoch: integer expected\";\n                if (message.actualDurationSec != null && message.hasOwnProperty(\"actualDurationSec\"))\n                    if (!$util.isInteger(message.actualDurationSec))\n                        return \"actualDurationSec: integer expected\";\n                return null;\n            };\n    \n            /**\n             * Creates a WritingHistory message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof Scrap.WritingHistory\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {Scrap.WritingHistory} WritingHistory\n             */\n            WritingHistory.fromObject = function fromObject(object) {\n                if (object instanceof $root.Scrap.WritingHistory)\n                    return object;\n                var message = new $root.Scrap.WritingHistory();\n                if (object.minutesSinceEpoch != null)\n                    message.minutesSinceEpoch = object.minutesSinceEpoch | 0;\n                if (object.actualDurationSec != null)\n                    message.actualDurationSec = object.actualDurationSec | 0;\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a WritingHistory message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Scrap.WritingHistory\n             * @static\n             * @param {Scrap.WritingHistory} message WritingHistory\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            WritingHistory.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.minutesSinceEpoch = 0;\n                    object.actualDurationSec = 0;\n                }\n                if (message.minutesSinceEpoch != null && message.hasOwnProperty(\"minutesSinceEpoch\"))\n                    object.minutesSinceEpoch = message.minutesSinceEpoch;\n                if (message.actualDurationSec != null && message.hasOwnProperty(\"actualDurationSec\"))\n                    object.actualDurationSec = message.actualDurationSec;\n                return object;\n            };\n    \n            /**\n             * Converts this WritingHistory to JSON.\n             * @function toJSON\n             * @memberof Scrap.WritingHistory\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            WritingHistory.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return WritingHistory;\n        })();\n    \n        return Scrap;\n    })();\n    \n    $root.WritingWorkspace = (function() {\n    \n        /**\n         * Properties of a WritingWorkspace.\n         * @exports IWritingWorkspace\n         * @interface IWritingWorkspace\n         * @property {Array.<IScrap>|null} [scraps] WritingWorkspace scraps\n         * @property {string|null} [author] WritingWorkspace author\n         * @property {string|null} [contactInfo] WritingWorkspace contactInfo\n         */\n    \n        /**\n         * Constructs a new WritingWorkspace.\n         * @exports WritingWorkspace\n         * @classdesc Represents a WritingWorkspace.\n         * @implements IWritingWorkspace\n         * @constructor\n         * @param {IWritingWorkspace=} [properties] Properties to set\n         */\n        function WritingWorkspace(properties) {\n            this.scraps = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * WritingWorkspace scraps.\n         * @member {Array.<IScrap>} scraps\n         * @memberof WritingWorkspace\n         * @instance\n         */\n        WritingWorkspace.prototype.scraps = $util.emptyArray;\n    \n        /**\n         * WritingWorkspace author.\n         * @member {string} author\n         * @memberof WritingWorkspace\n         * @instance\n         */\n        WritingWorkspace.prototype.author = \"\";\n    \n        /**\n         * WritingWorkspace contactInfo.\n         * @member {string} contactInfo\n         * @memberof WritingWorkspace\n         * @instance\n         */\n        WritingWorkspace.prototype.contactInfo = \"\";\n    \n        /**\n         * Creates a new WritingWorkspace instance using the specified properties.\n         * @function create\n         * @memberof WritingWorkspace\n         * @static\n         * @param {IWritingWorkspace=} [properties] Properties to set\n         * @returns {WritingWorkspace} WritingWorkspace instance\n         */\n        WritingWorkspace.create = function create(properties) {\n            return new WritingWorkspace(properties);\n        };\n    \n        /**\n         * Encodes the specified WritingWorkspace message. Does not implicitly {@link WritingWorkspace.verify|verify} messages.\n         * @function encode\n         * @memberof WritingWorkspace\n         * @static\n         * @param {IWritingWorkspace} message WritingWorkspace message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        WritingWorkspace.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.scraps != null && message.scraps.length)\n                for (var i = 0; i < message.scraps.length; ++i)\n                    $root.Scrap.encode(message.scraps[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.author != null && Object.hasOwnProperty.call(message, \"author\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.author);\n            if (message.contactInfo != null && Object.hasOwnProperty.call(message, \"contactInfo\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.contactInfo);\n            return writer;\n        };\n    \n        /**\n         * Encodes the specified WritingWorkspace message, length delimited. Does not implicitly {@link WritingWorkspace.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof WritingWorkspace\n         * @static\n         * @param {IWritingWorkspace} message WritingWorkspace message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        WritingWorkspace.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n    \n        /**\n         * Decodes a WritingWorkspace message from the specified reader or buffer.\n         * @function decode\n         * @memberof WritingWorkspace\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {WritingWorkspace} WritingWorkspace\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        WritingWorkspace.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WritingWorkspace();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 2:\n                    if (!(message.scraps && message.scraps.length))\n                        message.scraps = [];\n                    message.scraps.push($root.Scrap.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.author = reader.string();\n                    break;\n                case 4:\n                    message.contactInfo = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        /**\n         * Decodes a WritingWorkspace message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof WritingWorkspace\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {WritingWorkspace} WritingWorkspace\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        WritingWorkspace.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n    \n        /**\n         * Verifies a WritingWorkspace message.\n         * @function verify\n         * @memberof WritingWorkspace\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        WritingWorkspace.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.scraps != null && message.hasOwnProperty(\"scraps\")) {\n                if (!Array.isArray(message.scraps))\n                    return \"scraps: array expected\";\n                for (var i = 0; i < message.scraps.length; ++i) {\n                    var error = $root.Scrap.verify(message.scraps[i]);\n                    if (error)\n                        return \"scraps.\" + error;\n                }\n            }\n            if (message.author != null && message.hasOwnProperty(\"author\"))\n                if (!$util.isString(message.author))\n                    return \"author: string expected\";\n            if (message.contactInfo != null && message.hasOwnProperty(\"contactInfo\"))\n                if (!$util.isString(message.contactInfo))\n                    return \"contactInfo: string expected\";\n            return null;\n        };\n    \n        /**\n         * Creates a WritingWorkspace message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof WritingWorkspace\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {WritingWorkspace} WritingWorkspace\n         */\n        WritingWorkspace.fromObject = function fromObject(object) {\n            if (object instanceof $root.WritingWorkspace)\n                return object;\n            var message = new $root.WritingWorkspace();\n            if (object.scraps) {\n                if (!Array.isArray(object.scraps))\n                    throw TypeError(\".WritingWorkspace.scraps: array expected\");\n                message.scraps = [];\n                for (var i = 0; i < object.scraps.length; ++i) {\n                    if (typeof object.scraps[i] !== \"object\")\n                        throw TypeError(\".WritingWorkspace.scraps: object expected\");\n                    message.scraps[i] = $root.Scrap.fromObject(object.scraps[i]);\n                }\n            }\n            if (object.author != null)\n                message.author = String(object.author);\n            if (object.contactInfo != null)\n                message.contactInfo = String(object.contactInfo);\n            return message;\n        };\n    \n        /**\n         * Creates a plain object from a WritingWorkspace message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof WritingWorkspace\n         * @static\n         * @param {WritingWorkspace} message WritingWorkspace\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        WritingWorkspace.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.scraps = [];\n            if (options.defaults) {\n                object.author = \"\";\n                object.contactInfo = \"\";\n            }\n            if (message.scraps && message.scraps.length) {\n                object.scraps = [];\n                for (var j = 0; j < message.scraps.length; ++j)\n                    object.scraps[j] = $root.Scrap.toObject(message.scraps[j], options);\n            }\n            if (message.author != null && message.hasOwnProperty(\"author\"))\n                object.author = message.author;\n            if (message.contactInfo != null && message.hasOwnProperty(\"contactInfo\"))\n                object.contactInfo = message.contactInfo;\n            return object;\n        };\n    \n        /**\n         * Converts this WritingWorkspace to JSON.\n         * @function toJSON\n         * @memberof WritingWorkspace\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        WritingWorkspace.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n    \n        return WritingWorkspace;\n    })();\n\n    return $root;\n});\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit';\nimport {RootState} from '../../app/store';\nimport {CharacterAppearance} from '../utils/fetchCharacters';\nimport {TraitAppearance} from '../utils/fetchTraits';\nimport {SearchResult} from '../scrapDetails/SearchModal';\n\nexport interface HeaderOptions {\n  currentScrapId: string;\n  showEditLink: boolean;\n  showReadLink: boolean;\n  showPrintLink: boolean;\n  characterFilters: CharacterAppearance[];\n  currentCharacterFilter?: string;\n  currentCompletionFilter?: string;\n  traitFilters: TraitAppearance[];\n  currentTraitFilter?: string;\n  isCurrentlyInSession: boolean; // In a timed writing session\n  currentWritingSessionStartEpoch: number;\n  lastCheckedWritingSessionEpoch: number;\n  // Search result stuff:\n  searchModalOpen: boolean;\n  currentSearchQuery: string;\n  currentSearchResults: SearchResult[];\n  includeTitlePage: boolean;\n}\n\ninterface headerOptionsInState {\n  headerOptions: {\n    options: HeaderOptions\n  }\n}\n\nconst initialState = {\n  options: {\n    currentScrapId: '',\n    showEditLink: false,\n    showReadLink: false,\n    showPrintLink: false,\n    characterFilters: [],\n    currentCharacterFilter: '',\n    currentCompletionFilter: '',\n    traitFilters: [],\n    currentTraitFilter: '',\n    isCurrentlyInSession: false,\n    currentWritingSessionStartEpoch: 0,\n    lastCheckedWritingSessionEpoch: 0,\n    // Things for the search modal:\n    searchModalOpen: false,\n    currentSearchQuery: '',\n    currentSearchResults: [],\n    // For printing\n    includeTitlePage: false,\n  } as HeaderOptions\n};\n\n\nconst actionPrefix = 'headerOptions';\n\nconst headerOptionsSlice = createSlice({\n  name: actionPrefix,\n  initialState,\n  reducers: {\n    updateHeaderOptions(state, action: PayloadAction<object>) {\n      state.options = {\n        ...state.options,\n        ...action.payload\n      } as HeaderOptions;\n    },\n  }\n});\n\nexport const readHeaderOptions = (state: headerOptionsInState|RootState): HeaderOptions => {\n  return state.headerOptions.options;\n}\n\nexport const { updateHeaderOptions } = headerOptionsSlice.actions;\nexport default headerOptionsSlice.reducer;\n","\n\nexport function durationSecondsToString(durationSeconds: number): string {\n  let durationStr = '';\n\n  const hours = Math.floor(durationSeconds / 3600);\n  durationSeconds -= 3600 * hours;\n  durationStr += hours.toString().padStart(2, '0') + ':';\n\n  const minutes = Math.floor(durationSeconds / 60);\n  durationSeconds -= 60 * minutes;\n  durationStr += minutes.toString().padStart(2, '0') + ':';\n\n  durationStr += Math.round(durationSeconds).toString().padStart(2, '0');\n\n  return durationStr;\n}\n\nexport function durationStringToSeconds(durationString: string): number {\n  const expectedRegex = new RegExp('^[0-9:]+$');\n  if (!expectedRegex.test(durationString)) {\n    throw Error('Invalid duration string');\n  }\n\n  const splitDurationStr = durationString.split(':').filter(Boolean);\n\n  if (splitDurationStr.length > 3) {\n    throw Error('Invalid duration string');\n  }\n\n  let durationSec = 0;\n  for (let i = 0; i < splitDurationStr.length; i++) {\n    durationSec = (60 * durationSec) + parseInt(splitDurationStr[i], 10);\n  }\n\n  return durationSec;\n}\n","import {Input, Modal} from 'semantic-ui-react';\nimport {ScrapMap} from '../scrapList/scrapListSlice';\nimport {Scrap} from '../../protos_v2';\nimport {\n  Link\n} from 'react-router-dom';\nimport React from 'react';\nimport {durationSecondsToString} from '../utils/durationUtils';\n\nexport interface SearchResult {\n  scrap: Scrap;\n  score: number;\n  preview: string;\n}\n\nconst MAX_SEARCH_RESULTS = 5;\nconst EACH_SEARCH_RESULT_HEIGHT_PX = 120;\n\nfunction computeSearchResults(scrapMap: ScrapMap, query: string): SearchResult[] {\n  if (!query.length) {\n    return [];\n  }\n\n  return Object.values(scrapMap)\n      .map((scrap): SearchResult|null => {\n        if (!scrap.prose.toLowerCase().includes(query.toLowerCase())) {\n          return null;\n        }\n\n        let firstIndex = scrap.prose.toLowerCase().indexOf(query.toLowerCase());\n\n        firstIndex = Math.max(0, firstIndex - 30);\n\n        return {\n          scrap: scrap,\n          score: scrap.intendedDurationSec,\n          preview: scrap.prose.substring(firstIndex, firstIndex + 150),\n        };\n      })\n      .filter(Boolean)\n      .sort((a, b) => {\n        // @ts-ignore\n        return b.score - a.score;\n      })\n      .slice(0, 5) as SearchResult[]; // Final casting required since TS doesn't understand the filter(Boolean) bit\n}\n\nfunction formatSearchResults(currentSearchQuery: string, currentSearchResults: SearchResult[], onSelect: () => void): JSX.Element {\n  const minHeightPx = MAX_SEARCH_RESULTS * (8 + EACH_SEARCH_RESULT_HEIGHT_PX);\n\n  if (!currentSearchQuery) {\n    return <div style={{minHeight: `${minHeightPx}px`}}>&nbsp;</div>;\n  }\n\n  if (!currentSearchResults.length) {\n    return <div style={{minHeight: `${minHeightPx}px`}}>No results</div>;\n  }\n\n  return <div style={{minHeight: `${minHeightPx}px`}}>\n    {currentSearchResults.map((result) => {\n      return <div style={{\n        marginBottom: '8px',\n        height: `${EACH_SEARCH_RESULT_HEIGHT_PX}px`,\n        display: 'flex',\n        flexDirection: 'column',\n      }}>\n        <Link to={'/scrap/' + result.scrap.id}>\n          <span style={{fontSize: '16px'}} onClick={onSelect}>\n            {result.scrap.synopsis} ({durationSecondsToString(result.scrap.intendedDurationSec)})\n          </span>\n        </Link>\n        <pre style={{\n          background: 'lightgrey',\n          flex: '1',\n          overflowY: 'scroll',\n        }}>\n          ...{result.preview}...\n        </pre>\n      </div>\n    })}\n  </div>\n}\n\nexport function getSearchModal(isOpen: boolean, currentSearchQuery: string, currentSearchResults: SearchResult[], scrapMap: ScrapMap, onSearchQueryChange: (newQuery: string, newResults: SearchResult[]) => void, onClose: () => void) {\n\n  return <Modal\n      open={isOpen}\n      onClose={onClose}\n      closeOnDimmerClick={true}\n      closeOnEscape={true}\n    >\n    <Modal.Header>Search</Modal.Header>\n    <Modal.Content>\n      <Input\n          style={{display: 'block', marginBottom: '24px'}}\n          placeholder={'Search across all scraps'}\n          onChange={(e) => {\n            const results = computeSearchResults(scrapMap, e.target.value);\n            onSearchQueryChange(e.target.value, results);}}\n          value={currentSearchQuery}/>\n      {formatSearchResults(currentSearchQuery, currentSearchResults, onClose)}\n    </Modal.Content>\n  </Modal>\n}\n","import {IScrap, Scrap} from '../../protos_v2';\nimport {ScrapMapInState} from './scrapListSlice';\n\nconst allScrapIdsKey = 'scrap-ids';\n\nfunction scrapKey(id: string): string {\n  return `scrap-${id}`;\n}\n\nexport function readAllScrapsFromStorage(): Scrap[] {\n  return readScrapIds().map((id) => {\n    return readScrap(id);\n  });\n}\n\nfunction readScrapIds(): string[] {\n  let storyIdString = localStorage.getItem(allScrapIdsKey) || '[]';\n  return JSON.parse(storyIdString) as string[];\n}\n\nfunction writeScrapIds(scrapIds: string[]): void {\n  localStorage.setItem(allScrapIdsKey, JSON.stringify(scrapIds));\n}\n\nfunction readScrap(id: string): Scrap {\n  let scrapString = localStorage.getItem(scrapKey(id));\n  if (!scrapString) {\n    throw Error(`Unable to read scrap ${id} from local storage`);\n  }\n\n  return Scrap.create(JSON.parse(scrapString));\n}\n\nexport function writeScrap(scrap: IScrap) {\n  localStorage.setItem(scrapKey(scrap.id as string), JSON.stringify(scrap));\n}\n\nexport function addScrapToStorage(scrap: IScrap): void {\n  writeScrap(scrap);\n\n  const allScrapIds = readScrapIds();\n  allScrapIds.push(scrap.id as string);\n  writeScrapIds(allScrapIds);\n}\n\n\nexport function clearScrapFromStorage(idToRemove: string): void {\n  let allScrapIds = readScrapIds();\n\n  writeScrapIds(allScrapIds.filter((id) => {\n    return id !== idToRemove;\n  }));\n\n  localStorage.removeItem(scrapKey(idToRemove));\n}\n\nexport function fetchInitialStateFromStorage() {\n  const initialState = {\n    scrapMap: {} as ScrapMapInState\n  };\n  readAllScrapsFromStorage().forEach((scrap) => {\n    initialState.scrapMap[scrap.id] = scrap.toJSON();\n  });\n\n  return initialState;\n}\n","import React from 'react';\n\nexport const LINES_PER_PAGE = 55;\nexport const ONE_LINE_DURATION_SEC = 1.0909; // (1 / LINES_PER_PAGE * 60);\nexport const PAGE_WIDTH_EM = '37em';\n\n/** Fields on the data for a block of parsed text */\nexport const scrapIdField = 'scrapId'; // Indicates which scrap defines this block of prose\nexport const ancestorField = 'ancestorField'; // Array of ancestor scrap IDs, excluding the current one\n\nexport const pendingDurationSecContribution = 'pendingDurationSecContribution'; // Seconds (perhaps partial) which will be contributed, when this is actually written\nexport const durationSecContribution = 'durationSecContribution'; // Seconds (perhaps partial) contributed to the script duration\n\nexport const isScrapTrait = 'isScrapTrait';\nexport const scrapTraitText = 'scrapTraitText';\nexport const isScrapPlaceholder = 'isScrapPlaceholder';\nexport const scrapPlaceholderText = 'scrapPlaceholderText';\nexport const scrapPlaceholderDurationSecField = 'scrapPlaceholderDurationSecField';\nexport const isScrapEmbedding = 'isScrapEmbedding';\nexport const scrapLink = 'scrapLink';\nexport const isFountainHeader = 'isFountainHeader';\nexport const isFountainCentered = 'isFountainCentered';\nexport const isFountainTransition = 'isFountainTransition';\nexport const isBlank = 'isBlank';\nexport const isComment = 'isComment';\nexport const isCommentStart = 'isCommentStart';\nexport const isCommentEnd = 'isCommentEnd';\nexport const isFountainCharacter = 'isFountainCharacter';\nexport const character = 'character';\nexport const isFountainDialogue = 'isFountainDialogue';\nexport const isFountainParenthetical = 'isFountainParenthetical';\nexport const isFountainAction = 'isFountainAction';\n\nexport const FOUNTAIN_EDITOR_STYLE: React.CSSProperties = {\n  border: '1px solid',\n  padding: '6em',\n  margin: 'auto',\n  width: '49em', // PAGE_WIDTH_EM + padding\n  overflowY: 'scroll',\n  fontSize: '16px',\n  fontFamily: 'CourierPrime, Courier, monospace',\n  flex: '1'\n}\n\nexport function mergeDataObject(dataObject: { [index: string]: boolean|string|number}, newData: { [index: string]: boolean|string|number}): { [index: string]: boolean|string|number} {\n  return {\n    ...dataObject,\n    ...newData\n  };\n}\n","import {ContentState} from 'draft-js';\nimport {PAGE_WIDTH_EM, scrapIdField} from './usefulConstants';\nimport React, {Component, ReactElement} from 'react';\nimport {Link} from 'react-router-dom';\nimport {Button} from 'semantic-ui-react';\n\ninterface FountainReadOnlyState {\n  isHover: boolean;\n  scrapId: string;\n}\n\nconst parseScrapIdFromProps = (props: any) => {\n  const contentState = props.contentState as ContentState;\n  const data = contentState.getBlockMap().get(props.blockKey).getData();\n  return data.get(scrapIdField);\n}\n\nexport class BaseReadOnlyComponent extends Component<any, FountainReadOnlyState> {\n\n  constructor(props: any) {\n    super(props);\n\n    this.state = {\n      isHover: false,\n      scrapId: parseScrapIdFromProps(props)\n    }\n  }\n\n  buildScrapLinkButton(): ReactElement|null {\n    if (!this.state.isHover) {\n      return null;\n    }\n\n    const scrapLink = `/scrap/${this.state.scrapId}`;\n\n    return <Link to={scrapLink}>\n      <Button style={{cursor: 'pointer', position: 'absolute', top: '-12px', right: '-20px'}} circular color='blue' icon='edit outline' />\n    </Link>;\n  }\n\n  onMouseEnter(): void {\n    this.setState({\n      isHover: true\n    });\n  }\n\n  onMouseLeave(): void {\n    this.setState({\n      isHover: false\n    });\n  }\n\n  getParentStyle(): any {\n    const style: React.CSSProperties = {\n      position: 'relative',\n      paddingRight: '20px',\n      width: PAGE_WIDTH_EM,\n      margin: 0,\n    };\n\n    if (this.props.isFilterSelected) {\n      style.backgroundColor = '#f6f6c6';\n    }\n\n    if (this.state.isHover) {\n      style.backgroundColor = '#c6e1f6';\n    }\n\n    return style;\n  }\n\n  renderSpecific() {\n    return <span>{this.props.children}</span>\n  }\n\n  render() {\n    return (\n        <div style={this.getParentStyle()}\n             onMouseEnter={() => {this.onMouseEnter();}}\n             onMouseLeave={() => {this.onMouseLeave();}}>\n          {this.renderSpecific()}\n          {this.buildScrapLinkButton()}\n        </div>\n    );\n  }\n}\n","import React from 'react';\nimport {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isFountainHeader, ONE_LINE_DURATION_SEC, PAGE_WIDTH_EM} from './usefulConstants';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\nexport function fountainHeaderStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainHeader)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsSceneHeader(blankBefore: boolean, blankAfter: boolean, blockText: string): boolean {\n  return blankBefore && blankAfter && ((/^(int|ext|est|i\\/e)[\\s.]/i).test(blockText) || (blockText.startsWith('.') && !blockText.startsWith('..')));\n}\n\nexport function sceneHeaderDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC; // Assume one line per scene heading\n}\n\nexport function sceneHeaderData(blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainHeader]: true,\n    [durationSecContribution]: sceneHeaderDurationSec(blockText),\n  }\n}\n\n/**\n * Component to show a Fountain scene header in DraftJS.\n *\n */\nexport const FountainHeaderComponent = (props: any) => {\n  return (\n      <div style={{fontWeight: 'bold', width: PAGE_WIDTH_EM}} >{props.children}</div>\n  );\n}\n\nexport class FountainHeaderReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainHeaderComponent(this.props);\n  }\n}\n","// Props are:\n// https://github.com/facebook/draft-js/blob/main/src/model/decorators/DraftDecorator.js#L54-L71\nimport {ContentBlock, ContentState} from 'draft-js';\nimport React, {Component} from 'react';\nimport {useAppSelector} from '../../app/hooks';\nimport {ScrapMap, selectScrapMap} from '../scrapList/scrapListSlice';\nimport {\n  useHistory, useLocation\n} from 'react-router-dom';\nimport {durationSecondsToString} from '../utils/durationUtils';\nimport {Button, Icon} from 'semantic-ui-react';\nimport {isComment, isScrapEmbedding, scrapLink} from './usefulConstants';\n\nexport function scrapEmbeddingStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isScrapEmbedding)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsScrapEmbed(blockText: string): boolean {\n  if (!blockText.startsWith('{{') || !blockText.endsWith('}}')) {\n    return false;\n  }\n\n  return !(blockText.includes('|') || blockText.includes('@') || blockText.includes('#'));\n}\n\nexport function scrapEmbedData(blockText: string): { [index: string]: boolean|string} {\n  const scrapId = blockText.replace('{{', '').replace('}}', '').trim();\n\n  return {\n    [scrapLink]: scrapId,\n    [isScrapEmbedding]: true,\n  }\n}\n\n/**\n * Embedded component to show a scrap in a DraftJS editor.\n *\n * Assumes that `scrapLink` on the block's data contains the ID\n * */\nexport const ScrapEmbedComponent = (props: any) => {\n  const contentState = props.contentState as ContentState;\n  const data = contentState.getBlockMap().get(props.blockKey).getData();\n  const scrapId = data.get(scrapLink);\n  const inComment = data.get(isComment);\n\n  const scrapMap = useAppSelector(selectScrapMap);\n  const history = useHistory();\n  const currentLocation = useLocation();\n\n  const parentScrapId = getScrapIdFromUrl(currentLocation.pathname);\n\n  const backgroundColor = inComment ? '#cfead9' : '#555';\n\n  return (\n      <div\n          style={{\n            background: backgroundColor,\n            fontWeight: 'bold',\n            display: 'flex',\n            flexDirection: 'column',\n            padding: '8px'\n          }}\n      >\n        <div style={{\n          color: 'white'\n\n        }}>{props.children}</div>\n        <div style={{flex: '1', cursor: 'pointer', padding: '8px', border: '1px solid', background: 'white', fontWeight: 'normal'}}>\n          <ScrapEmbedSummary\n            parentScrapId={parentScrapId}\n            scrapId={scrapId}\n            scrapMap={scrapMap}\n            onGotoScrap={() => { history.push(`/scrap/${scrapId}`) }}\n          />\n        </div>\n      </div>\n  );\n}\n\nfunction getScrapIdFromUrl(url: string): string {\n  return url.replace('/scrap/', '');\n}\n\n\ninterface ScrapEmbedSummaryProps {\n  parentScrapId: string;\n  scrapId: string;\n  scrapMap: ScrapMap;\n  onGotoScrap: () => void;\n}\n\nexport class ScrapEmbedSummary extends Component<ScrapEmbedSummaryProps> {\n  render() {\n    const scrap = this.props.scrapMap[this.props.scrapId];\n\n    if (!scrap) {\n      return (<div>\n        Scrap \"{this.props.scrapId}\" does not exist.\n      </div>)\n    }\n\n    if (this.props.scrapId === this.props.parentScrapId) {\n      return (<div style={{color: 'red'}}>\n        Scraps shouldn't include themselves\n      </div>);\n    }\n\n    return (<div style={{display: 'flex'}}>\n      <Button icon color='blue'\n              onClick={() => {this.props.onGotoScrap();}}\n      >\n        <Icon name='angle right' />\n      </Button>\n      <div style={{marginLeft: '24px', flex: '1'}}>\n        <div>{scrap.synopsis}</div>\n        <div>{durationSecondsToString(scrap.intendedDurationSec)}</div>\n      </div>\n    </div>);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isFountainTransition, ONE_LINE_DURATION_SEC, PAGE_WIDTH_EM} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\n\nexport function fountainTransitionStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainTransition)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsSceneTransition(blankBefore: boolean, blankAfter: boolean, blockText: string): boolean {\n  return blankBefore && blankAfter && ((blockText.startsWith('>') && !blockText.endsWith('<')) || (blockText.toUpperCase() === blockText && blockText.endsWith('TO:')));\n}\n\nexport function sceneTransitionDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC; // Assume one line per scene heading\n}\n\nexport function sceneTransitionData(blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainTransition]: true,\n    [durationSecContribution]: sceneTransitionDurationSec(blockText)\n  }\n}\n\n/**\n * Component to show a Fountain transition in DraftJS.\n *\n */\nexport const FountainTransitionComponent = (props: any) => {\n  return (\n      <div style={{fontWeight: 'bold', textAlign: 'right', width: PAGE_WIDTH_EM}} >{props.children}</div>\n  );\n}\n\n\nexport class FountainTransitionReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainTransitionComponent(this.props);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isFountainCentered, ONE_LINE_DURATION_SEC, PAGE_WIDTH_EM} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\n\nexport function fountainCenteredStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainCentered)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsCentered(blockText: string): boolean {\n  return blockText.startsWith('>') && blockText.endsWith('<');\n}\n\nexport function sceneCenteredDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC; // Assume one line per scene heading\n}\n\n\nexport function sceneCenteredData(blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainCentered]: true,\n    [durationSecContribution]: sceneCenteredDurationSec(blockText),\n  }\n}\n\n/**\n * Component to show a Fountain \"centered\" element in DraftJS.\n *\n */\nexport const FountainCenteredComponent = (props: any) => {\n  return (\n      <div style={{fontWeight: 'bold', textAlign: 'center', width: PAGE_WIDTH_EM}} >{props.children}</div>\n  );\n}\n\nexport class FountainCenteredReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainCenteredComponent(this.props);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {character, durationSecContribution, isFountainCharacter, ONE_LINE_DURATION_SEC} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\nimport {useAppSelector} from '../../app/hooks';\nimport {readHeaderOptions} from '../revision-header/headerOptionsSlice';\n\nexport function fountainCharacterStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainCharacter)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsCharacter(blankBefore: boolean, blankAfter: boolean, blockText: string): boolean {\n  return blankBefore && !blankAfter && (blockText.toUpperCase() === blockText || blockText.startsWith('@'));\n}\n\nexport function characterDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC * Math.ceil(blockText.length / 28); // About 28 characters per line\n}\n\nexport function characterData(blockText: string): { [index: string]: boolean|string|number} {\n  const parsedCharacter = blockText\n      .replace(/\\(V\\.O\\.\\)/i, '')\n      .replace(/\\(O\\.S\\.\\)/i, '')\n      .replace(/\\(CONT'D\\)/i, '')\n      .replace(/\\(CONT’D\\)/i, '')\n      .replace(/\\(PRE-LAP\\)/i, '')\n      .trim();\n\n  return {\n    [isFountainCharacter]: true,\n    [character]: parsedCharacter,\n    [durationSecContribution]: characterDurationSec(blockText)\n  }\n}\n\n/**\n * Component to show a Fountain character in DraftJS.\n *\n */\nexport const FountainCharacterComponent = (props: any) => {\n  return (\n      <div style={{fontWeight: 'bold', marginLeft: '12em', width: '17em'}} >{props.children}</div>\n  );\n}\n\n\nclass FountainCharacterReadOnlyClassComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainCharacterComponent(this.props);\n  }\n}\n\nexport const FountainCharacterReadOnlyComponent = (props: any) => {\n  let isFilterSelected = false;\n  let characterFilter = useAppSelector(readHeaderOptions).currentCharacterFilter;\n\n  const contentState = props.contentState as ContentState;\n  const data = contentState.getBlockMap().get(props.blockKey).getData();\n  if (characterFilter === data.get(character)) {\n    isFilterSelected = true;\n  }\n\n  return (\n      <FountainCharacterReadOnlyClassComponent\n          blockKey={props.blockKey}\n          contentState={props.contentState}\n          isFilterSelected={isFilterSelected}\n          key={props.key}\n          children={props.children} />\n  );\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {character, durationSecContribution, isFountainDialogue, ONE_LINE_DURATION_SEC} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\nimport {useAppSelector} from '../../app/hooks';\nimport {readHeaderOptions} from '../revision-header/headerOptionsSlice';\n\nexport function fountainDialogueStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainDialogue)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsDialogue(characterBefore: string, blockText: string): boolean {\n  return !!characterBefore && (!blockText.startsWith('(') || !blockText.endsWith(')'));\n}\n\nexport function dialogueDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC * Math.ceil(blockText.length / 36); // About 36 characters per line of dialogue fit\n}\n\nexport function dialogueData(characterBefore: string, blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainDialogue]: true,\n    [character]: characterBefore,\n    [durationSecContribution]: dialogueDurationSec(blockText)\n  }\n}\n\n/**\n * Component to show Fountain dialogue in DraftJS.\n *\n */\nexport const FountainDialogueComponent = (props: any) => {\n  return (\n      <div style={{marginLeft: '6em', width: '23.5em'}} >{props.children}</div>\n  );\n}\n\nclass FountainDialogueReadOnlyClassComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainDialogueComponent(this.props);\n  }\n}\n\nexport const FountainDialogueReadOnlyComponent = (props: any) => {\n  let isFilterSelected = false;\n  let characterFilter = useAppSelector(readHeaderOptions).currentCharacterFilter;\n\n  const contentState = props.contentState as ContentState;\n  const data = contentState.getBlockMap().get(props.blockKey).getData();\n  if (characterFilter === data.get(character)) {\n    isFilterSelected = true;\n  }\n\n  return (\n      <FountainDialogueReadOnlyClassComponent\n          blockKey={props.blockKey}\n          contentState={props.contentState}\n          isFilterSelected={isFilterSelected}\n          key={props.key}\n          children={props.children} />\n  );\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {character, durationSecContribution, isFountainParenthetical, ONE_LINE_DURATION_SEC} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\nimport {useAppSelector} from '../../app/hooks';\nimport {readHeaderOptions} from '../revision-header/headerOptionsSlice';\n\nexport function fountainParentheticalStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainParenthetical)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsParenthetical(characterBefore: string, blockText: string): boolean {\n  return !!characterBefore && blockText.startsWith('(') && blockText.endsWith(')');\n}\n\nexport function parentheticalDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC * Math.ceil(blockText.length / 30); // About 30 characters per line\n}\n\nexport function parentheticalData(characterBefore: string, blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainParenthetical]: true,\n    [character]: characterBefore,\n    [durationSecContribution]: parentheticalDurationSec(blockText)\n  }\n}\n\n/**\n * Component to show Fountain parenthetical in DraftJS.\n *\n */\nexport const FountainParentheticalComponent = (props: any) => {\n  return (\n      <div style={{marginLeft: '8.5em', width: '19.5em'}} >{props.children}</div>\n  );\n}\n\nclass FountainParentheticalReadOnlyClassComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainParentheticalComponent(this.props);\n  }\n}\n\nexport const FountainParentheticalReadOnlyComponent = (props: any) => {\n  let isFilterSelected = false;\n  let characterFilter = useAppSelector(readHeaderOptions).currentCharacterFilter;\n\n  const contentState = props.contentState as ContentState;\n  const data = contentState.getBlockMap().get(props.blockKey).getData();\n  if (characterFilter === data.get(character)) {\n    isFilterSelected = true;\n  }\n\n  return (\n      <FountainParentheticalReadOnlyClassComponent\n          blockKey={props.blockKey}\n          contentState={props.contentState}\n          isFilterSelected={isFilterSelected}\n          key={props.key}\n          children={props.children} />\n  );\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isFountainAction, ONE_LINE_DURATION_SEC, PAGE_WIDTH_EM} from './usefulConstants';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\nexport function fountainActionStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isFountainAction)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function actionDurationSec(blockText: string): number {\n  return ONE_LINE_DURATION_SEC * Math.ceil(blockText.length / 56); // About 56 characters per line of action\n}\n\nexport function actionData(blockText: string): { [index: string]: boolean|string|number} {\n  return {\n    [isFountainAction]: true,\n    [durationSecContribution]: actionDurationSec(blockText),\n  }\n}\n\n/**\n * Component to show a Fountain action line in DraftJS.\n *\n */\nexport const FountainActionComponent = (props: any) => {\n  return (\n      <div style={{width: PAGE_WIDTH_EM}} >{props.children}</div>\n  );\n}\n\nexport class FountainActionReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    return FountainActionComponent(this.props);\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {durationSecContribution, isScrapPlaceholder, ONE_LINE_DURATION_SEC, pendingDurationSecContribution, scrapPlaceholderDurationSecField, scrapPlaceholderText} from './usefulConstants';\nimport {durationSecondsToString, durationStringToSeconds} from '../utils/durationUtils';\nimport React from 'react';\nimport {BaseReadOnlyComponent} from './BaseReadOnlyComponent';\n\nexport function scrapPlaceholderStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isScrapPlaceholder)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsScrapPlaceholder(blockText: string): boolean {\n  if (!blockText.startsWith('{{') || !blockText.endsWith('}}')) {\n    return false;\n  }\n\n  let splitText = blockText.split('|');\n  return splitText.length === 2;\n}\n\nexport function scrapPlaceholderData(blockText: string): { [index: string]: boolean|string|number} {\n  const content = blockText.replace('{{', '').replace('}}', '').trim().split('|');\n\n  const placeholderText = content[0].trim();\n  let durationSec = 0;\n  try {\n    durationSec = durationStringToSeconds(content[1].trim());\n  } catch {}\n\n  return {\n    [scrapPlaceholderText]: placeholderText,\n    [scrapPlaceholderDurationSecField]: durationSec,\n    [isScrapPlaceholder]: true,\n    [durationSecContribution]: scrapPlaceholderDurationSec(blockText),\n    [pendingDurationSecContribution]: scrapPlaceholderDurationSec(blockText),\n  }\n}\n\nexport function scrapPlaceholderDurationSec(blockText: string): number {\n  const content = blockText.replace('{{', '').replace('}}', '').trim();\n\n  try {\n    let durationStr = content.split('|')[1].trim();\n    return durationStringToSeconds(durationStr);\n  } catch {\n    // Invalid duration string\n  }\n\n  return 0;\n}\n\nexport const ScrapPlaceholderComponent = (props: any) => {\n  return <div\n      style={{\n        background: '#050',\n        color: 'white',\n        display: 'flex',\n        padding: '8px'\n      }}\n  >\n    <div style={{flex: 1}}>{props.children}</div>\n  </div>\n}\n\n\nexport class ScrapPlaceholderReadOnlyComponent extends BaseReadOnlyComponent {\n  renderSpecific(): JSX.Element {\n    const contentState = this.props.contentState as ContentState;\n    const data = contentState.getBlockMap().get(this.props.blockKey).getData();\n    const placeholderText = data.get(scrapPlaceholderText);\n    const durationSec = data.get(scrapPlaceholderDurationSecField);\n\n    const displayText = `${placeholderText}: ${durationSecondsToString(durationSec)}`;\n    const linesOfText = Math.ceil(displayText.length / 60) + 4; // 40px margin top/bottom\n    const numberOfLines = Math.ceil(durationSec / ONE_LINE_DURATION_SEC);\n    const heightStyle = `${20 * numberOfLines}px`;\n    // line = 20px\n\n    const numberOfInstances = Math.ceil(0.01 + numberOfLines / linesOfText);\n\n    return <div style={{\n      height: heightStyle,\n      background: '#afa',\n      overflow: 'hidden',\n      position: 'relative'\n    }}\n      >{Array(numberOfInstances).fill(0).map(() => {\n          return <div style={{display: 'block', padding: '40px 0'}}>{displayText}</div>\n        })}\n      <div style={{\n        position: 'absolute',\n        bottom: 0,\n        width: '100%',\n        height: '40px',\n        background: 'linear-gradient(180deg, transparent 0%, #afa 100%)',\n        zIndex: 1,\n      }}>\n        &nbsp;\n      </div>\n    </div>\n  }\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {isScrapTrait, scrapTraitText} from './usefulConstants';\nimport React from 'react';\n\nexport function scrapTraitStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isScrapTrait)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsScrapTrait(blockText: string): boolean {\n  if (!blockText.startsWith('{{') || !blockText.endsWith('}}')) {\n    return false;\n  }\n\n  return blockText.includes('#');\n}\n\nexport function scrapTraitData(blockText: string): { [index: string]: boolean|string|number} {\n  const content = blockText.replace('{{', '').replace('}}', '').trim();\n\n  return {\n    [scrapTraitText]: content,\n    [isScrapTrait]: true,\n  }\n}\n\nexport const ScrapTraitComponent = (props: any) => {\n  return <div\n      style={{\n        background: '#c00',\n        color: 'white',\n        display: 'flex',\n        padding: '8px'\n      }}\n  >\n    <div style={{flex: 1}}>{props.children}</div>\n  </div>\n}\n\nexport const ScrapTraitReadonlyComponent = (props: any) => {\n  return null; // Hide\n}\n","import {CharacterMetadata, ContentBlock, ContentState} from 'draft-js';\nimport Immutable from 'immutable';\nimport {ScrapMap} from '../scrapList/scrapListSlice';\nimport {Scrap} from '../../protos_v2';\nimport {character, durationSecContribution, isBlank, isComment, isCommentEnd, isCommentStart, mergeDataObject, ONE_LINE_DURATION_SEC, scrapLink} from './usefulConstants';\nimport {checkIsSceneHeader, sceneHeaderData, sceneHeaderDurationSec} from './FountainHeaderComponent';\nimport {checkIsScrapEmbed, scrapEmbedData} from './ScrapEmbedComponent';\nimport {checkIsSceneTransition, sceneTransitionData, sceneTransitionDurationSec} from './FountainTransitionComponent';\nimport {checkIsCentered, sceneCenteredData, sceneCenteredDurationSec} from './FountainCenteredComponent';\nimport {checkIsCommentEnd, checkIsCommentStart} from './CommentComponent';\nimport {characterData, characterDurationSec, checkIsCharacter} from './FountainCharacterComponent';\nimport {checkIsDialogue, dialogueData, dialogueDurationSec} from './FountainDialogueComponent';\nimport {checkIsParenthetical, parentheticalData, parentheticalDurationSec} from './FountainParentheticalComponent';\nimport {actionData, actionDurationSec} from './FountainActionComponent';\nimport {checkIsScrapPlaceholder, scrapPlaceholderData, scrapPlaceholderDurationSec} from './ScrapPlaceholderComponent';\nimport {checkIsScrapTrait, scrapTraitData} from './ScrapTraitComponent';\n\nexport interface ProcessProgress {\n  processStartEpoch: number;\n  currentDurationSec: number;\n  childScraps: Immutable.OrderedSet<string>;\n}\n\ninterface ProcessUpdate {\n  processProgress: ProcessProgress;\n  contentBlock: ContentBlock;\n}\n\n\nfunction applyStyles(character: CharacterMetadata, styles: Immutable.OrderedSet<string>): CharacterMetadata {\n  return (character as any).set('style', styles) as CharacterMetadata;\n}\n\nexport function isArrayEqualToImmutableSet(set: Immutable.OrderedSet<string>, array: string[]): boolean {\n  if (set.size !== array.length) {\n    return false;\n  }\n\n  for (let i = 0; i < array.length; i++) {\n    if (!set.includes(array[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Process each content block, resetting the blockData and conditionally setting a flag for if the block\n// is blank or not. This function needs to be able to operate on each contentBlock independent of all the rest\nexport function preProcessProseBlock(contentBlock: ContentBlock): ContentBlock {\n  if (!contentBlock) {\n    return contentBlock;\n  }\n\n  let blockData: { [index: string]: boolean|string} = {};\n  let blockText = contentBlock.getText().trim();\n\n  if (!blockText.length) {\n    blockData[isBlank] = true;\n  } else {\n    if (checkIsCommentStart(blockText)) {\n      blockData[isCommentStart] = true;\n    }\n    if (checkIsCommentEnd(blockText)) {\n      blockData[isCommentEnd] = true;\n    }\n  }\n\n  return contentBlock.set('data', Immutable.fromJS(blockData)) as ContentBlock;\n}\n\nexport function processProseBlock(contentBlock: ContentBlock, blockBefore: null|ContentBlock, blockAfter: null|ContentBlock, processProgress: ProcessProgress, scrapMap: ScrapMap): ProcessUpdate {\n  if (!contentBlock) {\n    return {\n      processProgress: processProgress,\n      contentBlock: contentBlock\n    };\n  }\n\n  let blockData: { [index: string]: boolean|string|number} = contentBlock.getData().toJS();\n  let applyCharacterStyles = true;\n\n  let blockText = contentBlock.getText().trim();\n\n  const blankBefore: boolean = !!blockBefore ? blockBefore.getData().get(isBlank) : true;\n  const blankAfter: boolean = !!blockAfter ? blockAfter.getData().get(isBlank) : true;\n  const characterBefore: string = !!blockBefore ? (blockBefore.getData().get(character) || '') : '';\n\n  if (blockData[isBlank]) {\n    if (!blankBefore && !blockData[isComment]) { // We only want to count 1 contiguous block of \"blank\", since we remove redundant whitespace\n      processProgress.currentDurationSec += ONE_LINE_DURATION_SEC; // Assume one line of whitespace\n      blockData = mergeDataObject(blockData, {\n        [durationSecContribution]: ONE_LINE_DURATION_SEC\n      });\n    }\n  } else {\n    if (!blockData[isComment]) {\n      if (checkIsSceneHeader(blankBefore, blankAfter, blockText)) {\n        /** Scene header */\n        blockData = mergeDataObject(blockData, sceneHeaderData(blockText));\n\n        processProgress.currentDurationSec += sceneHeaderDurationSec(blockText);\n      } else if (checkIsSceneTransition(blankBefore, blankAfter, blockText)) {\n        /** Scene transition */\n        blockData = mergeDataObject(blockData, sceneTransitionData(blockText));\n\n        processProgress.currentDurationSec += sceneTransitionDurationSec(blockText);\n      } else if (checkIsCentered(blockText)) {\n        /** Centered action */\n        blockData = mergeDataObject(blockData, sceneCenteredData(blockText));\n\n        processProgress.currentDurationSec += sceneCenteredDurationSec(blockText);\n      } else if (checkIsCharacter(blankBefore, blankAfter, blockText)) {\n        /** Character */\n        blockData = mergeDataObject(blockData, characterData(blockText));\n\n        processProgress.currentDurationSec += characterDurationSec(blockText);\n      } else if (checkIsDialogue(characterBefore, blockText)) {\n        /** Dialogue */\n        blockData = mergeDataObject(blockData, dialogueData(characterBefore, blockText));\n\n        processProgress.currentDurationSec += dialogueDurationSec(blockText);\n      }\n      else if (checkIsParenthetical(characterBefore, blockText)) {\n        /** Parenthetical */\n        blockData = mergeDataObject(blockData, parentheticalData(characterBefore, blockText));\n\n        processProgress.currentDurationSec += parentheticalDurationSec(blockText);\n      } else if (checkIsScrapPlaceholder(blockText)) {\n        /** Scrap placeholder (for scrap that doesn't exist yet, for structure planning) */\n        blockData = mergeDataObject(blockData, scrapPlaceholderData(blockText));\n\n        processProgress.currentDurationSec += scrapPlaceholderDurationSec(blockText);\n      } else if (checkIsScrapTrait(blockText)) {\n      /** Scrap trait (for adding binary labels on scraps, for tracking / reporting) */\n      blockData = mergeDataObject(blockData, scrapTraitData(blockText));\n    } else if (!checkIsScrapEmbed(blockText)) {\n        /** Action */\n        blockData = mergeDataObject(blockData, actionData(blockText));\n\n        processProgress.currentDurationSec += actionDurationSec(blockText);\n      }\n    }\n\n    if (checkIsScrapEmbed(blockText)) {\n      /** Scrap link embedded in prose */\n      blockData = mergeDataObject(blockData, scrapEmbedData(blockText));\n\n      const scrapId = blockData[scrapLink] as string;\n\n      if (!!scrapMap[scrapId]) {\n        processProgress.childScraps = processProgress.childScraps.add(scrapId);\n\n        const childScrap = scrapMap[scrapId] as Scrap;\n\n        if (!blockData[isComment]) {\n          processProgress.currentDurationSec += childScrap.intendedDurationSec;\n        }\n      }\n    }\n  }\n\n  const updatedBlock = contentBlock.set('data', Immutable.fromJS(blockData)) as ContentBlock;\n\n  applyCharacterStyles = false;\n\n  const updatedCharacterList = updatedBlock.getCharacterList().map((c, idx) => {\n    if (!c || !applyCharacterStyles) { return c; }\n\n\n    // @ts-ignore\n    if (idx < 5) {\n      return applyStyles(c, Immutable.OrderedSet.of('BOLD', 'GREEN'));\n    } else {\n      return applyStyles(c, Immutable.OrderedSet());\n    }\n  });\n\n  const finalBlockUpdate = updatedBlock.set('characterList', updatedCharacterList) as ContentBlock;\n\n  return {\n    contentBlock: finalBlockUpdate,\n    processProgress: processProgress,\n  }\n}\n\ninterface ParsedProseResult {\n  contentState: ContentState;\n  totalDurationSec: number;\n  childScraps: Immutable.OrderedSet<string>;\n  showTimeoutWarning: boolean;\n}\n\nexport function parseAllProse(contentState: ContentState, scrapMap: ScrapMap, warnParsingThreshold: number, errorParsingThreshold: number): ParsedProseResult {\n\n  let newParseErrorState = false;\n\n  let processProgress = {\n    processStartEpoch: Date.now(),\n    currentDurationSec: 0,\n    childScraps: Immutable.OrderedSet<string>()\n  } as ProcessProgress;\n\n  let currentBlockMap = contentState.getBlockMap();\n  // @ts-ignore\n  const blockKeys = [ ...currentBlockMap.keys()];\n\n  for (let i = 0; i < blockKeys.length; i++) {\n    const nextKey = blockKeys[i];\n    currentBlockMap = currentBlockMap.set(nextKey, preProcessProseBlock(currentBlockMap.get(nextKey)));\n\n    const timeSoFar = Date.now() - processProgress.processStartEpoch;\n    if (timeSoFar > warnParsingThreshold) {\n      newParseErrorState = true;\n    }\n    if (timeSoFar > errorParsingThreshold) {\n      break;\n    }\n  }\n\n  // Mark all comment blocks as such\n  let currentlyInComment = false;\n  for (let i = 0; i < blockKeys.length; i++) {\n    const nextKey = blockKeys[i];\n    const blockData = currentBlockMap.get(nextKey).getData().toJS();\n    if (blockData[isCommentStart]) {\n      currentlyInComment = true;\n    }\n\n    if (currentlyInComment) {\n      const currentBlock = currentBlockMap.get(nextKey);\n\n      blockData[isComment] = true;\n      const updatedData = Immutable.fromJS(blockData);\n\n      const updatedBlock = currentBlock.set('data', updatedData) as ContentBlock;\n      currentBlockMap = currentBlockMap.set(nextKey, updatedBlock);\n    }\n\n    if (blockData[isCommentEnd]) {\n      currentlyInComment = false;\n    }\n    const timeSoFar = Date.now() - processProgress.processStartEpoch;\n    if (timeSoFar > warnParsingThreshold) {\n      newParseErrorState = true;\n    }\n    if (timeSoFar > errorParsingThreshold) {\n      break;\n    }\n  }\n\n  for (let i = 0; i < blockKeys.length; i++) {\n    const blockBefore = i > 0 ? currentBlockMap.get(blockKeys[i - 1]) : null;\n    const nextKey = blockKeys[i];\n    const blockAfter = i + 1 < blockKeys.length ? currentBlockMap.get(blockKeys[i + 1]) : null;\n\n    const update = processProseBlock(currentBlockMap.get(nextKey), blockBefore, blockAfter, processProgress, scrapMap);\n\n    processProgress = update.processProgress;\n\n    currentBlockMap = currentBlockMap.set(nextKey, update.contentBlock);\n    const timeSoFar = Date.now() - processProgress.processStartEpoch;\n    if (timeSoFar > warnParsingThreshold) {\n      newParseErrorState = true;\n    }\n    if (timeSoFar > errorParsingThreshold) {\n      break;\n    }\n  }\n\n  const newContent = contentState.set('blockMap', currentBlockMap) as ContentState;\n\n  const durationMs = Date.now() - processProgress.processStartEpoch;\n  console.log('Update took: ' + durationMs);\n\n  return {\n    contentState: newContent,\n    totalDurationSec: processProgress.currentDurationSec,\n    childScraps: processProgress.childScraps,\n    showTimeoutWarning: newParseErrorState\n  };\n}\n","import {ContentBlock, ContentState} from 'draft-js';\nimport {isComment, isScrapEmbedding, PAGE_WIDTH_EM} from './usefulConstants';\nimport React from 'react';\n\n\nexport function commentStrategy(contentBlock: ContentBlock, callback: (start: number, end: number) => void, contentState: ContentState) {\n  if (!!contentBlock.getData().get(isComment) && !contentBlock.getData().get(isScrapEmbedding)) {\n    callback(0, contentBlock.getText().length);\n  }\n}\n\nexport function checkIsCommentStart(blockText: string): boolean {\n  return blockText.startsWith('/*');\n}\n\n\nexport function checkIsCommentEnd(blockText: string): boolean {\n  return blockText.endsWith('*/');\n}\n\n/**\n * Component to show a block component element in DraftJS.\n *\n */\nexport const CommentComponent = (props: any) => {\n  return (\n      <div style={{fontStyle: 'italic', background: '#cfead9', width: PAGE_WIDTH_EM}}>{props.children}</div>\n  );\n}\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport {ContentBlock, ContentState} from 'draft-js';\nimport {parseAllProse} from '../scrapDetails/parseProse';\nimport {ancestorField, isComment, isScrapEmbedding, scrapIdField, scrapLink} from '../scrapDetails/usefulConstants';\n\nexport function fetchParsedContentBlocksForScrap(scrapId: string, scrapAncestors: string[], scrapMap: ScrapMap): Array<ContentBlock> {\n  let prose = scrapMap[scrapId]?.prose || '';\n\n  let newAncestors = [...scrapAncestors, scrapId];\n\n  const initialContentState = ContentState.createFromText(prose);\n\n  const parseResult = parseAllProse(initialContentState, scrapMap, 500, 5000);\n\n  const allNewContentBlocks: Array<ContentBlock> = [];\n\n  parseResult.contentState.getBlocksAsArray().forEach((block) => {\n    const blockData = block.getData();\n\n    if (blockData.get(isComment)) {\n      // Skip\n      return;\n    }\n\n    if (!blockData.get(isScrapEmbedding)) {\n      // Simple addition, just append the ID of the scrap, and the ancestors at this point\n      let updatedBlock = block.set('data', blockData.set(scrapIdField, scrapId).set(ancestorField, scrapAncestors));\n\n      allNewContentBlocks.push(updatedBlock as ContentBlock);\n      return;\n    }\n\n    const embeddedScrapId = blockData.get(scrapLink);\n\n    if (!scrapMap[embeddedScrapId]) {\n      // Scrap doesn't exist, skip\n      return;\n    }\n\n    if (newAncestors.includes(embeddedScrapId)) {\n      throw Error(`Replacing scrap ${embeddedScrapId} would cause infinite recursion`);\n    }\n\n    const subBlocks = fetchParsedContentBlocksForScrap(embeddedScrapId, newAncestors, scrapMap);\n\n    allNewContentBlocks.push(...subBlocks);\n  });\n\n  return allNewContentBlocks;\n}\n","\nexport function dateFromMinSinceEpoch(minSinceEpoch: number): string {\n  const date = new Date(minSinceEpoch * 60000);\n  return date.toLocaleDateString();\n}\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport React, {Component} from 'react';\nimport {Button, Icon, Popup} from 'semantic-ui-react';\nimport {durationSecondsToString} from '../utils/durationUtils';\nimport {parseTimeline} from './timelineParsing';\nimport {\n  Link\n} from 'react-router-dom';\nimport {ContentBlock} from 'draft-js';\nimport {Scrap} from '../../protos_v2';\nimport { Line } from 'react-chartjs-2';\nimport {Chart, registerables} from 'chart.js';\nimport {dateFromMinSinceEpoch} from '../utils/timeUtils';\nChart.register(...registerables);\n\nfunction formatPercentString(percent: number): string {\n  return `${percent}%`;\n}\n\nexport class TimelineBlock {\n  headerText: string;\n  id: string;\n  startSec: number;\n  durationSec: number;\n  characters: Set<string>;\n  completeness: Scrap.Completeness;\n  traits: Set<string>\n\n  constructor(headerText: string, id: string, startSec: number, durationSec: number, completeness: Scrap.Completeness) {\n    this.headerText = headerText;\n    this.id = id;\n    this.startSec = startSec;\n    this.durationSec = durationSec;\n    this.characters = new Set<string>();\n    this.completeness = completeness;\n    this.traits = new Set<string>();\n  }\n\n  render(totalDurationSec: number, currentCharacterFilter: string, highlightPendingCompletion: boolean, currentTraitFilter: string) {\n    let background = 'grey';\n\n    if (\n        this.characters.has(currentCharacterFilter) ||\n        (this.traits.has(currentTraitFilter))\n    ) {\n      background = '#D2042D';\n    }\n\n    let completenessText;\n    switch (this.completeness) {\n      case Scrap.Completeness.FINAL:\n        completenessText = 'Final';\n        break;\n      case Scrap.Completeness.POLISHED:\n        completenessText = 'Polished';\n        break;\n      case Scrap.Completeness.INITIAL_DRAFT:\n        completenessText = 'Initial Draft';\n        break;\n      case Scrap.Completeness.BRAINSTORM:\n        completenessText = 'Brainstorm';\n        break;\n      default:\n        completenessText = 'Not Started';\n    }\n    let popupText = durationSecondsToString(this.durationSec) + ` (${completenessText})`;\n\n    if (highlightPendingCompletion) {\n      switch (this.completeness) {\n        case Scrap.Completeness.FINAL:\n          background = '#228B22';\n          break;\n        case Scrap.Completeness.POLISHED:\n          background = '#C9CC3F';\n          break;\n        case Scrap.Completeness.INITIAL_DRAFT:\n          background = '#FFC300';\n          break;\n        case Scrap.Completeness.BRAINSTORM:\n          background = '#FF5F1F';\n          break;\n        default:\n          background = '#D2042D'\n      }\n    }\n\n    return <Popup\n        key={'key-' + this.id}\n        content={popupText}\n        header={this.headerText}\n        mouseEnterDelay={50}\n        mouseLeaveDelay={50}\n        trigger={\n          <Link\n              to={'/scrap/' + this.id}\n              style={{\n                cursor: 'pointer',\n                display: 'inline-block',\n                height: '100%',\n                boxShadow: 'inset 0px 0px 0px 1px #555',\n                position: 'absolute',\n                width: formatPercentString(100 * this.durationSec / totalDurationSec),\n                left: formatPercentString(100 * this.startSec / totalDurationSec),\n                background: background,\n                zIndex: 2,\n              }}\n          >\n          <div\n        >\n          &nbsp;\n          </div></Link>}\n    />\n  }\n}\n\nexport class TimelineRow {\n  blocks: TimelineBlock[] = [];\n\n  lastBlockId(): string {\n    if (!this.blocks.length) {\n      return '';\n    }\n\n    return this.blocks[this.blocks.length - 1].id;\n  }\n\n  render(totalDurationSec: number, zoomLevel: number, currentCharacterFilter: string, highlightPendingCompletion: boolean, currentTraitFilter: string) {\n    return <div style={{\n      position: 'relative',\n      width: formatPercentString(zoomLevel),\n      height: '40px',\n      borderBottom: '1px solid'\n    }}>\n      {this.blocks.map((block) => block.render(totalDurationSec, currentCharacterFilter, highlightPendingCompletion, currentTraitFilter))}\n    </div>\n  }\n}\n\nexport class Timeline {\n  isValid: boolean = false;\n  durationSec: number = 0;\n  percentComplete: number = 0;\n  rows: TimelineRow[] = [];\n\n  constructor(scrapId: string, scrapMap: ScrapMap, parsedContentBlocks: ContentBlock[]) {\n    if (!scrapMap[scrapId]) {\n      return;\n    }\n    const parseResult = parseTimeline(parsedContentBlocks, scrapMap);\n\n    this.durationSec = parseResult.totalDurationSec;\n    this.percentComplete = parseResult.percentComplete;\n    if (!this.durationSec) {\n      return;\n    }\n\n    this.isValid = true;\n\n    this.rows = parseResult.rows;\n  }\n\n  getSecondMarkers(zoomLevel: number): number[] {\n    const numLevels = Math.round(4 * (zoomLevel / 100)) + 1;\n    const stepLevel = (this.durationSec / (numLevels - 1));\n\n    let startingPoint = 0;\n    let steps = []\n    for (let i = 0; i < numLevels; i++) {\n      const nextContribution = Math.round(startingPoint);\n      steps.push(nextContribution);\n      startingPoint += stepLevel;\n    }\n\n    return steps;\n  }\n\n  render(zoomLevel: number, currentCharacterFilter: string, highlightPendingCompletion: boolean, currentTraitFilter: string) {\n    let secondMarkers = this.getSecondMarkers(zoomLevel);\n    let markerTopPadding = 41 * this.rows.length;\n\n    return <div style={{width: '100%', overflowX: 'scroll', background: 'lightgrey'}}>\n      {this.rows.map((row) => row.render(this.durationSec, zoomLevel, currentCharacterFilter, highlightPendingCompletion, currentTraitFilter))}\n      <div style={{height: '24px', position: 'relative', width: formatPercentString(zoomLevel), background: 'white'}}>\n        {secondMarkers.map((value, idx) => {\n\n          const markerStyle: React.CSSProperties = {\n            display: 'inline-block',\n            position: 'absolute',\n            fontSize: '16px',\n            fontFamily: 'CourierPrime, Courier, monospace',\n            paddingTop: `${markerTopPadding}px`,\n            top: `-${markerTopPadding}px`\n          };\n\n          if (idx + 1 === secondMarkers.length) {\n            markerStyle.paddingRight = '8px';\n            markerStyle.textAlign = 'right';\n            markerStyle.borderRight = '2px solid';\n            markerStyle.right = formatPercentString(100 - (100 * value / this.durationSec));\n          } else {\n            markerStyle.paddingLeft = '8px';\n            markerStyle.textAlign = 'left';\n            markerStyle.borderLeft = '2px solid';\n            markerStyle.left = formatPercentString(100 * value / this.durationSec);\n          }\n\n          return <div\n              style={markerStyle}>{durationSecondsToString(value)}</div>\n        })}\n      </div>\n    </div>\n  }\n}\n\ninterface TimelineProps {\n  scrapId: string;\n  scrapMap: ScrapMap;\n  parsedContentBlocks: ContentBlock[];\n  currentCharacterFilter: string;\n  currentCompletionFilter: string;\n  currentTraitFilter: string;\n}\n\ninterface TimelineState {\n  scrapId: string;\n  timeline: Timeline;\n  zoomLevel: number;\n  chartMinimized: boolean;\n  timelineMinimized: boolean;\n}\n\nexport class TimelineViewer extends Component<TimelineProps, TimelineState> {\n\n  constructor(props: TimelineProps) {\n    super(props);\n\n    this.state = this.initializeState(props);\n  }\n\n  initializeState(props: TimelineProps): TimelineState {\n    return {\n      scrapId: props.scrapId,\n      timeline: new Timeline(props.scrapId, props.scrapMap, props.parsedContentBlocks),\n      zoomLevel: 100,\n      chartMinimized: true,\n      timelineMinimized: false,\n    }\n  }\n\n  zoomIn() {\n    this.setState({\n      zoomLevel: this.state.zoomLevel * 2\n    });\n  }\n\n  zoomOut() {\n    this.setState({\n      zoomLevel: Math.max(100, this.state.zoomLevel / 2)\n    });\n  }\n\n  flipTimelineMinimization() {\n    this.setState({\n      timelineMinimized: !this.state.timelineMinimized\n    });\n  }\n\n  flipChartMinimization() {\n    this.setState({\n      chartMinimized: !this.state.chartMinimized\n    });\n  }\n\n  getProgressChart(): JSX.Element|null {\n    if (this.state.chartMinimized) {\n      return null;\n    }\n\n    const writingHistory = this.props.scrapMap[this.state.scrapId]?.writingHistory || [];\n\n    if (!writingHistory.length) {\n      return <div>No writing history</div>\n    }\n\n    if (writingHistory.length === 1) {\n      return <div>\n        {dateFromMinSinceEpoch(writingHistory[0].minutesSinceEpoch as number)}: {(writingHistory[0].actualDurationSec as number) / 60}\n      </div>\n    }\n\n    let minMinEpoch = (writingHistory[0].minutesSinceEpoch as number);\n    let maxMinEpoch = (writingHistory[writingHistory.length - 1].minutesSinceEpoch as number);\n\n    /// build the list and values\n    const dateMap: {[key:string]: number|null} = {};\n    for (let minEpoch = minMinEpoch; minEpoch <= maxMinEpoch; minEpoch += (24 * 60)) {\n      dateMap[dateFromMinSinceEpoch(minEpoch)] = null;\n    }\n\n    for (let i = 0; i < writingHistory.length; i++) {\n      const dateStr = dateFromMinSinceEpoch(writingHistory[i].minutesSinceEpoch as number);\n      dateMap[dateStr] = (writingHistory[i].actualDurationSec as number) / 60;\n    }\n\n    const labels = [];\n    const values = [];\n    for (let minEpoch = minMinEpoch; minEpoch <= maxMinEpoch; minEpoch += (24 * 60)) {\n      const dateStr = dateFromMinSinceEpoch(minEpoch);\n      const value = dateMap[dateStr];\n\n      labels.push(dateStr);\n      values.push(value);\n    }\n\n    const options = {\n      responsive: true,\n      plugins: {\n        title: {\n          display: true,\n          text: 'Progress over Time',\n        },\n        legend: {\n          display: false,\n        },\n      },\n      scales: {\n        y: {\n          title: {\n            display: true,\n            text: 'Pages complete',\n          },\n          type: 'linear' as const,\n          display: true,\n          position: 'left' as const,\n        },\n      },\n      maintainAspectRatio: false,\n    };\n\n    const data = {\n      labels,\n      datasets: [\n        {\n          data: values\n        }\n      ]\n    }\n\n    return <div>\n      <div style={{position: 'relative', height: '300px'}}>\n        <Line\n          height='300px'\n          options={options}\n          data={data}\n      />\n      </div>\n      <pre>{JSON.stringify(writingHistory, null, 4)}</pre>\n    </div>;\n  }\n\n  render() {\n    if (!this.state.timeline.isValid) {\n      return <div>... loading timeline... </div>\n    }\n\n    const zoomOptions = this.state.timelineMinimized ? null : (<div style={{display: 'inline-block'}}>\n      <Button onClick={() => this.zoomOut()} disabled={this.state.zoomLevel === 100} icon>\n        <Icon name='zoom-out' />\n      </Button>\n      <Button onClick={() => this.zoomIn()} icon>\n        <Icon name='zoom-in' />\n      </Button>\n    </div>);\n\n    return (<div>\n      <div style={{marginBottom: '12px', display: 'flex'}}>\n        {zoomOptions}\n        <span style={{flex: '1'}}>&nbsp;</span>\n        <button style={{margin: 'auto 24px'}} onClick={() => { this.flipChartMinimization(); }}>\n          Percent complete: {this.state.timeline.percentComplete}\n        </button>\n        <Button onClick={() => this.flipTimelineMinimization()} icon>\n          <Icon name={this.state.timelineMinimized ? 'window maximize outline' : 'window minimize outline'}/>\n        </Button>\n      </div>\n      <div>\n        {this.getProgressChart()}\n      </div>\n      {this.state.timelineMinimized ? null : this.state.timeline.render(\n          this.state.zoomLevel,\n          this.props.currentCharacterFilter,\n          !!this.props.currentCompletionFilter,\n          this.props.currentTraitFilter\n      )}\n    </div>)\n  }\n}\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport {TimelineBlock, TimelineRow} from './Timeline';\nimport {ancestorField, character, durationSecContribution, pendingDurationSecContribution, scrapIdField, scrapTraitText} from '../scrapDetails/usefulConstants';\nimport {ContentBlock} from 'draft-js';\nimport {Scrap} from '../../protos_v2';\n\ninterface ParsedTimeline {\n  totalDurationSec: number;\n  totalCompletedSec: number;\n  percentComplete: number;\n  rows: TimelineRow[];\n}\n\nexport function parseTimeline(parsedBlocks: ContentBlock[], scrapMap: ScrapMap): ParsedTimeline {\n  let rows: TimelineRow[] = [];\n\n  let totalDurationSec = 0;\n  let totalPendingSec = 0;\n  for (let i = 0; i < parsedBlocks.length; i++) {\n\n    const durationContribution = parsedBlocks[i].getData().get(durationSecContribution) || 0;\n    const incompleteContribution = parsedBlocks[i].getData().get(pendingDurationSecContribution) || 0;\n    if (!durationContribution) {\n      //continue;\n    }\n\n    const characterContribution = parsedBlocks[i].getData().get(character) || null;\n\n    const traitString = (parsedBlocks[i].getData().get(scrapTraitText) || '') as string;\n    const parsedTraits = traitString.split('#').filter(Boolean).map((untrimmed) => { return untrimmed.trim(); });\n\n    const ancestors = [\n        ...(parsedBlocks[i].getData().get(ancestorField) || []),\n        parsedBlocks[i].getData().get(scrapIdField) || ''\n    ];\n\n    for (let j = 0; j < ancestors.length; j++) {\n      if (rows.length <= j) {\n        // Need to add a new row\n        rows.push(new TimelineRow());\n      }\n\n      // Check to see what the last block's ID is\n      const lastBlockId = rows[j].lastBlockId();\n\n      if (ancestors[j] === lastBlockId) {\n        // Extend existing block\n        rows[j].blocks[rows[j].blocks.length - 1].durationSec += durationContribution;\n      } else {\n        rows[j].blocks.push(new TimelineBlock(\n            getScrapSynopsis(ancestors[j], scrapMap),\n            ancestors[j],\n            totalDurationSec,\n            durationContribution,\n            getScrapCompleteness(ancestors[j], scrapMap),\n        ));\n      }\n\n      if (!!characterContribution) {\n        rows[j].blocks[rows[j].blocks.length - 1].characters.add(characterContribution);\n      }\n      parsedTraits.forEach((trait) => {\n        rows[j].blocks[rows[j].blocks.length - 1].traits.add(trait);\n      });\n    }\n\n    totalDurationSec += durationContribution;\n    totalPendingSec += incompleteContribution;\n  }\n\n  return {\n    totalDurationSec: totalDurationSec,\n    totalCompletedSec: totalDurationSec - totalPendingSec,\n    percentComplete: Math.ceil(1000 * (1 - (totalPendingSec / totalDurationSec))) / 10,\n    rows: rows,\n  }\n}\n\nfunction getScrapSynopsis(scrapId: string, scrapMap: ScrapMap): string {\n  return scrapMap[scrapId]?.synopsis || '';\n}\n\nfunction getScrapCompleteness(scrapId: string, scrapMap: ScrapMap): Scrap.Completeness {\n  return scrapMap[scrapId]?.completeness || Scrap.Completeness.NOT_STARTED\n}\n","import {createSlice, Middleware, PayloadAction} from '@reduxjs/toolkit';\nimport {RootState} from '../../app/store';\nimport {IScrap, Scrap} from '../../protos_v2';\nimport {addScrapToStorage, clearScrapFromStorage, fetchInitialStateFromStorage, writeScrap} from './scrapListPersistence';\nimport WritingHistory = Scrap.WritingHistory;\nimport {fetchParsedContentBlocksForScrap} from '../utils/fetchParsedContentBlocksForScrap';\nimport {parseTimeline} from '../timeline/timelineParsing';\n\nexport interface ScrapMap {\n  [key: string]: Scrap;\n}\n\nexport interface ScrapMapInState {\n  [key: string]: IScrap\n}\n\ninterface ScrapListInState {\n  scrapList: {\n    scrapMap: ScrapMapInState\n  }\n}\n\nconst initialState = fetchInitialStateFromStorage();\n\nconst actionPrefix = 'scrapList';\n\nconst ScrapListSlice = createSlice({\n  name: actionPrefix,\n  initialState,\n  reducers: {\n    createScrap(state, action: PayloadAction<IScrap>) {\n      state.scrapMap[action.payload.id as string] = action.payload;\n    },\n    updateScrap(state, action: PayloadAction<IScrap>) {\n      const updatedScrap = action.payload;\n      updatedScrap.writingHistory = updatedScrap.writingHistory || [];\n\n      const writingHistory = updatedScrap.writingHistory;\n      let lastUpdatedMinutesEpoch = 0;\n      if (writingHistory.length) {\n        lastUpdatedMinutesEpoch = writingHistory[writingHistory.length - 1].minutesSinceEpoch as number;\n      }\n      const newMinutesSinceEpoch = Math.floor(Date.now() / 60000);\n      if (newMinutesSinceEpoch - lastUpdatedMinutesEpoch > 5) {\n        // Need to update or create new entry\n        const parsedTimelineBlocks = fetchParsedContentBlocksForScrap(\n            updatedScrap.id as string,\n            [],\n            state.scrapMap as ScrapMap\n        );\n\n        const parsedTimeline = parseTimeline(parsedTimelineBlocks, state.scrapMap as ScrapMap);\n\n        const newDurationSec = Math.floor(parsedTimeline.totalCompletedSec);\n\n        const newHistoryEntry = {\n          minutesSinceEpoch: newMinutesSinceEpoch,\n          actualDurationSec: newDurationSec,\n        } as WritingHistory;\n\n        if (newMinutesSinceEpoch - lastUpdatedMinutesEpoch > 60) {\n          // New entry\n          updatedScrap.writingHistory.push(newHistoryEntry);\n        } else {\n          // Updated entry\n          updatedScrap.writingHistory[writingHistory.length - 1] = newHistoryEntry;\n        }\n      }\n\n      state.scrapMap[action.payload.id as string] = updatedScrap;\n    },\n    removeScrap(state, action: PayloadAction<string>) {\n      delete state.scrapMap[action.payload];\n    }\n  }\n});\n\nexport const scrapListPersistenceMiddleware: Middleware<{}, ScrapListInState>\n    = storeAPI => next => action => {\n  let result = next(action);\n\n  if (action.type.startsWith(actionPrefix + '/')) {\n    handleScrapListPersistence(action);\n  }\n\n  return result;\n}\n\nexport const handleScrapListPersistence = (action: PayloadAction<string|IScrap>) => {\n  switch (action.type) {\n    case `${actionPrefix}/createScrap`:\n      addScrapToStorage(action.payload as IScrap);\n      break;\n    case `${actionPrefix}/updateScrap`:\n      writeScrap(action.payload as IScrap);\n      break;\n    case `${actionPrefix}/removeScrap`:\n      clearScrapFromStorage(action.payload as string);\n      break;\n  }\n}\n\n// Selector for fetching full map of stories\nexport const selectScrapMap = (state: ScrapListInState|RootState): ScrapMap => {\n  const compiledScrapMap: ScrapMap = {};\n\n  for (const [key, value] of Object.entries(state.scrapList.scrapMap)) {\n    compiledScrapMap[key] = Scrap.fromObject(value);\n  }\n\n  return compiledScrapMap;\n}\n\n// Creates selector for particular Scrap\nexport const selectSpecificScrap = (id: string) => (state: ScrapListInState|RootState): Scrap|null => {\n  const fetchedScrap = state.scrapList.scrapMap[id];\n\n  if (!fetchedScrap) {\n    return null;\n  }\n\n  return Scrap.create(fetchedScrap);\n}\n\nexport const { createScrap, updateScrap, removeScrap } = ScrapListSlice.actions;\nexport default ScrapListSlice.reducer;\n","import React from 'react';\nimport {\n  Link\n} from 'react-router-dom';\nimport {Button, Checkbox, Dropdown, DropdownItemProps, Icon, Menu} from 'semantic-ui-react';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {readHeaderOptions, updateHeaderOptions} from './headerOptionsSlice';\nimport {durationSecondsToString} from '../utils/durationUtils';\nimport {getSearchModal} from '../scrapDetails/SearchModal';\nimport {selectScrapMap} from '../scrapList/scrapListSlice';\n\nexport default function RevisionHeader() {\n  const dispatch = useAppDispatch();\n  const options = useAppSelector(readHeaderOptions);\n  const scrapMap = useAppSelector(selectScrapMap);\n\n  const dispatchPartialOptionsUpdate = (partialUpdate: object) => {\n    dispatch(updateHeaderOptions(partialUpdate));\n  }\n\n  let characterFilters;\n  if (options.characterFilters.length && !options.showReadLink) {\n    const characterOptions = options.characterFilters.map((characterFilter) => {\n      return {\n        key: characterFilter.character,\n        text: `${characterFilter.character} (${Math.round(characterFilter.percentDurationSec * 1000) / 10}%)`,\n        value: characterFilter.character,\n      } as DropdownItemProps;\n    });\n\n    characterOptions.unshift({\n      key: 'none',\n      value: 'No Character Filter',\n      text: 'No Character Filter'\n    });\n\n    characterFilters = <Dropdown\n        text={options.currentCharacterFilter || 'Filter by character'}\n        floating\n        labeled\n        scrolling\n        item\n        className='icon'\n        value={options.currentCharacterFilter}\n        options={characterOptions}\n        onChange={(e, data) => {\n          dispatchPartialOptionsUpdate({\n            currentCharacterFilter: data.value as string,\n            currentCompletionFilter: '',\n            currentTraitFilter: '',\n          });\n        }}\n    />\n  }\n\n  let completionFilters;\n  if (!options.showReadLink) {\n    // Only show on the read page\n    completionFilters = <Dropdown\n        text={options.currentCompletionFilter || 'Filter by completion'}\n        floating\n        labeled\n        scrolling\n        item\n        className='icon'\n        value={options.currentCompletionFilter}\n        options={[\n          {\n            key: 'none',\n            value: '',\n            text: 'No Completion Filter'\n          },\n          {\n            key: 'pending',\n            value: 'Pending Completion',\n            text: 'Show Completion'\n          }\n        ]}\n        onChange={(e, data) => {\n          dispatchPartialOptionsUpdate({\n            currentCharacterFilter: '',\n            currentTraitFilter: '',\n            currentCompletionFilter: data.value as string,\n          });\n        }}\n    />\n  }\n\n  let traitFilters;\n  if (options.traitFilters.length && !options.showReadLink) {\n    const traitOptions = options.traitFilters.map((traitFilter) => {\n      return {\n        key: traitFilter.trait,\n        text: `${traitFilter.trait} (${traitFilter.numberOfAppearances})`,\n        value: traitFilter.trait,\n      } as DropdownItemProps;\n    });\n\n    traitOptions.unshift({\n      key: 'none',\n      value: 'No Trait Filter',\n      text: 'No Trait Filter'\n    });\n\n    traitFilters = <Dropdown\n        text={options.currentTraitFilter || 'Filter by trait'}\n        floating\n        labeled\n        scrolling\n        item\n        className='icon'\n        value={options.currentTraitFilter}\n        options={traitOptions}\n        onChange={(e, data) => {\n          dispatchPartialOptionsUpdate({\n            currentCharacterFilter: '',\n            currentTraitFilter: data.value as string,\n            currentCompletionFilter: '',\n          });\n        }}\n    />\n  }\n\n  let editEntry;\n  if (options.showEditLink) {\n    editEntry = <Link to={'/scrap/' + options.currentScrapId}>\n      <Menu.Item>\n        <Icon name=\"edit\" />\n      </Menu.Item>\n    </Link>\n  }\n\n  let readEntry;\n  if (options.showReadLink) {\n    readEntry = <Link to={'/read/' + options.currentScrapId}>\n      <Menu.Item>\n        <Icon name=\"film\" />\n      </Menu.Item>\n    </Link>\n  }\n\n  let printEntry;\n  if (options.showPrintLink) {\n    printEntry = <Link to={'/print/' + options.currentScrapId}>\n      <Menu.Item>\n        <Icon name=\"print\" />\n      </Menu.Item>\n    </Link>\n  }\n\n  let timerEntry;\n  if (options.showPrintLink) {\n    if (options.isCurrentlyInSession) {\n      timerEntry = <Menu.Item>\n        {durationSecondsToString((Date.now() - options.currentWritingSessionStartEpoch) / 1000)} spent writing\n      </Menu.Item>\n    } else {\n      timerEntry = <Menu.Item><Button\n          onClick={() => {\n            dispatchPartialOptionsUpdate({\n              isCurrentlyInSession: true,\n              currentWritingSessionStartEpoch: Date.now(),\n              lastCheckedWritingSessionEpoch: Date.now(),\n            });\n\n            // Update header state every second, to get the timer to visibly update\n            setInterval(() => {\n              dispatchPartialOptionsUpdate({\n                lastCheckedWritingSessionEpoch: Date.now(),\n              });\n            }, 1000);\n          }}\n      >Start writing session</Button></Menu.Item>\n    }\n  }\n\n  let titlePageEntry;\n  if (!options.showPrintLink) {\n    titlePageEntry = <Menu.Item>\n      <Checkbox\n          onChange={(e, data) => {\n            dispatchPartialOptionsUpdate({\n              includeTitlePage: data.checked\n            });\n          }}\n          checked={options.includeTitlePage}\n          label={'Include title page'}/>\n    </Menu.Item>\n  }\n\n  const searchModal = getSearchModal(\n      options.searchModalOpen,\n      options.currentSearchQuery,\n      options.currentSearchResults,\n      scrapMap,\n      (newQuery: string, newResults) => {\n        dispatchPartialOptionsUpdate({\n          currentSearchQuery: newQuery,\n          currentSearchResults: newResults,\n        });\n      },\n      () => {\n        dispatchPartialOptionsUpdate({\n          searchModalOpen: false,\n        });\n      });\n\n  return (\n      <Menu>\n        <Link to={'/'}>\n          <Menu.Item header>Revision</Menu.Item>\n        </Link>\n        <Link to={'/data'}>\n          <Menu.Item>\n            <Icon name=\"save\" />\n          </Menu.Item>\n        </Link>\n        <Menu.Item onClick={() => {\n          dispatchPartialOptionsUpdate({\n            searchModalOpen: true,\n          });\n        }}>\n          <Icon name=\"search\" />\n        </Menu.Item>\n        {searchModal}\n        {timerEntry}\n        {titlePageEntry}\n        <Menu.Menu position='right'>\n          {completionFilters}\n          {traitFilters}\n          {characterFilters}\n          {editEntry}\n          {readEntry}\n          {printEntry}\n        </Menu.Menu>\n      </Menu>\n  );\n}\n","import {ContactInfo} from './contactInfoSlice';\n\n\nconst AUTHOR_KEY = 'workspace-author';\nconst CONTACT_INFO_KEY = 'workspace-contact-info';\n\nexport function readContactInfoFromStorage(): ContactInfo {\n  return {\n    author: localStorage.getItem(AUTHOR_KEY) || '',\n    contactInfo: localStorage.getItem(CONTACT_INFO_KEY) || '',\n  }\n}\n\nexport function setAuthor(newValue: string) {\n  localStorage.setItem(AUTHOR_KEY, newValue);\n}\n\nexport function setContactInfo(newValue: string) {\n  localStorage.setItem(CONTACT_INFO_KEY, newValue);\n}\n\nexport function writeContactInfoToStorage(contactInfo: ContactInfo): void {\n  setAuthor(contactInfo.author);\n  setContactInfo(contactInfo.contactInfo);\n}\n","import {createSlice, Middleware, PayloadAction} from '@reduxjs/toolkit';\nimport {RootState} from '../../app/store';\nimport {readContactInfoFromStorage, setAuthor, setContactInfo} from './contactInfoPersistence';\n\nexport interface ContactInfo {\n  author: string;\n  contactInfo: string;\n}\n\ninterface ContactInfoInState {\n  workspaceContactInfo: ContactInfo;\n}\n\nconst initialState = readContactInfoFromStorage();\n\nconst actionPrefix = 'workspaceContactInfo';\n\nconst ContactInfoSlice = createSlice({\n  name: actionPrefix,\n  initialState,\n  reducers: {\n    updateAuthor(state, action: PayloadAction<string>) {\n      state.author = action.payload;\n    },\n    updateContactInfo(state, action: PayloadAction<string>) {\n      state.contactInfo = action.payload;\n    }\n  },\n});\n\nexport const contactInfoPersistenceMiddleware: Middleware<{}, ContactInfoInState>\n    = storeAPI => next => action => {\n  let result = next(action);\n\n  if (action.type.startsWith(actionPrefix + '/')) {\n    handleContactInfoPersistence(action);\n  }\n\n  return result;\n}\n\nexport const handleContactInfoPersistence = (action: PayloadAction<string>) => {\n  switch (action.type) {\n    case `${actionPrefix}/updateAuthor`:\n      setAuthor(action.payload);\n      break;\n    case `${actionPrefix}/updateContactInfo`:\n      setContactInfo(action.payload);\n      break;\n  }\n}\n\n// Selector for fetching contact info\nexport const selectContactInfo = (state: ContactInfoInState|RootState): ContactInfo => {\n  return state.workspaceContactInfo;\n}\n\nexport const { updateAuthor, updateContactInfo } = ContactInfoSlice.actions;\nexport default ContactInfoSlice.reducer;\n","import {Button, Header, Card, Icon, Segment, Form} from 'semantic-ui-react';\nimport { useHistory } from 'react-router-dom';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {IScrap, Scrap} from '../../protos_v2';\nimport { v4 as uuid } from 'uuid';\nimport {\n  Link\n} from 'react-router-dom';\nimport {createScrap, selectScrapMap, ScrapMap} from '../../features/scrapList/scrapListSlice';\nimport {durationSecondsToString} from '../../features/utils/durationUtils';\nimport {selectContactInfo, updateAuthor, updateContactInfo} from '../print-scrap/contactInfoSlice';\nimport React from 'react';\n\nfunction createNewScrap(): IScrap {\n  return Scrap.create({\n    id: uuid(),\n    synopsis: 'Story Content',\n    prose: 'Here is where you can summarize the story, and start to structure / brainstorm\\n'\n      + 'Feel free to create new scraps for alternative starting points, or new supporting docs '\n      + 'for this story.'\n  }).toJSON();\n}\n\nfunction getScrapSection(scrapMap: ScrapMap): JSX.Element {\n  const scrapList = Object.values(scrapMap);\n\n  const hasParentMap: {[key: string]: boolean} = {};\n  scrapList.forEach((scrap) => {\n    scrap.childScraps.forEach((childId) => {\n      hasParentMap[childId] = true;\n    });\n  });\n\n  if (!scrapList.length) {\n    return (\n        <Segment>Whoops, no scraps yet</Segment>\n    );\n  }\n\n  const preparedScrapList = scrapList.filter((scrap) => {\n    return !hasParentMap[scrap.id];\n  }).sort((a, b) => {\n    return b.intendedDurationSec - a.intendedDurationSec;\n  });\n\n  return <Segment style={{display: 'flex', flexWrap: 'wrap'}}>\n    {preparedScrapList.map((scrap, idx) => {\n      return (\n          <Link to={'/read/' + scrap.id} key={idx}>\n            <Card style={{margin: '8px'}}>\n              <Card.Content header={scrap.synopsis} />\n              <Card.Content>\n                <p>{durationSecondsToString(scrap.intendedDurationSec)}</p>\n              </Card.Content>\n            </Card>\n          </Link>\n      );\n    })}\n  </Segment>\n}\n\nexport default function Homepage() {\n  const dispatch = useAppDispatch();\n  const history = useHistory();\n  const scrapMap = useAppSelector(selectScrapMap);\n  const contactInfo = useAppSelector(selectContactInfo);\n\n  return (\n      <div style={{margin: '24px'}}>\n        <Segment.Group>\n          <Segment>\n            <Header size='medium'>About You\n              <Header.Subheader>\n                Your name / contact info (will be on PDFs you download)\n              </Header.Subheader>\n            </Header>\n            <Form>\n              <Form.Input\n                  label='Author'\n                  defaultValue={contactInfo.author}\n                  onChange={(e) => {\n                    dispatch(updateAuthor(e.target.value));\n                  }}\n              />\n              <Form.TextArea\n                  label='Contact Info'\n                  defaultValue={contactInfo.contactInfo}\n                  onChange={(e) => {\n                    dispatch(updateContactInfo(e.target.value));\n                  }}\n                  rows={2}\n              />\n            </Form>\n          </Segment>\n        </Segment.Group>\n        <Segment.Group >\n          <Segment style={{display: 'flex'}}>\n            <Header size='medium'>Scrap List\n              <Header.Subheader>\n                All your top-level scraps (no parents)\n              </Header.Subheader>\n            </Header>\n            <div style={{flex: 1, textAlign: 'right'}}>\n              <Button icon color='green'\n                onClick={() => {\n                  const newScrap = createNewScrap();\n                  dispatch(createScrap(newScrap));\n\n                  history.push(`/scrap/${newScrap.id}`);\n                }}\n              >\n                <Icon name='add' />\n              </Button>\n            </div>\n          </Segment>\n          {getScrapSection(scrapMap)}\n        </Segment.Group>\n      </div>\n  );\n}\n","import {useAppSelector} from '../../app/hooks';\nimport {Button, Header, Segment} from 'semantic-ui-react';\n\nimport fileDownload from 'js-file-download';\nimport {WritingWorkspace} from '../../protos_v2';\nimport {addScrapToStorage, readAllScrapsFromStorage} from '../../features/scrapList/scrapListPersistence';\nimport {selectScrapMap} from '../../features/scrapList/scrapListSlice';\nimport {readContactInfoFromStorage, writeContactInfoToStorage} from '../print-scrap/contactInfoPersistence';\n\nfunction clearWorkspace() {\n  localStorage.clear();\n  window.location.reload();\n}\n\nfunction downloadWorkspace() {\n  const filename = 'writing_workspace_' + Date.now() + '.write';\n\n  fileDownload(loadDataFromStorage(), filename);\n}\n\nasync function uploadWorkspace(files: FileList|null) {\n  if (!files) {\n    return;\n  }\n\n  const fileData = await files[0].arrayBuffer();\n  const parsedData = new Uint8Array(fileData);\n  loadDataToStorage(parsedData);\n\n  window.location.reload();\n}\n\nexport function loadDataFromStorage(): Uint8Array {\n  const contactInfo = readContactInfoFromStorage();\n\n  const workspace = WritingWorkspace.create({\n    author: contactInfo.author,\n    contactInfo: contactInfo.contactInfo,\n    scraps: readAllScrapsFromStorage(),\n  });\n\n  return WritingWorkspace.encode(workspace).finish();\n}\n\nexport function loadDataToStorage(data: Uint8Array): void {\n  const workspace = WritingWorkspace.decode(data);\n\n  localStorage.clear();\n\n  workspace.scraps.forEach((scrap) => {\n    addScrapToStorage(scrap);\n  });\n\n  writeContactInfoToStorage({\n    author: workspace.author,\n    contactInfo: workspace.contactInfo,\n  });\n}\n\n\nexport default function DataManagementPage() {\n  const scrapMap = useAppSelector(selectScrapMap);\n\n  return (\n      <div style={{margin: '24px'}}>\n        <Segment.Group >\n          <Segment style={{display: 'flex'}}>\n            <Header size='medium'>Data Management\n              <Header.Subheader>\n                Load, Save, or Clear your Workspace\n              </Header.Subheader>\n            </Header>\n          </Segment>\n          <Segment>\n            {Object.keys(scrapMap).length} Scraps\n          </Segment>\n          <Segment>\n            <Button color='green'\n                    onClick={() => {downloadWorkspace()}}>\n              Download Workspace\n            </Button>\n            <Button color='red'\n                    onClick={() => {clearWorkspace()}}>\n              Clear Workspace\n            </Button>\n          </Segment>\n          <Segment>\n            <Header size='small'>Upload Workspace</Header>\n            <input type=\"file\" accept=\".write\" onChange={(event) => uploadWorkspace(event.target.files)} />\n          </Segment>\n        </Segment.Group>\n      </div>\n  );\n}\n","import {CompositeDecorator} from 'draft-js';\nimport {ScrapEmbedComponent, scrapEmbeddingStrategy} from './ScrapEmbedComponent';\nimport {FountainHeaderComponent, FountainHeaderReadOnlyComponent, fountainHeaderStrategy} from './FountainHeaderComponent';\nimport {FountainTransitionComponent, FountainTransitionReadOnlyComponent, fountainTransitionStrategy} from './FountainTransitionComponent';\nimport {FountainCenteredComponent, FountainCenteredReadOnlyComponent, fountainCenteredStrategy} from './FountainCenteredComponent';\nimport {FountainCharacterComponent, FountainCharacterReadOnlyComponent, fountainCharacterStrategy} from './FountainCharacterComponent';\nimport {FountainDialogueComponent, FountainDialogueReadOnlyComponent, fountainDialogueStrategy} from './FountainDialogueComponent';\nimport {FountainParentheticalComponent, FountainParentheticalReadOnlyComponent, fountainParentheticalStrategy} from './FountainParentheticalComponent';\nimport {CommentComponent, commentStrategy} from './CommentComponent';\nimport {FountainActionComponent, FountainActionReadOnlyComponent, fountainActionStrategy} from './FountainActionComponent';\nimport {ScrapPlaceholderComponent, ScrapPlaceholderReadOnlyComponent, scrapPlaceholderStrategy} from './ScrapPlaceholderComponent';\nimport {ScrapTraitComponent, ScrapTraitReadonlyComponent, scrapTraitStrategy} from './ScrapTraitComponent';\n\n/** Decorator for the script editor */\nexport const editorDecorator = new CompositeDecorator([\n  {\n    strategy: scrapPlaceholderStrategy,\n    component: ScrapPlaceholderComponent,\n  },\n  {\n    strategy: scrapTraitStrategy,\n    component: ScrapTraitComponent,\n  },\n  {\n    strategy: scrapEmbeddingStrategy,\n    component: ScrapEmbedComponent,\n  },\n  {\n    strategy: fountainHeaderStrategy,\n    component: FountainHeaderComponent,\n  },\n  {\n    strategy: fountainTransitionStrategy,\n    component: FountainTransitionComponent,\n  },\n  {\n    strategy: fountainCenteredStrategy,\n    component: FountainCenteredComponent,\n  },\n  {\n    strategy: fountainCharacterStrategy,\n    component: FountainCharacterComponent,\n  },\n  {\n    strategy: fountainDialogueStrategy,\n    component: FountainDialogueComponent,\n  },\n  {\n    strategy: fountainParentheticalStrategy,\n    component: FountainParentheticalComponent,\n  },\n  {\n    strategy: commentStrategy,\n    component: CommentComponent,\n  },\n  {\n    strategy: fountainActionStrategy,\n    component: FountainActionComponent,\n  },\n]);\n\n/** Decorator for the script viewer (read-only) */\nexport const viewerDecorator = new CompositeDecorator([\n  {\n    strategy: scrapPlaceholderStrategy,\n    component: ScrapPlaceholderReadOnlyComponent,\n  },\n  {\n    strategy: scrapTraitStrategy,\n    component: ScrapTraitReadonlyComponent,\n  },\n  {\n    strategy: fountainHeaderStrategy,\n    component: FountainHeaderReadOnlyComponent,\n  },\n  {\n    strategy: fountainTransitionStrategy,\n    component: FountainTransitionReadOnlyComponent,\n  },\n  {\n    strategy: fountainCenteredStrategy,\n    component: FountainCenteredReadOnlyComponent,\n  },\n  {\n    strategy: fountainCharacterStrategy,\n    component: FountainCharacterReadOnlyComponent,\n  },\n  {\n    strategy: fountainDialogueStrategy,\n    component: FountainDialogueReadOnlyComponent,\n  },\n  {\n    strategy: fountainParentheticalStrategy,\n    component: FountainParentheticalReadOnlyComponent,\n  },\n  {\n    strategy: fountainActionStrategy,\n    component: FountainActionReadOnlyComponent,\n  },\n]);\n","// @ts-ignore\nimport getFragmentFromSelection from 'draft-js/lib/getFragmentFromSelection';\nimport {ContentState, Editor, EditorState, Modifier} from 'draft-js';\nimport * as clipboard from 'clipboard-polyfill/text';\nimport {v4 as uuid} from 'uuid';\nimport {editorDecorator} from './foutainDecorators';\nimport {Scrap} from '../../protos_v2';\nimport {durationStringToSeconds} from '../utils/durationUtils';\nimport {ScrapDetailsProps, ScrapDetailsState} from './ScrapDetails';\nimport {ScrapMap} from '../scrapList/scrapListSlice';\n\nexport function getSelectedText(editorState: EditorState): string {\n  const selected = getFragmentFromSelection(editorState);\n  return (selected ? selected.map((x: { getText: () => any; }) => x.getText()).join('\\n') : '') as string;\n}\n\nexport function onCut(\n    editor: Editor,\n    e: any,\n    removeWhenDone: boolean,\n    editorState: EditorState,\n    setState: (newState: any) => void): void\n{\n  e.preventDefault();\n\n  const selectedText = getSelectedText(editorState);\n  clipboard.writeText(selectedText).then(() => {\n    if (!removeWhenDone) {\n      return;\n    }\n\n    const newContentState = Modifier.replaceText(\n        editorState.getCurrentContent(),\n        editorState.getSelection(),\n        ''\n    );\n\n    setState({editorState: EditorState.set(editorState, {currentContent: newContentState})});\n  });\n}\n\n\nexport function addChildScrap(\n    editorState: EditorState,\n    onScrapCreate: (scrap: Scrap) => void,\n    setState: (newState: any, callback: () => void) => void,\n    then: () => void\n): void {\n  const currentSelection = editorState.getSelection();\n\n  const currentlySelectedText = getSelectedText(editorState);\n\n  const newScrapId = uuid();\n\n  const newScrap = Scrap.create({\n    id: newScrapId,\n    synopsis: 'New Scrap created in editor',\n    prose: 'this has placeholder content for now',\n  });\n  if (!!currentlySelectedText.trim().length) {\n    newScrap.prose = currentlySelectedText;\n  }\n\n  onScrapCreate(newScrap);\n\n  const thingToInsert = '\\n{{' + newScrapId + '}}\\n';\n\n  const newContentState = currentSelection.isCollapsed() ?\n      Modifier.insertText(\n          editorState.getCurrentContent(),\n          currentSelection,\n          thingToInsert\n      ) : Modifier.replaceText(\n          editorState.getCurrentContent(),\n          currentSelection,\n          thingToInsert\n      );\n\n  setState({\n    editorState: EditorState.createWithContent(ContentState.createFromText(newContentState.getPlainText()), editorDecorator)\n  }, () => {\n    then(); // remap\n  });\n}\n\nexport function replacePlaceholderScraps(\n    editorState: EditorState,\n    onScrapCreate: (scrap: Scrap) => void,\n    setState: (newState: any, callback: () => void) => void,\n    then: () => void\n): void {\n  const currentSelection = editorState.getSelection();\n\n  const currentlySelectedText = getSelectedText(editorState);\n  let textToSwap = currentlySelectedText;\n\n  let re = new RegExp('{{([^}]+)}}', 'g');\n  let match;\n  while (match = re.exec(currentlySelectedText)) {\n    const textToReplace = match[0];\n    const splitText = match[1].split('|');\n\n    if (splitText.length !== 2) {\n      continue;\n    }\n\n    let intendedDurationSec = 0;\n    try {\n      intendedDurationSec = durationStringToSeconds(splitText[1].trim());\n    } catch {}\n\n    const newScrapId = uuid();\n\n    const newScrap = Scrap.create({\n      id: newScrapId,\n      synopsis: splitText[0].trim(),\n      prose: textToReplace,\n      intendedDurationSec: intendedDurationSec\n    });\n\n\n    onScrapCreate(newScrap);\n\n    textToSwap = textToSwap.replace(\n        textToReplace,\n        '\\n{{' + newScrapId + '}}\\n'\n    );\n  }\n\n  const newContentState = Modifier.replaceText(\n      editorState.getCurrentContent(),\n      currentSelection,\n      textToSwap\n  );\n\n  setState({\n    editorState: EditorState.createWithContent(ContentState.createFromText(newContentState.getPlainText()), editorDecorator)\n  }, () => {\n    then();\n  });\n}\n\nexport function absorbPlaceholderScraps(\n    thisScrapId: string,\n    editorState: EditorState,\n    scrapMap: ScrapMap,\n    onScrapDelete: (scrapId: string) => void,\n    setState: (newState: any, callback: () => void) => void,\n    then: () => void\n): void {\n  const currentSelection = editorState.getSelection();\n\n  const currentlySelectedText = getSelectedText(editorState);\n  let textToSwap = currentlySelectedText;\n  const absorbedIds: string[] = [];\n\n  let re = new RegExp('{{([^}]+)}}', 'g');\n  let match;\n  while (match = re.exec(currentlySelectedText)) {\n    const textToReplace = match[0];\n    const idToAbsorb = match[1].trim();\n\n    // Cool, now absorb that ID\n    const scrapToAbsorb = scrapMap[idToAbsorb] as Scrap;\n    if (!scrapToAbsorb) {\n      continue;\n    }\n\n    // Replace the ID reference with the actual prose\n    textToSwap = textToSwap.replace(\n        textToReplace,\n        scrapToAbsorb.prose\n    );\n\n    absorbedIds.push(idToAbsorb);\n  }\n\n  // Go through all absorbed IDs and see which ones can be cleaned up (deleted)\n  const childOfMoreThanThisMap: {[key: string]: boolean} = {};\n  Object.values(scrapMap).forEach((scrap) => {\n    if (scrap.id === thisScrapId) {\n      return;\n    }\n\n    scrap.childScraps.forEach((childScrapId) => {\n      childOfMoreThanThisMap[childScrapId] = true;\n    });\n  });\n\n  const fullyAbsorbedIds = absorbedIds.filter((absorbedId) => {\n    return !childOfMoreThanThisMap[absorbedId]; // If this was only a child of the absorbing scrap, you can delete it now\n  });\n\n  fullyAbsorbedIds.forEach((fullyAbsorbedId) => {\n    onScrapDelete(fullyAbsorbedId);\n  });\n\n  const newContentState = Modifier.replaceText(\n      editorState.getCurrentContent(),\n      currentSelection,\n      textToSwap\n  );\n\n  setState({\n    editorState: EditorState.createWithContent(ContentState.createFromText(newContentState.getPlainText()), editorDecorator)\n  }, () => {\n    then();\n  });\n}\n\nexport function initializeState(props: ScrapDetailsProps): ScrapDetailsState {\n  return {\n    editorState: buildInitialEditorState(props),\n    lastEmittedStr: '',\n    scrapId: props.scrapId,\n    durationErrorString: null,\n    actualDurationSec: 0,\n    parentScrapIds: buildParentScrapIds(props),\n    parseErrorState: false,\n    durationInputKey: 'duration-key-' + Date.now(),\n    focusMode: false,\n  };\n}\n\nfunction buildInitialEditorState(props: ScrapDetailsProps): EditorState {\n  let thisScrap = props.scrapMap[props.scrapId];\n\n  if (!thisScrap) {\n    return EditorState.createEmpty();\n  }\n\n  return EditorState.createWithContent(ContentState.createFromText(thisScrap.prose), editorDecorator)\n}\n\nfunction buildParentScrapIds(props: ScrapDetailsProps): string[] {\n  const thisScrap = props.scrapMap[props.scrapId];\n  const parentScraps = [];\n  for (let key in props.scrapMap) {\n    const scrap = props.scrapMap[key] as Scrap;\n    if (scrap.childScraps.includes(thisScrap.id)) {\n      parentScraps.push(scrap.id);\n    }\n  }\n\n  return parentScraps;\n}\n","import React, {ReactElement} from 'react';\nimport {Scrap} from '../../protos_v2';\nimport {Breadcrumb, BreadcrumbDivider, BreadcrumbSection, Button, Dropdown, Form, Segment} from 'semantic-ui-react';\nimport {Link} from 'react-router-dom';\nimport {ScrapMap} from '../scrapList/scrapListSlice';\nimport {absorbPlaceholderScraps, addChildScrap, replacePlaceholderScraps} from './editorInteractionUtils';\nimport {ScrapDetailsProps, ScrapDetailsState} from './ScrapDetails';\nimport {durationSecondsToString, durationStringToSeconds} from '../utils/durationUtils';\n\nexport function getBreadcrumbs(parentScrapIds: string[], scrapMap: ScrapMap): ReactElement {\n  const parentScraps = parentScrapIds.map((scrapId) => {\n    return scrapMap[scrapId];\n  }).filter(Boolean);\n\n  const parentScrapLinks = parentScraps.map<React.ReactNode>(((parentScrap: Scrap) => {\n    return (<BreadcrumbSection link>\n      <Link to={'/scrap/' + parentScrap.id}>{parentScrap.synopsis}</Link>\n    </BreadcrumbSection>)\n  }));\n\n  let scrapContribution;\n  if (parentScraps.length) {\n    scrapContribution = (<div>Scraps:\n      <Breadcrumb>\n        {\n          parentScrapLinks.reduce((prev, curr) => [prev, <BreadcrumbDivider icon='right chevron' />, curr])\n        }\n      </Breadcrumb>\n    </div>);\n  } else {\n    scrapContribution = (<div>No parent scraps</div>);\n  }\n\n  return (<div>\n    {scrapContribution}\n  </div>);\n}\n\nexport function getProseEditorToolbar(\n    props: ScrapDetailsProps,\n    state: ScrapDetailsState,\n    remapEditorContent: () => void,\n    setState: (newState: any, callback: () => void) => void,\n): ReactElement {\n  const parseWarning = state.parseErrorState ?\n      (<div style={{color: 'red'}}>Parsing took too long, please break into smaller chunks</div>) : null;\n\n  const focusLabel = state.focusMode ? 'Focus Off' : 'Focus On';\n\n  const actualDurationSec = state.actualDurationSec;\n  const intendedDurationSec = props.scrapMap[props.scrapId].intendedDurationSec;\n  let durationPercentLabel = `${Math.ceil(1000 * actualDurationSec / intendedDurationSec) / 10}% Complete`;\n\n  return <div>\n    <div style={{display: 'flex'}}>\n      <button onClick={() => addChildScrap(\n          state.editorState,\n          props.onScrapCreate,\n          (newState, callback) => {setState(newState, callback);},\n          () => remapEditorContent()\n      )}>Add child scrap</button>\n      <button onClick={() => replacePlaceholderScraps(\n          state.editorState,\n          props.onScrapCreate,\n          (newState, callback) => {setState(newState, callback);},\n          () => remapEditorContent()\n      )}>Replace placeholder scraps</button>\n      <button onClick={() => absorbPlaceholderScraps(\n          props.scrapId,\n          state.editorState,\n          props.scrapMap,\n          props.onScrapDelete,\n          (newState, callback) => {setState(newState, callback);},\n          () => remapEditorContent()\n      )}>\n        Absorb selected scraps\n      </button>\n      <span style={{flex: 1}}>&nbsp;</span>\n      <span style={{margin: 'auto 24px'}}>{durationPercentLabel}</span>\n      <button onClick={() => {\n        setState({\n          focusMode: !state.focusMode\n        }, () => {});\n      }}>{focusLabel}</button>\n    </div>\n    {parseWarning}\n  </div>;\n}\n\nexport function getPrimaryForm(\n    thisScrap: Scrap,\n    state: ScrapDetailsState,\n    props: ScrapDetailsProps,\n    setState: (newState: any, callback: () => void) => void,\n): ReactElement {\n  return <Segment>\n    <Form>\n      <div style={{display: 'flex'}}>\n        <div style={{flex: 1, margin: '16px 0'}}>\n          <Form.Input\n              label='Synopsis'\n              defaultValue={thisScrap.synopsis}\n              onChange={(e) => {\n                const scrap = props.scrapMap[props.scrapId] as Scrap;\n                scrap.synopsis = e.target.value;\n                props.onScrapUpdate(scrap);\n              }}\n          />\n        </div>\n        <div style={{flex: 1, margin: '16px'}}>\n          <Form.Input\n              key={state.durationInputKey}\n              style={{flex: 1}}\n              label='Intended Duration (HH:MM:SS)'\n              defaultValue={durationSecondsToString(thisScrap.intendedDurationSec)}\n              error={state.durationErrorString}\n              onChange={(e) => {\n                onDurationChange(e.target.value, props, setState);\n              }}\n          />\n        </div>\n        <div style={{flex: 1, margin: '16px auto'}}>\n          <Form.Field>\n            <label>\n              Completeness\n            </label>\n            <Dropdown\n                selection\n                options = {[\n                  {\n                    key: 'not_started',\n                    text: 'Not Started',\n                    value: Scrap.Completeness.NOT_STARTED,\n                  },\n                  {\n                    key: 'brainstorm',\n                    text: 'Brainstorm',\n                    value: Scrap.Completeness.BRAINSTORM,\n                  },\n                  {\n                    key: 'draft',\n                    text: 'Initial Draft',\n                    value: Scrap.Completeness.INITIAL_DRAFT,\n                  },\n                  {\n                    key: 'polished',\n                    text: 'Polished',\n                    value: Scrap.Completeness.POLISHED,\n                  },\n                  {\n                    key: 'final',\n                    text: 'Final',\n                    value: Scrap.Completeness.FINAL,\n                  },\n                ]}\n                value={thisScrap.completeness || Scrap.Completeness.NOT_STARTED}\n                onChange={(e, data) => {\n                  const scrap = props.scrapMap[props.scrapId] as Scrap;\n                  scrap.completeness = data.value as number;\n                  props.onScrapUpdate(scrap);\n                }}\n            />\n          </Form.Field>\n        </div>\n        <div style={{flex: 1, margin: 'auto'}}>\n          <Form.Field>\n            <label>\n              Current Actual Duration: {durationSecondsToString(state.actualDurationSec)}\n            </label>\n            <Button\n                onClick={() => {\n                  updateExpectedDurationSec(props, state, setState);\n                }}\n                disabled={state.actualDurationSec === thisScrap.intendedDurationSec}\n            >\n              Update expected duration\n            </Button>\n          </Form.Field>\n        </div>\n      </div>\n    </Form>\n  </Segment>\n}\n\nfunction onDurationChange(newDuration: string, props: ScrapDetailsProps, setState: (newState: any, callback: () => void) => void) {\n  let durationSec;\n  try {\n    durationSec = durationStringToSeconds(newDuration);\n  } catch {\n    return setDurationErrorString(true, setState);\n  }\n\n  const scrap = props.scrapMap[props.scrapId] as Scrap;\n\n  scrap.intendedDurationSec = durationSec;\n  props.onScrapUpdate(scrap);\n  setDurationErrorString(false, setState);\n}\n\nfunction updateExpectedDurationSec(props: ScrapDetailsProps, state: ScrapDetailsState, setState: (newState: any, callback: () => void) => void): void {\n  const scrap = props.scrapMap[props.scrapId] as Scrap;\n\n  scrap.intendedDurationSec = state.actualDurationSec;\n  props.onScrapUpdate(scrap);\n  setState({\n    durationInputKey: 'duration-key-' + Date.now()\n  }, () => {\n    setDurationErrorString(false, setState);\n  });\n}\n\nfunction setDurationErrorString(hasError: boolean, setState: (newState: any, callback: () => void) => void) {\n  setState({\n    durationErrorString: hasError ? 'Please enter a duration of format HH:MM:SS' : null\n  }, () => {});\n}\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport React, {Component} from 'react';\nimport {Editor, EditorState} from 'draft-js';\nimport 'draft-js/dist/Draft.css';\nimport {Scrap} from '../../protos_v2';\nimport debounce from 'debounce';\nimport {isArrayEqualToImmutableSet, parseAllProse} from './parseProse';\nimport {FOUNTAIN_EDITOR_STYLE} from './usefulConstants';\nimport {HeaderOptions} from '../revision-header/headerOptionsSlice';\nimport {initializeState, onCut} from './editorInteractionUtils';\nimport {getBreadcrumbs, getPrimaryForm, getProseEditorToolbar} from './ScrapDetailsHelperComponents';\n\nexport interface ScrapDetailsProps {\n  scrapId: string;\n  scrapMap: ScrapMap;\n  onScrapCreate: (scrap: Scrap) => void;\n  onScrapUpdate: (scrap: Scrap) => void;\n  onScrapDelete: (scrapId: string) => void;\n  headerOptions: HeaderOptions;\n  onUpdateHeaderOptions: (headerOptions: HeaderOptions) => void;\n}\n\nexport interface ScrapDetailsState {\n  editorState: EditorState;\n  lastEmittedStr: string;\n  scrapId: string;\n  durationErrorString: string|null;\n  parseErrorState: boolean;\n  actualDurationSec: number;\n  parentScrapIds: string[];\n  durationInputKey: string;\n  focusMode: boolean;\n}\n\nconst styleMap = {\n  'GREEN': {\n    color: 'green'\n  },\n}\n\nexport default class ScrapDetails extends Component<ScrapDetailsProps, ScrapDetailsState> {\n  domEditor: any;\n\n  constructor(props: ScrapDetailsProps) {\n    super(props);\n\n    this.state = initializeState(props);\n    this.remapEditorContent();\n  }\n\n  setHeaderOptions(): void {\n    this.props.onUpdateHeaderOptions({\n      ...this.props.headerOptions,\n      currentScrapId: this.props.scrapId,\n      showReadLink: true,\n      showEditLink: false,\n      showPrintLink: true,\n      characterFilters: [],\n      currentCharacterFilter: '',\n      currentCompletionFilter: '',\n      traitFilters: [],\n      currentTraitFilter: '',\n    });\n  }\n\n  componentDidMount() {\n    this.setHeaderOptions();\n  }\n\n  componentDidUpdate(prevProps: Readonly<ScrapDetailsProps>, prevState: Readonly<ScrapDetailsState>, snapshot?: any) {\n    if (this.state.scrapId === this.props.scrapId) {\n      return;\n    }\n\n    // Need to update\n    this.setHeaderOptions();\n    this.setState(initializeState(this.props));\n    this.remapEditorContent();\n  }\n\n  setDomEditorRef(ref: any) {\n    this.domEditor = ref;\n  }\n\n  focus(): void {\n    this.domEditor.focus();\n  }\n\n  onProseChange(newState: EditorState): void {\n    this.setState({editorState: newState});\n\n    this.remapEditorContent(); // Restyle, but only after things settle down a bit\n  }\n\n  persistProse(newProseStr: string): void {\n    const scrap = this.props.scrapMap[this.props.scrapId] as Scrap;\n\n    scrap.prose = newProseStr;\n    this.props.onScrapUpdate(scrap);\n  }\n\n  remapEditorContent = debounce(() => {\n    const newStrToEmit = this.state.editorState.getCurrentContent().getPlainText();\n\n    if (newStrToEmit === this.state.lastEmittedStr) {\n      return; // No need to update\n    }\n\n    this.persistProse(newStrToEmit);\n\n    const parseResult = parseAllProse(this.state.editorState.getCurrentContent(), this.props.scrapMap,50, 500);\n\n    // Check to see if we need to update the scrap b/c the references to child scraps changed\n    const thisScrap = this.props.scrapMap[this.props.scrapId];\n\n    if (!isArrayEqualToImmutableSet(parseResult.childScraps, thisScrap.childScraps)) {\n      const newScrap = Scrap.create({\n        ...thisScrap,\n        childScraps: [ ...(parseResult.childScraps.toArray()) ]\n      });\n\n      this.props.onScrapUpdate(newScrap);\n    }\n\n    this.setState({\n      editorState: EditorState.set(this.state.editorState, {currentContent: parseResult.contentState}),\n      lastEmittedStr: newStrToEmit,\n      actualDurationSec: Math.round(parseResult.totalDurationSec),\n      parseErrorState: parseResult.showTimeoutWarning,\n    });\n  }, 200);\n\n\n  render() {\n    let thisScrap = this.props.scrapMap[this.props.scrapId];\n\n    if (!thisScrap) {\n      return (\n          <div>Whoops, could not find scrap</div>\n      );\n    }\n\n    let noFocusSection = null;\n    if (!this.state.focusMode) {\n      noFocusSection = <div>\n        {getBreadcrumbs(this.state.parentScrapIds, this.props.scrapMap)}\n        {getPrimaryForm(\n            thisScrap,\n            this.state,\n            this.props,\n            (newState, callback) => { this.setState(newState, callback)}\n        )}\n      </div>\n    }\n\n    return (\n        <div style={{height: '100%', display: 'flex', flexDirection: 'column'}} key={'scrap-details-' + this.props.scrapId}>\n          {noFocusSection}\n          {getProseEditorToolbar(\n              this.props,\n              this.state,\n              this.remapEditorContent,\n              (newState, callback) => { this.setState(newState, callback)}\n          )}\n          <div\n              onClick={() => {this.focus()}}\n              style={FOUNTAIN_EDITOR_STYLE}>\n            <Editor\n                customStyleMap={styleMap}\n                spellCheck={true}\n                stripPastedStyles={true}\n                onCut={(editor, e) => {\n                  onCut(editor, e, true, this.state.editorState, (newState) => {this.setState(newState);});\n                }}\n                onCopy={(editor, e) => {\n                  onCut(editor, e, false, this.state.editorState, (newState) => {this.setState(newState);});\n                }}\n                editorState={this.state.editorState}\n                ref={(ref) => {this.setDomEditorRef(ref);}}\n                onChange={(newState) => {this.onProseChange(newState); }}/>\n          </div>\n        </div>\n    );\n  }\n\n}\n","import { RouteComponentProps } from 'react-router';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {createScrap, removeScrap, selectScrapMap, updateScrap} from '../../features/scrapList/scrapListSlice';\nimport ScrapDetails from '../../features/scrapDetails/ScrapDetails';\nimport {readHeaderOptions, updateHeaderOptions} from '../../features/revision-header/headerOptionsSlice';\n\ninterface MatchParams {\n  id: string\n}\n\ninterface ScrapDetailsProps extends RouteComponentProps<MatchParams> {}\n\nexport default function ScrapDetailsPage (props: ScrapDetailsProps) {\n  const scrapMap = useAppSelector(selectScrapMap);\n  const headerOptions = useAppSelector(readHeaderOptions);\n  const dispatch = useAppDispatch();\n\n  return (\n      <ScrapDetails\n          scrapId={props.match.params.id}\n          scrapMap={scrapMap}\n          onScrapCreate={(scrap) => dispatch(createScrap(scrap.toJSON()))}\n          onScrapUpdate={(scrap) => dispatch(updateScrap(scrap.toJSON()))}\n          onScrapDelete={(scrapId) => dispatch(removeScrap(scrapId))}\n          headerOptions={headerOptions}\n          onUpdateHeaderOptions={(headerOptions) => dispatch(updateHeaderOptions(headerOptions))}\n      />\n  )\n}\n","import React, {Component, ReactElement} from 'react';\n\ntype Candidate = {\n  label: string;\n  description: string;\n  currentScore: number;\n  wins: number;\n  losses: number;\n}\n\ntype MyState = {\n  showListInput: boolean;\n  showCurrentScores: boolean;\n  nextCandidateLabel: string;\n  nextCandidateDesc: string;\n\n  candidates: Candidate[];\n  winMatrix: number[][];\n  candidateIndexA: number;\n  candidateIndexB: number;\n}\n\nexport default class DecisionPage extends Component<any, MyState> {\n\n\n  state: MyState = {\n    showListInput: true,\n    showCurrentScores: false,\n    nextCandidateLabel: '',\n    nextCandidateDesc: '',\n    candidates: [],\n    winMatrix: [],\n    candidateIndexA: -1,\n    candidateIndexB: -1,\n  };\n\n  addCandidate(): void {\n    let newCandidates = [...this.state.candidates, {\n      label: this.state.nextCandidateLabel,\n      description: this.state.nextCandidateDesc,\n      currentScore: 1,\n      wins: 0,\n      losses: 0,\n    } as Candidate];\n\n    let defaultValue = 1 / (10 * newCandidates.length);\n    let winMatrix = [...Array(newCandidates.length)].map(e => Array(newCandidates.length).fill(defaultValue)) as number[][];\n\n    for (let i = 0; i < winMatrix.length; i++) {\n      winMatrix[i][i] = 0;\n    }\n\n    this.setState({\n      ...this.state,\n      candidates: newCandidates,\n      winMatrix: winMatrix,\n      nextCandidateLabel: '',\n      nextCandidateDesc: '',\n    });\n  }\n\n  setupNewComparison(): void {\n    let indexAWeights = this.state.candidates.map((ignore, idx) => {\n      return 1 / this.getTotalComparisons(idx);\n    });\n\n    let indexA = this.randomSelectWeighted(indexAWeights);\n\n    let indexBWeights = indexAWeights.map((ignore, idx) => {\n      if (idx === indexA) {\n        return 0;\n      }\n\n      return 1 / (this.state.winMatrix[idx][indexA] + this.state.winMatrix[indexA][idx]);\n    });\n\n    let indexB = this.randomSelectWeighted(indexBWeights);\n\n    this.setState({\n      ...this.state,\n      showListInput: false,\n      candidateIndexA: indexA,\n      candidateIndexB: indexB,\n    })\n  }\n\n  randomSelectWeighted(weights: number[]): number {\n    let sumWeight = weights.reduce(((previousValue, currentValue) => previousValue + currentValue));\n\n    let randomCutoff = Math.random() * sumWeight;\n    let sum = 0;\n    for (let i = 0; i < weights.length; i++) {\n      sum += weights[i];\n      if (sum >= randomCutoff) {\n        return i;\n      }\n    }\n\n    throw Error('should not get here');\n  }\n\n  getTotalComparisons(index: number): number {\n    let totalComparisons = 0;\n    for (let i = 0; i < this.state.winMatrix.length; i++) {\n      totalComparisons += this.state.winMatrix[index][i] + this.state.winMatrix[i][index];\n    }\n\n    return totalComparisons;\n  }\n\n  renderComparison(): ReactElement {\n    if (this.state.candidateIndexA < 0 || this.state.candidateIndexB < 0) {\n      return (<div>no comparison yet</div>);\n    }\n\n    let candidateA = this.state.candidates[this.state.candidateIndexA];\n    let candidateB = this.state.candidates[this.state.candidateIndexB];\n\n    return (<div style={{marginTop: '100px', marginBottom: '100px'}}>\n      <h2>Comparison</h2>\n      <div style={{display: 'flex'}}>\n        <div style={{flex: 1}}>\n          <h3>{candidateA.label}\n            <button onClick={() => this.updateWin(this.state.candidateIndexA, this.state.candidateIndexB)}>Select</button>\n          </h3>\n          {candidateA.description.split('\\n').map(line => (<p>{line}</p>))}\n        </div>\n        <div style={{flex: 1}}>\n          <h3>{candidateB.label}\n            <button onClick={() => this.updateWin(this.state.candidateIndexB, this.state.candidateIndexA)}>Select</button>\n          </h3>\n          {candidateB.description.split('\\n').map(line => (<p>{line}</p>))}\n        </div>\n      </div>\n    </div>)\n  }\n\n  updateWin(winIndex: number, loseIndex: number): void {\n    let winMatrix = this.state.winMatrix;\n    winMatrix[winIndex][loseIndex] += 1;\n\n    let candidates = this.state.candidates;\n    candidates[winIndex].wins += 1;\n    candidates[loseIndex].losses += 1;\n\n    // Update all the scores\n    // Based on sloppy implementation of https://stats.stackexchange.com/questions/83005/how-to-calculate-ratings-rankings-from-paired-comparison-pairwise-comparison-o\n    for (let iteration = 0; iteration < 1000; iteration++) {\n      // Naive iteration for now\n\n      for (let i = 0; i < candidates.length; i++) {\n\n        let W_i = 0;\n        for (let j = 0; j < candidates.length; j++) {\n          W_i += winMatrix[i][j];\n        }\n\n        let denominator = 0;\n        for (let j = 0; j < candidates.length; j++) {\n          if (i !== j) {\n            let N_ij = winMatrix[i][j] + winMatrix[j][i];\n            denominator += (N_ij) / (candidates[i].currentScore + candidates[j].currentScore);\n          }\n        }\n\n        candidates[i].currentScore = W_i / denominator;\n      }\n\n      // Re-normalize\n      let averageValue = 0;\n      for (let i = 0; i < candidates.length; i++) {\n        averageValue += candidates[i].currentScore;\n      }\n      averageValue /= candidates.length;\n      for (let i = 0; i < candidates.length; i++) {\n        candidates[i].currentScore /= averageValue;\n      }\n    }\n\n\n\n    this.setState({\n      ...this.state,\n      candidates: candidates,\n      winMatrix: winMatrix\n    }, () => {\n      this.setupNewComparison();\n    });\n  }\n\n  renderWinMatrix(): ReactElement {\n    if (!this.state.showCurrentScores) {\n      return (<div></div>);\n    }\n\n    return (<div><h2>Current Win Matrix</h2><pre>\n      {this.state.winMatrix.map(line => {\n        return line.join(',\\t') + '\\n';\n      })}\n    </pre></div>)\n  }\n\n  renderCandidates(): ReactElement {\n    if (!this.state.showCurrentScores && !this.state.showListInput) {\n      return (<div></div>);\n    }\n\n    let sortedCandidates = this.state.candidates\n        .map((candidate) => candidate) // Cheap sort\n        .sort((a, b) => b.currentScore - a.currentScore);\n\n    return (<div>\n      <h2>{sortedCandidates.length} Candidates</h2>\n      {sortedCandidates.map((candidate, idx) => {\n        return (<div>\n          <h3>{candidate.label} ({candidate.currentScore}, {candidate.wins} wins, {candidate.losses} losses)</h3>\n        </div>);\n      })}\n    </div>);\n  }\n\n  toggleShowCurrentScores(): void {\n    this.setState(\n        {...this.state, showCurrentScores: !this.state.showCurrentScores}\n    );\n  }\n\n  updateNextCandidateLabel(newValue: string): void {\n    this.setState({\n      ...this.state,\n      nextCandidateLabel: newValue\n    });\n  }\n\n  updateNextCandidateDesc(newValue: string): void {\n    this.setState({\n      ...this.state,\n      nextCandidateDesc: newValue\n    });\n  }\n\n  render() {\n    let mainContent;\n    if (this.state.showListInput) {\n      mainContent = (\n        <div>\n          <h2>Declare Candidates</h2>\n          <p>\n            Let's create some candidates\n          </p>\n          <div>\n            <input\n                type='text'\n                value={this.state.nextCandidateLabel}\n                onChange={(e) => this.updateNextCandidateLabel(e.target.value)} />\n            <textarea\n                value={this.state.nextCandidateDesc}\n                onChange={(e) => this.updateNextCandidateDesc(e.target.value)}></textarea>\n          </div>\n\n          <button style={{display: 'block'}} onClick={() => this.addCandidate()}>Add Candidate</button>\n          <button style={{display: 'block'}} onClick={() => this.setupNewComparison()}>Parse and begin</button>\n          {this.renderCandidates()}\n        </div>\n      );\n    } else {\n      mainContent = (<div>\n        {this.renderComparison()}\n\n        <button style={{display: 'block'}} onClick={() => this.toggleShowCurrentScores()}>Toggle results</button>\n\n        {this.renderWinMatrix()}\n        {this.renderCandidates()}\n      </div>);\n    }\n\n    return (\n        <div style={{margin: '24px'}}>\n          <h1>Decisions</h1>\n          <p>\n            Let's make some decisions based on pairwise comparisons. You know that FaceMash scene in Social Network?\n            It's just like that, except hopefully you're using it for better decisions.\n          </p>\n          {mainContent}\n        </div>\n    );\n  }\n}\n","import {ScrapMap} from '../scrapList/scrapListSlice';\nimport {Editor, ContentState, ContentBlock, EditorState} from 'draft-js';\nimport {Component, ReactElement} from 'react';\nimport {viewerDecorator} from './foutainDecorators';\nimport {FOUNTAIN_EDITOR_STYLE} from './usefulConstants';\n\ninterface ReadOnlyViewerProps {\n  scrapId: string;\n  scrapMap: ScrapMap;\n  parsedContentBlocks: ContentBlock[];\n}\n\ninterface ReadOnlyViewerState {\n  scrapId: string;\n  editorState: EditorState;\n}\n\nexport class ReadOnlyViewer extends Component<ReadOnlyViewerProps, ReadOnlyViewerState> {\n\n  constructor(props: ReadOnlyViewerProps) {\n    super(props);\n\n    this.state = this.initializeState(props);\n  }\n\n  initializeState(props: ReadOnlyViewerProps): ReadOnlyViewerState {\n    return {\n      scrapId: props.scrapId,\n      editorState: this.buildInitialEditorState(props)\n    };\n  }\n\n  componentDidUpdate(prevProps: Readonly<ReadOnlyViewerProps>, prevState: Readonly<ReadOnlyViewerState>, snapshot?: any) {\n    if (this.state.scrapId === this.props.scrapId) {\n      return;\n    }\n\n    // Need to update\n    this.setState(this.initializeState(this.props));\n  }\n\n  buildInitialEditorState(props: ReadOnlyViewerProps): EditorState {\n    let thisScrap = props.scrapMap[props.scrapId];\n\n    if (!thisScrap) {\n      return EditorState.createEmpty();\n    }\n\n    return EditorState.createWithContent(\n        ContentState.createFromBlockArray(\n            this.props.parsedContentBlocks),\n        viewerDecorator);\n  }\n\n  normalizeProse(prose: string): string {\n    return prose; // TODO: actually normalize things, remove comments, normalize whitespace\n  }\n\n  render(): ReactElement {\n    return <div\n        style={FOUNTAIN_EDITOR_STYLE}>\n      <Editor\n        readOnly\n        onChange={() => {}}\n        editorState={this.state.editorState}\n      />\n    </div>\n  }\n\n}\n","import { RouteComponentProps } from 'react-router';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {ScrapMap, selectScrapMap} from '../../features/scrapList/scrapListSlice';\nimport React, {Component} from 'react';\nimport {ContentBlock} from 'draft-js';\nimport {fetchParsedContentBlocksForScrap} from '../../features/utils/fetchParsedContentBlocksForScrap';\nimport {TimelineViewer} from '../../features/timeline/Timeline';\nimport {ReadOnlyViewer} from '../../features/scrapDetails/ReadOnlyViewer';\nimport {HeaderOptions, readHeaderOptions, updateHeaderOptions} from '../../features/revision-header/headerOptionsSlice';\nimport {fetchCharacters} from '../../features/utils/fetchCharacters';\nimport {fetchTraits} from '../../features/utils/fetchTraits';\n\ninterface MatchParams {\n  id: string\n}\n\ninterface ReadScrapProps extends RouteComponentProps<MatchParams> {}\n\nexport default function ReadScrapPage (props: ReadScrapProps) {\n  const scrapMap = useAppSelector(selectScrapMap);\n  const dispatch = useAppDispatch();\n  const headerOptions = useAppSelector(readHeaderOptions);\n\n  return (\n      <ReadScrap\n          scrapId={props.match.params.id}\n          scrapMap={scrapMap}\n          onUpdateHeaderOptions={(newHeaderOptions) => dispatch(updateHeaderOptions(\n              {\n                ...headerOptions,\n                ...newHeaderOptions,\n              }))}\n          headerOptions={headerOptions}\n      />\n  )\n}\n\ninterface ReadPageProps {\n  scrapId: string;\n  scrapMap: ScrapMap;\n  onUpdateHeaderOptions: (headerOptions: HeaderOptions) => void;\n  headerOptions: HeaderOptions;\n}\n\ninterface ReadPageState {\n  scrapId: string;\n  hasLoaded: boolean;\n  parsedContentBlocks: ContentBlock[];\n}\n\nexport class ReadScrap extends Component<ReadPageProps, ReadPageState> {\n\n  constructor(props: ReadPageProps) {\n    super(props);\n\n    this.state = {\n      scrapId: props.scrapId,\n      hasLoaded: false,\n      parsedContentBlocks: [],\n    };\n  }\n\n  componentDidMount() {\n    const parsedBlocks = fetchParsedContentBlocksForScrap(this.props.scrapId, [], this.props.scrapMap);\n\n    const characters = fetchCharacters(parsedBlocks);\n    const traits = fetchTraits(parsedBlocks);\n\n    this.setState({\n      hasLoaded: true,\n      parsedContentBlocks: parsedBlocks,\n    });\n\n    this.props.onUpdateHeaderOptions({\n      ...this.props.headerOptions,\n      currentScrapId: this.state.scrapId,\n      showReadLink: false,\n      showEditLink: true,\n      showPrintLink: true,\n      characterFilters: characters,\n      traitFilters: traits,\n    });\n  }\n\n  render() {\n    if (!this.state.hasLoaded) {\n      return <div> ... loading ...</div>\n    }\n\n    return <div style={{height: '100%', display: 'flex', flexDirection: 'column'}}>\n      <TimelineViewer\n          scrapId={this.state.scrapId}\n          scrapMap={this.props.scrapMap}\n          parsedContentBlocks={this.state.parsedContentBlocks}\n          currentCharacterFilter={this.props.headerOptions.currentCharacterFilter || ''}\n          currentCompletionFilter={this.props.headerOptions.currentCompletionFilter || ''}\n          currentTraitFilter={this.props.headerOptions.currentTraitFilter || ''}\n      />\n      <ReadOnlyViewer\n          scrapId={this.state.scrapId}\n          scrapMap={this.props.scrapMap}\n          parsedContentBlocks={this.state.parsedContentBlocks}/>\n    </div>\n  }\n}\n","import {ContentBlock} from 'draft-js';\nimport {character, durationSecContribution} from '../scrapDetails/usefulConstants';\n\nexport interface CharacterAppearance {\n  character: string;\n  totalDurationSec: number;\n  percentDurationSec: number;\n}\n\nexport function fetchCharacters(parsedBlocks: ContentBlock[]): CharacterAppearance[] {\n  const characterMap: {[key: string]: CharacterAppearance} = {};\n\n  let totalDurationSec = 0;\n  parsedBlocks.forEach((block) => {\n    const blockData = block.getData();\n\n    const thisCharacter = blockData.get(character) as string;\n    const thisDurationSecContribution = (blockData.get(durationSecContribution) || 0) as number;\n\n    totalDurationSec += thisDurationSecContribution;\n\n    if (!!thisCharacter) {\n      if (!characterMap[thisCharacter]) {\n        characterMap[thisCharacter] = {\n          character: thisCharacter,\n          totalDurationSec: 0,\n          percentDurationSec: 0,\n        };\n      }\n      characterMap[thisCharacter].totalDurationSec += thisDurationSecContribution;\n    }\n  });\n\n  return Object.values(characterMap).sort((b, a) => {\n    return a.totalDurationSec - b.totalDurationSec;\n  }).map((characterEntry) => {\n    characterEntry.percentDurationSec = characterEntry.totalDurationSec / totalDurationSec;\n    return characterEntry;\n  });\n}\n","import {ContentBlock} from 'draft-js';\nimport {scrapTraitText} from '../scrapDetails/usefulConstants';\n\nexport interface TraitAppearance {\n  trait: string;\n  numberOfAppearances: number;\n}\n\nexport function fetchTraits(parsedBlocks: ContentBlock[]): TraitAppearance[] {\n  const traitMap: {[key: string]: TraitAppearance} = {};\n\n  parsedBlocks.forEach((block) => {\n    const blockData = block.getData();\n\n    const traitText = (blockData.get(scrapTraitText) || '') as string;\n    traitText.split('#').filter(Boolean).forEach((untrimmedTrait) => {\n      const trait = untrimmedTrait.trim();\n\n      if (!traitMap[trait]) {\n        traitMap[trait] = {\n          trait: trait,\n          numberOfAppearances: 0\n        };\n      }\n\n      traitMap[trait].numberOfAppearances += 1;\n    });\n  });\n\n  return Object.values(traitMap).sort((a, b) => {\n    return b.numberOfAppearances - a.numberOfAppearances;\n  });\n}\n","export default __webpack_public_path__ + \"static/media/CourierPrime-Regular.68d89efc.ttf\";","export default __webpack_public_path__ + \"static/media/CourierPrime-Bold.ac693e5a.ttf\";","export default __webpack_public_path__ + \"static/media/CourierPrime-Italic.e56d9623.ttf\";","export default __webpack_public_path__ + \"static/media/CourierPrime-Bold-Italic.40cb412d.ttf\";","import React from 'react';\nimport {PDFViewer, Font, Page, Text, View, Document, StyleSheet } from '@react-pdf/renderer';\nimport {ContentBlock} from 'draft-js';\nimport {Scrap} from '../../protos_v2';\nimport {isFountainCentered, isFountainCharacter, isFountainDialogue, isFountainHeader, isFountainParenthetical, isFountainTransition, isScrapPlaceholder, isScrapTrait} from '../../features/scrapDetails/usefulConstants';\nimport {\n  Style\n} from '@react-pdf/types';\nimport {PrintPageProps} from './PrintScrapPage';\n\n// @ts-ignore\nimport CourierPrime from '../../courierPrime/CourierPrime-Regular.ttf';\n\n// @ts-ignore\nimport CourierPrimeBold from '../../courierPrime/CourierPrime-Bold.ttf';\n\n// @ts-ignore\nimport CourierPrimeItalic from '../../courierPrime/CourierPrime-Italic.ttf';\n\n// @ts-ignore\nimport CourierPrimeBoldItalic from '../../courierPrime/CourierPrime-Bold-Italic.ttf';\n\nFont.register({ family: 'CourierPrime', format: 'truetype', src: CourierPrime});\nFont.register({ family: 'CourierPrimeBold', format: 'truetype', src: CourierPrimeBold});\nFont.register({ family: 'CourierPrimeItalic', format: 'truetype', src: CourierPrimeItalic});\nFont.register({ family: 'CourierPrimeBoldItalic', format: 'truetype', src: CourierPrimeBoldItalic});\n\n// Disable hyphenation\nFont.registerHyphenationCallback(word => [word]);\n\nconst ONE_LINE_PADDING = '12pt';\n\n// Create styles\nconst styles = StyleSheet.create({\n  title: {\n    marginLeft: '72pt',\n    marginTop: '2in',\n    textAlign: 'center',\n    textDecoration: 'underline',\n    width: '252pt'\n  },\n  author: {\n    marginLeft: '72pt',\n    paddingTop: '18pt',\n    textAlign: 'center',\n    width: '252pt'\n  },\n  contactInfo: {\n    position: 'absolute',\n    //right: '1.25in',\n    //top: '0.5in',\n    bottom: '1in',\n    left: '1.5in',\n  },\n  dateInfo: {\n    position: 'absolute',\n    right: '1in',\n    //top: '0.5in',\n    bottom: '1in',\n    //left: '1in',\n  },\n  page: {\n    fontFamily: 'CourierPrime',\n    fontSize: '12pt',\n    paddingTop: '1in',\n    paddingLeft: '1.5in',\n    paddingRight: '1in',\n    paddingBottom: '1in',\n    margin: '0'\n  },\n  characterLine: {\n    marginLeft: '144pt',\n    width: '204pt'\n  },\n  dialogueLine: {\n    marginLeft: '72pt',\n    width: '252pt'\n  },\n  parentheticalLine: {\n    marginLeft: '108pt',\n    width: '234pt',\n  },\n  transitionLine: {\n    paddingTop: ONE_LINE_PADDING,\n    textAlign: 'right',\n  },\n  centeredLine: {\n    textAlign: 'center',\n  },\n  sceneHeaderLine: {\n    fontFamily: 'CourierPrimeBold',\n    paddingBottom: ONE_LINE_PADDING\n  },\n  block: {\n    paddingBottom: ONE_LINE_PADDING\n  },\n  bold: {\n    fontFamily: 'CourierPrimeBold',\n  },\n  italic: {\n    fontFamily: 'CourierPrimeItalic',\n  },\n  boldItalic: {\n    fontFamily: 'CourierPrimeBoldItalic',\n  },\n  underline: {\n    textDecoration: 'underline',\n  },\n  pageNumber: {\n    position: 'absolute',\n    right: '1.25in',\n    top: '0.5in',\n    left: '1.5in',\n    textAlign: 'right',\n  }\n});\n\n// Defines a block of elements that must exist on the same page\ninterface PDFBlock {\n  elements: ScriptElement[];\n}\n\n// Defines a text block that contains some amount of emphasis\ninterface TextEmphasisBlock {\n  style: object;\n  text: string;\n}\n\nenum ElementType {\n  SCENE_HEADING,\n  ACTION,\n  DIALOGUE,\n  CHARACTER,\n  PARENTHETICAL,\n  TRANSITION,\n  CENTERED,\n}\n\ninterface ScriptElement {\n  text: string;\n  style?: Style;\n  type: ElementType,\n}\n\nfunction newPDFBlock(): PDFBlock {\n  return {\n    elements: []\n  };\n}\n\nfunction shouldCreateNewBlock(lastElementType: ElementType|null, nextElementType: ElementType): boolean {\n  if (nextElementType === ElementType.TRANSITION) {\n    return false; // Don't let transitions start on a page by themselves\n  }\n\n  if ([ElementType.DIALOGUE, ElementType.PARENTHETICAL].includes(nextElementType)) {\n    return false; // Dialogue / parentheticals shouldn't start a page by themselves\n  }\n\n  if (lastElementType === ElementType.SCENE_HEADING) {\n    return false; // Don't let a scene heading be the last thing on a page\n  }\n\n  return true;\n}\n\nfunction parsePDFBlocks(parsedContentBlocks: ContentBlock[]): PDFBlock[] {\n  const pdfBlocks: PDFBlock[] = [];\n\n  let nextPDFBlock = newPDFBlock();\n  let mostRecentCharacter: string;\n\n  parsedContentBlocks.forEach((block) => {\n    const blockData = block.getData();\n    let blockText = block.getText();\n\n    if (!blockText.trim().length) {\n      return;\n    }\n\n    if (blockData.get(isScrapTrait)) {\n      return; // Don't render traits in PDF\n    }\n\n    if (blockData.get(isScrapPlaceholder)) {\n      return; // For now, don't render placeholders in PDF\n    }\n\n    let style: Style|undefined = undefined;\n    let type: ElementType = ElementType.ACTION; // Default to action.\n\n    if (blockData.get(isFountainCharacter)) {\n      style = styles.characterLine;\n      type = ElementType.CHARACTER;\n\n      if (blockText !== mostRecentCharacter) {\n        mostRecentCharacter = blockText;\n      } else {\n        // If the same character is continuing, label it as (CONT'D)\n        blockText += ' (CONT\\'D)';\n      }\n\n    } else if (blockData.get(isFountainDialogue)) {\n      style = styles.dialogueLine;\n      type = ElementType.DIALOGUE;\n    } else if (blockData.get(isFountainParenthetical)) {\n      style = styles.parentheticalLine;\n      type = ElementType.PARENTHETICAL;\n    } else if (blockData.get(isFountainTransition)) {\n      style = styles.transitionLine;\n      type = ElementType.TRANSITION;\n      mostRecentCharacter = '';\n\n      if (blockText.startsWith('>')) {\n        blockText = blockText.replace(/^>/, '');\n      }\n    } else if (blockData.get(isFountainCentered)) {\n      style = styles.centeredLine;\n      type = ElementType.CENTERED;\n\n      if (blockText.startsWith('>') && blockText.endsWith('<')) {\n        blockText = blockText.replace(/^>/, '').replace(/<$/, '');\n      }\n    } else if (blockData.get(isFountainHeader)) {\n      style = styles.sceneHeaderLine;\n      type = ElementType.SCENE_HEADING;\n      mostRecentCharacter = '';\n\n      if (blockText.startsWith('.')) {\n        blockText = blockText.replace(/^\\./, '');\n      }\n    }\n\n    const nextElement: ScriptElement = {\n      text: blockText,\n      style: style,\n      type: type,\n    };\n\n    const lastElementType = nextPDFBlock.elements.length ? nextPDFBlock.elements[nextPDFBlock.elements.length - 1].type : null;\n\n    if (shouldCreateNewBlock(lastElementType, nextElement.type)) {\n      // Time for a new block\n      pdfBlocks.push(nextPDFBlock);\n      nextPDFBlock = newPDFBlock();\n    } else {\n      // Time to continue the existing block\n    }\n\n    nextPDFBlock.elements.push(nextElement);\n\n  });\n\n  if (nextPDFBlock.elements.length) {\n    pdfBlocks.push(nextPDFBlock);\n  }\n\n  return pdfBlocks.filter((block) => {\n    return !!block.elements.length;\n  });\n}\n\nconst underlineRegex = /_(.*?)_/;\nconst boldItalicRegex = /\\*{3}(.*?)\\*{3}/;\nconst boldRegex = /\\*{2}(.*?)\\*{2}/;\nconst italicRegex = /\\*(.*?)\\*/;\n\nfunction applyRegexSplit(text: string, regex: RegExp, parentStyle: object, thisStyle: object): TextEmphasisBlock[] {\n  const splitResult = text.split(regex);\n\n  if (splitResult.length > 1) {\n    const returnBlocks: TextEmphasisBlock[] = [];\n\n    splitResult.forEach((segment, idx) => {\n      const segmentStyle = idx % 2 === 0 ? parentStyle : {\n        ...parentStyle,\n        ...thisStyle,\n      };\n\n      returnBlocks.push(\n        ...parseTextEmphasis(\n            segment,\n            segmentStyle\n        )\n      );\n    })\n\n    return returnBlocks;\n  }\n\n  return [];\n}\n\nfunction parseTextEmphasis(text: string, parentStyle: object): TextEmphasisBlock[] {\n  const underlineResult = applyRegexSplit(text, underlineRegex, parentStyle, styles.underline);\n  if (underlineResult.length) { return underlineResult; }\n\n  const boldItalicResult = applyRegexSplit(text, boldItalicRegex, parentStyle, styles.boldItalic);\n  if (boldItalicResult.length) { return boldItalicResult; }\n\n  const boldResult = applyRegexSplit(text, boldRegex, parentStyle, styles.bold);\n  if (boldResult.length) { return boldResult; }\n\n  const italicResult = applyRegexSplit(text, italicRegex, parentStyle, styles.italic);\n  if (italicResult.length) { return italicResult; }\n\n  return [{\n    style: parentStyle,\n    text: text,\n  }];\n}\n\nfunction getTitlePage(title: string|null, author: string, contactInfo: string): JSX.Element|null {\n  if (!title) {\n    return null;\n  }\n\n  const dateStr = new Date().toLocaleDateString(\n      'en-US',\n      {year: 'numeric', month: 'long', day: 'numeric'}\n  );\n\n  let metadataSection;\n  if (!!author) {\n    metadataSection = <React.Fragment>\n      <Text style={styles.author}>by</Text>\n      <Text style={styles.author}>{author}</Text>\n      <View style={styles.contactInfo}>\n        {contactInfo.split('\\n').map((contactLine) => {\n          return <Text>{contactLine.trim()}</Text>\n        })}\n      </View>\n      <View style={styles.dateInfo}>\n        <Text>{dateStr}</Text>\n      </View>\n    </React.Fragment>\n  }\n\n  return <Page size=\"LETTER\" style={styles.page}>\n    <View style={styles.title}>\n      {title.split('|').map((titleLine) => {\n        return <Text>{titleLine.trim()}</Text>\n      })}\n    </View>\n    {metadataSection}\n  </Page>;\n}\n\n// Create Document Component\nfunction renderDocument(scrap: Scrap, parsedContentBlocks: ContentBlock[], title: string|null, author: string, contactInfo: string): JSX.Element {\n\n  const parsedPDFBlocks = parsePDFBlocks(parsedContentBlocks);\n\n  const showTitlePage = !!title;\n\n  let pageNumberElement: JSX.Element|null = (<Text style={styles.pageNumber} render={({ pageNumber }) => {\n    const effectivePageNumber = showTitlePage ? (pageNumber - 1) : pageNumber;\n\n    if (effectivePageNumber === 1) {\n      return '';\n    }\n\n    return `${effectivePageNumber}.`\n  }} fixed />);\n\n  return <Document\n      title={scrap.synopsis.replace('|', '')}\n      author={author}\n      creator={author}\n      producer={'Revision (https://jon-simpkins.github.io/revision)'}\n  >\n    {getTitlePage(title, author, contactInfo)}\n    <Page size=\"LETTER\" style={styles.page} wrap>\n      {pageNumberElement}\n      {parsedPDFBlocks.map((pdfBlock) => (\n        <View wrap={false} style={styles.block}>\n          {pdfBlock.elements.map((element) => (\n              <Text style={element.style}>\n                {parseTextEmphasis(element.text, {})\n                    .filter((emphasisBlock) => !!emphasisBlock.text.length)\n                    .map((emphasisBlock) => (\n                  <Text style={emphasisBlock.style}>{emphasisBlock.text}</Text>\n                ))}\n              </Text>\n          ))}\n        </View>\n      ))}\n    </Page>\n  </Document>\n}\n\nexport function renderExamplePDF(printPageProps: PrintPageProps, parsedContentBlocks: ContentBlock[]) {\n  const thisScrap = printPageProps.scrapMap[printPageProps.scrapId] as Scrap;\n\n  const title = printPageProps.headerOptions.includeTitlePage ? thisScrap.synopsis : null;\n\n  return <PDFViewer style={{flex: 1}}>\n    {renderDocument(thisScrap, parsedContentBlocks, title, printPageProps.author, printPageProps.contactInfo)}\n  </PDFViewer>\n}\n","import { RouteComponentProps } from 'react-router';\nimport {useAppDispatch, useAppSelector} from '../../app/hooks';\nimport {ScrapMap, selectScrapMap} from '../../features/scrapList/scrapListSlice';\nimport React, {Component} from 'react';\nimport {ContentBlock} from 'draft-js';\nimport {fetchParsedContentBlocksForScrap} from '../../features/utils/fetchParsedContentBlocksForScrap';\nimport {HeaderOptions, readHeaderOptions, updateHeaderOptions} from '../../features/revision-header/headerOptionsSlice';\nimport {renderExamplePDF} from './savePDF';\nimport {selectContactInfo} from './contactInfoSlice';\nimport {durationSecContribution} from '../../features/scrapDetails/usefulConstants';\n\ninterface MatchParams {\n  id: string\n}\n\ninterface PrintScrapProps extends RouteComponentProps<MatchParams> {}\n\nexport default function PrintScrapPage (props: PrintScrapProps) {\n  const scrapMap = useAppSelector(selectScrapMap);\n  const dispatch = useAppDispatch();\n  const headerOptions = useAppSelector(readHeaderOptions);\n  const contactInfo = useAppSelector(selectContactInfo);\n\n  return (\n      <PrintScrap\n          scrapId={props.match.params.id}\n          scrapMap={scrapMap}\n          onUpdateHeaderOptions={(newHeaderOptions) => dispatch(updateHeaderOptions(\n              {\n                ...headerOptions,\n                ...newHeaderOptions,\n              }))}\n          headerOptions={headerOptions}\n          author={contactInfo.author}\n          contactInfo={contactInfo.contactInfo}\n      />\n  )\n}\n\nexport interface PrintPageProps {\n  scrapId: string;\n  scrapMap: ScrapMap;\n  onUpdateHeaderOptions: (headerOptions: HeaderOptions) => void;\n  headerOptions: HeaderOptions;\n  author: string;\n  contactInfo: string;\n}\n\ninterface PrintPageState {\n  scrapId: string;\n  hasLoaded: boolean;\n  alreadyWarned: boolean;\n  durationPages: number;\n  parsedContentBlocks: ContentBlock[];\n}\n\nexport class PrintScrap extends Component<PrintPageProps, PrintPageState> {\n\n  constructor(props: PrintPageProps) {\n    super(props);\n\n    this.state = {\n      scrapId: props.scrapId,\n      hasLoaded: false,\n      alreadyWarned: false,\n      durationPages: 0,\n      parsedContentBlocks: [],\n    };\n  }\n\n  componentDidMount() {\n    const parsedBlocks = fetchParsedContentBlocksForScrap(this.props.scrapId, [], this.props.scrapMap);\n\n    let totalDurationSec = 0;\n    parsedBlocks.forEach((block) => {\n      const blockData = block.getData();\n      const durationSec = (blockData.get(durationSecContribution) || 0) as number;\n      totalDurationSec += durationSec;\n    });\n\n    this.setState({\n      hasLoaded: true,\n      parsedContentBlocks: parsedBlocks,\n      alreadyWarned: (totalDurationSec <= 60 * 5),\n      durationPages: Math.ceil(totalDurationSec / 60),\n    });\n\n    this.props.onUpdateHeaderOptions({\n      ...this.props.headerOptions,\n      currentScrapId: this.state.scrapId,\n      showReadLink: true,\n      showEditLink: true,\n      showPrintLink: false,\n    });\n  }\n\n  render() {\n    if (!this.state.hasLoaded) {\n      return <div> ... loading ...</div>\n    }\n\n    if (!this.state.alreadyWarned) {\n      return <div style={{\n        margin: '24px'\n      }}>\n        <p>Long PDFs can take a bit to render (this one will be about {this.state.durationPages} pages).</p>\n        <p>Click the following button to render, and then please be patient :) </p>\n        <button onClick={() => {\n          this.setState({\n            alreadyWarned: true\n          });\n        }}>\n          Render PDF\n        </button>\n      </div>\n    }\n\n\n    return <div style={{height: '100%', display: 'flex', flexDirection: 'column'}}>\n      {renderExamplePDF(this.props, this.state.parsedContentBlocks)}\n    </div>;\n  }\n}\n","import React from 'react';\nimport './App.css';\nimport RevisionHeader from './features/revision-header/RevisionHeader';\nimport {\n  HashRouter as Router,\n  Switch,\n  Route\n} from 'react-router-dom';\n\nimport Homepage from './pages/homepage/Homepage';\nimport DataManagementPage from './pages/import-export/DataManagementPage';\nimport ScrapDetailsPage from './pages/scrap-details/ScrapDetailsPage';\nimport DecisionPage from './pages/decisions/DecisionPage';\nimport ReadScrapPage from './pages/read-scrap/ReadScrapPage';\nimport PrintScrapPage from './pages/print-scrap/PrintScrapPage';\n\nfunction App() {\n  return (\n      <div style={{padding: 0, margin: 0, height: '100vh'}}>\n    <Router >\n      <RevisionHeader />\n      <div style={{\n        height: 'calc(100% - 68px)',\n      }}>\n        <Switch>\n          <Route path=\"/decisions\" component={DecisionPage} />\n          <Route path=\"/data\" component={DataManagementPage} />\n          <Route path=\"/scrap/:id\" component={ScrapDetailsPage} />\n          <Route path=\"/read/:id\" component={ReadScrapPage} />\n          <Route path=\"/print/:id\" component={PrintScrapPage} />\n          <Route path=\"/\" component={Homepage} />\n        </Switch>\n      </div>\n    </Router>\n      </div>\n  );\n}\n\nexport default App;\n","import {configureStore, ThunkAction, Action} from '@reduxjs/toolkit';\nimport scrapListReducer, {scrapListPersistenceMiddleware} from '../features/scrapList/scrapListSlice';\nimport headerOptionsReducer from '../features/revision-header/headerOptionsSlice';\nimport contactInfoReducer, {contactInfoPersistenceMiddleware} from '../pages/print-scrap/contactInfoSlice';\n\nexport const store = configureStore({\n  reducer: {\n    scrapList: scrapListReducer,\n    headerOptions: headerOptionsReducer,\n    workspaceContactInfo: contactInfoReducer,\n  },\n  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat([\n    scrapListPersistenceMiddleware,\n    contactInfoPersistenceMiddleware,\n  ])\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\nimport 'semantic-ui-css/semantic.min.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}