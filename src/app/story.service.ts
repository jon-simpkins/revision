import { ApplicationRef, Injectable } from '@angular/core';

import { createDoc, fetchDoc, updateBatch } from '../docsApi/docsApiHelpers';

const STORY_SUMMARIES_KEY = 'STORY_SUMMARIES';

@Injectable({
  providedIn: 'root'
})
export class StoryService {

  storySummaries: object[] = [];
  currentId: string = null;
  currentStoryStr: string = '';

  constructor(private appRef: ApplicationRef) {
    if (localStorage.getItem(STORY_SUMMARIES_KEY)) {
      this.storySummaries = JSON.parse(localStorage.getItem(STORY_SUMMARIES_KEY));
    }
  }

  persistStorySummaries() {
    localStorage.setItem(STORY_SUMMARIES_KEY, JSON.stringify(this.storySummaries));
  }

  createStory() {
    createDoc('Revision Story ' + Date.now())
      .then((response) => {
        let newDocumentId = response.result.documentId;

        this.storySummaries.push({
          id: newDocumentId,
          title: response.result.title
        });
        this.persistStorySummaries();
        this.appRef.tick();

        this.writeHeader(newDocumentId).then((response) => {
          console.log(response);
        });
        // TODO: write / update the changelog
      });
  }

  // Convenience function to write the boilerplate header for the document
  writeHeader(id) {
    let updates = this.insertTextLines(1,
      [
        'Story created in Revision!',
        '',
        '',
        'Do NOT edit this file directly, as doing so might cause Revision to be unable to open it again.',
        '',
        'The intention of storing this document in Google Docs is to clearly delegate all ownership of the content to you, and to allow your exclusive ability to modify the list of folks who can collaborate or view it.',
        '',
        'IF YOU WANT TO IMPORT TO REVISION: simply copy the URL of this page and paste it into the prompt given in the “import” dialog.',
        '',
        '--------------------------'
      ],
      [
        {bold: true, fontSize: this.generateFontSize(18)},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {},
        {bold: true}
      ]
    );

    return updateBatch(
      id,
      updates
    );
  }

  fetchStory(id) {
    if (id === this.currentId) {
      return;
    }

    fetchDoc(id).then((response) => {
      this.currentId = id;
      this.currentStoryStr = JSON.stringify(response.result, null, 4);
      this.appRef.tick();
    });
  }

  // Generates an array of commands to insert text lines to the main body of the document
  insertTextLines(firstStartLocation: number, textLines: string[], styles: object[]) {
    let commands = [];
    let startLocation = firstStartLocation;
    textLines.forEach((line, idx) => {
      commands.push(
        this.insertTextLine(startLocation, line)
      );

      if (Object.keys(styles[idx]).length) {
        commands.push(
          this.applyTextStyle(startLocation, startLocation+line.length, styles[idx])
        );
      }

      startLocation += line.length + 1;
    });

    return commands;
  }

  applyTextStyle(startLocation: number, endLocation: number, style: object) {
    return {
      updateTextStyle: {
        range: {
          startIndex: startLocation,
          endIndex: endLocation
        },
        textStyle: style,
        fields: '*'
      }
    };
  }

  generateFontSize(ptSize: number) {
    return {
      magnitude: ptSize,
      unit: 'PT'
    }
  }

  // Generates a command to insert text to the main body of the document
  insertTextLine(startLocation: number, text: string) {
    return {
      insertText: {
        text: text + '\n',
        location: {
          index: startLocation
        }
      }
    }
  }

}
